#编程基础 #cpp 

面向对象程序设计语言有**封装**、**继承**和**多态**三种机制

- “多态（polymorphism）”指的是同一名字的事物可以完成不同的功能
	- 编译时的多态:*在编译时就能根据实参确定应该调用哪个函数*
		- 函数的重载（包括运算符的重载）、对重载函数的调用
	- **运行时的多态**：***本章的主要内容***
		- 和继承、虚函数等概念有关

# 5.1 C++多态和虚函数快速入门教程

根据上一章内容，通过基类指针只能访问派生类的成员变量，*不能访问派生类的成员函数*

- *虚函数 virtual function*
	- C++提供多态的目的：
		- 可以**通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问**，*尤其是成员函数*。
		- 如果没有多态，我们只能访问成员变量
	- 在派生类的成员函数的声明处，加上virtual；定义可以加但不需要加
	- `virtual void display();`

**多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态。**

```cpp
#include <iostream>
using namespace std;

//基类People
class People{
public:
    People(char *name, int age);
    virtual void display();  //声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是个无业游民。"<<endl;
}

//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  //声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是一名教师，每月有"<<m_salary<<"元的收入。"<<endl;
}

int main(){

    People *p = new People("王志刚", 23);
    // 使用的是基类的成员函数
    p -> display(); // 王志刚今年23岁了，是个无业游民。

	// 使用的是派生类的成员函数
    p = new Teacher("赵宏佳", 45, 8200);
    p -> display();// 赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
    
    return 0;
}
```

> 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。
> 换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态（Polymorphism）**。

像上边这个例子中，同一条语句 `p->display();` 可以执行不同的操作，看起来有不同表现方式，这就是多态。

## 借助引用也可以实现多态

> Hint!
> **引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据**。
> 所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。

```cpp
int main(){
    People p("王志刚", 23);
    Teacher t("赵宏佳", 45, 8200);
   
    People &rp = p;
    People &rt = t;
   
    rp.display(); // 王志刚今年23岁了，是个无业游民。
    rt.display(); // 赵宏佳今年45岁了，是一名教师，每月有8200元的收入。

    return 0;
}
```

## 多态的用途

小项目中很少会用到多态

【实例】：假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。

```cpp
#include <iostream>
using namespace std;

//军队
class Troops{
public:
    virtual void fight(){ cout<<"Strike back!"<<endl; }
};

//陆军
class Army: public Troops{
public:
    void fight(){ cout<<"--Army is fighting!"<<endl; }
};
//99A主战坦克
class _99A: public Army{
public:
    void fight(){ cout<<"----99A(Tank) is fighting!"<<endl; }
};
//武直10武装直升机
class WZ_10: public Army{
public:
    void fight(){ cout<<"----WZ-10(Helicopter) is fighting!"<<endl; }
};
//长剑10巡航导弹
class CJ_10: public Army{
public:
    void fight(){ cout<<"----CJ-10(Missile) is fighting!"<<endl; }
};

//空军
class AirForce: public Troops{
public:
    void fight(){ cout<<"--AirForce is fighting!"<<endl; }
};
//J-20隐形歼击机
class J_20: public AirForce{
public:
    void fight(){ cout<<"----J-20(Fighter Plane) is fighting!"<<endl; }
};
//CH5无人机
class CH_5: public AirForce{
public:
    void fight(){ cout<<"----CH-5(UAV) is fighting!"<<endl; }
};
//轰6K轰炸机
class H_6K: public AirForce{
public:
    void fight(){ cout<<"----H-6K(Bomber) is fighting!"<<endl; }
};

int main(){
    Troops *p = new Troops;
    p ->fight(); // Strike back!
    //陆军
    p = new Army;
    p ->fight(); // --Army is fighting!
    p = new _99A;
    p -> fight(); // ----99A(Tank) is fighting!
    p = new WZ_10;
    p -> fight(); // ----WZ-10(Helicopter) is fighting!
    p = new CJ_10;
    p -> fight(); // ----CJ-10(Missile) is fighting!
    //空军
    p = new AirForce;
    p -> fight(); // --AirForce is fighting!
    p = new J_20;
    p -> fight(); // ----J-20(Fighter Plane) is fighting!
    p = new CH_5;
    p -> fight(); // ----CH-5(UAV) is fighting!
    p = new H_6K;
    p -> fight(); // ----H-6K(Bomber) is fighting!

    return 0;
}
```

根据案例可以发现，只需要声明一个指针变量p，就可以调用所有派生类的虚函数，从而避免了需要创建多个派生类自己的指针变量，容易造成混乱。

通过虚函数与多态，使得只需要一个指针变量就可以完成多个虚函数的调用。从而使得具有复杂继承关系的大中型程序的代码更简洁（只需要一个指针变量）与灵活（实现多个派生类中虚函数的调用）。

# 5.2 C++虚函数注意事项以及构成多态的条件

1) 只需要在**虚函数的声明处加上 virtual 关键字**，函数定义处可以加也可以不加。
2) 为了方便，你可以**只将基类中的函数声明为虚函数**，这样**所有派生类中具有遮蔽关系的同名函数**都将**自动成为虚函数**。
3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。
4) 只有派生类的虚函数覆盖基类的虚函数（**函数原型相同**）才能构成多态（通过基类指针访问派生类函数）
	- 例：
		- **基类虚函数**的原型为`virtual void func();`，
		- **派生类虚函数**的原型为`virtual void func(int);`，
		- 那么**当基类指针 p 指向派生类对象**时，
			- 语句`p -> func();`将调用基类的函数
			- 语句`p -> func(100);`将会出错
5) 构造函数不能是虚函数
6) 析构函数可以声明为虚函数，**而且有时候必须要声明为虚函数**

## 构成多态的条件

三大特征：
- 封装：
	- 所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数
		- public、protected、private
- 继承：
	- 一个类从另一个类获取成员变量和成员函数的过程
- **多态**：
	- 通过**基类的指针**既可以访问**基类的成员**，也可以访问**派生类的成员**
	- 这里的成员就同时包括了成员变量和成员函数

- 构成多态的条件：
	- 必须存在继承关系
	- 继承关系中必须要有同名虚函数，并且是覆盖关系（函数原型相同）
	- 存在基类指针，通过该指针调用虚函数

- 尝试缕清下面这个代码

```cpp
#include <iostream>
using namespace std;

//基类Base
class Base{
public:
    virtual void func();
    virtual void func(int);
};
void Base::func(){
    cout<<"void Base::func()"<<endl;
}
void Base::func(int n){
    cout<<"void Base::func(int)"<<endl;
}

//派生类Derived
class Derived: public Base{
public:
    void func();
    void func(char *);
};
void Derived::func(){
    cout<<"void Derived::func()"<<endl;
}
void Derived::func(char *str){
    cout<<"void Derived::func(char *)"<<endl;
}

int main(){
    Base *p = new Derived(); // 申明基类指针，但是指向派生类对象
    p -> func();  //输出void Derived::func()，构成多态的语句
    p -> func(10);  //输出void Base::func(int)
    p -> func("http://c.biancheng.net");  //compile error，因为函数原型不同，派生类中void func(char *);与基类中没有相同的函数原型，且不是虚函数

    return 0;
}
```

## 什么时候声明虚函数

- 首先看成员函数所在的类是否会作为基类。
- 然后看成员函数在类的继承后有无可能被更改功能
	- 如果希望更改其功能的，一般应该将它声明为虚函数。
	- 如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。

# 5.3 C++虚析构函数的必要性

构造函数不能是虚函数：
- 因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义。  
- C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。

**析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数**

- 【举例】析构函数的必要性

```cpp
#include <iostream>
using namespace std;

//基类
class Base{
public:
    Base();
    ~Base();
protected:
    char *str;
};
Base::Base(){
    str = new char[100];
    cout<<"Base constructor"<<endl;
}
Base::~Base(){
    delete[] str;
    cout<<"Base destructor"<<endl;
}

//派生类
class Derived: public Base{
public:
    Derived();
    ~Derived();
private:
    char *name;
};
Derived::Derived(){
    name = new char[100];
    cout<<"Derived constructor"<<endl;
}
Derived::~Derived(){
    delete[] name;
    cout<<"Derived destructor"<<endl;
}

int main(){
   Base *pb = new Derived();
   delete pb;

   cout<<"-------------------"<<endl;

   Derived *pd = new Derived();
   delete pd;

   return 0;
}
运行结果：  
Base constructor  
Derived constructor  
Base destructor  
-------------------  
Base constructor  
Derived constructor  
Derived destructor  
Base destructor
```

- 此时，基类和派生类中的析构函数都不是虚函数
	- 基类指针无法访问到派生类中的析构函数
		- 从而无法释放派生类中的100个char类型的内存空间
		- 为什么？
			- 因为这里析构函数不是虚函数，而指针又是根据自身类型调用函数的，从而只调用了基类的析构函数
	- 派生类指针调用析构函数，然后调用基类的析构函数
		- 这里的指针是派生类指针，从而能够根据类型匹配到派生类的析构函数
		- 而调用派生类的析构函数又会（隐式）调用到基类的析构函数，参考：[[04.继承与派生#C++基类和派生类的析构函数]]

- **将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数**，参考：[[05.C++多态与虚函数#C++虚函数注意事项以及构成多态的条件]]
	- 大部分情况下都应该将**基类的析构函数**声明为虚函数

# 5.4 C++纯虚函数和抽象类

将虚函数声明为纯虚函数，语法格式：
```cpp
virtual 返回值类型 函数名(函数参数) =0；
```

- 纯虚函数没有函数体，只有函数声明
- 在虚函数结尾加上 ` =0` ，表明该虚函数为纯虚函数
	- 注意：这里的` = 0` 只是形式上的作用，不影响函数返回值及类型，只是告诉编译器这个是纯虚函数
	- 只有类中的虚函数才能被声明为纯虚函数
		- 普通成员函数和顶层函数都不可以

**抽象类 abstract class：包含纯虚函数的类**
- 抽象：指无法实例化，无法创建对象
	- 原因：纯虚函数没有函数体，不是完整的函数，无法调用，也无法分配内存空间
- 一般作为基类，声明纯虚函数。然后将纯虚函数留给派生类去实现。
- **派生类必须要实现全部的纯虚函数才能被实例化**
- 目的：
	- 利用抽象基类，提前声明一些基类不需要的或无法实现的，但是其派生类可能会用到的一些功能（并且强制派生类必须要完成函数体定义）

- 【实例】线-矩形-长方体-正方体

```cpp
#include <iostream>
using namespace std;

//线
class Line{
public:
    Line(float len);
    virtual float area() = 0;
    virtual float volume() = 0;
protected:
    float m_len;
};
Line::Line(float len): m_len(len){ }

//矩形
class Rec: public Line{
public:
    Rec(float len, float width);
    float area();
protected:
    float m_width;
};
Rec::Rec(float len, float width): Line(len), m_width(width){ }
float Rec::area(){ return m_len * m_width; }

//长方体
class Cuboid: public Rec{
public:
    Cuboid(float len, float width, float height);
    float area();
    float volume();
protected:
    float m_height;
};
Cuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height){ }
float Cuboid::area(){ return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); }
float Cuboid::volume(){ return m_len * m_width * m_height; }

//正方体
class Cube: public Cuboid{
public:
    Cube(float len);
    float area();
    float volume();
};
Cube::Cube(float len): Cuboid(len, len, len){ }
float Cube::area(){ return 6 * m_len * m_len; }
float Cube::volume(){ return m_len * m_len * m_len; }

int main(){
    Line *p = new Cuboid(10, 20, 30);
    cout<<"The area of Cuboid is "<<p->area()<<endl;
    cout<<"The volume of Cuboid is "<<p->volume()<<endl;
  
    p = new Cube(15);
    cout<<"The area of Cube is "<<p->area()<<endl;
    cout<<"The volume of Cube is "<<p->volume()<<endl;

    return 0;
}
```

- 注意
	- 这里的rec只实现了area，而没有实现volume，仍然无法实例化

# 5.5 C++虚函数表，多态的实现机制

指针访问类的成员函数时：

- 如果是非虚函数，则编译器根据指针的*类型*寻找该函数
- 如果是虚函数，且派生类有同名的函数遮蔽，则编译器会根据指针的*指向*找到函数
	- 指针指向的对象属于哪个类就调用哪个类的函数，**这就是多态**

> **编译器能够通过指针指向的对象找到虚函数，是因为创建对象时额外增加了虚函数表**

描述：

如果一个类包含了虚函数，那么在创建类的对象的时候就会额外地增加一个*存放了每一个虚函数的地址*的数组，该数组和对象是分开存储的。

为了将对象和数组进行关联，编译器会在对象中设置一个指针，指向数组的起始位置。

这里的数组就是**虚函数表（Virtual function table）**，简写为 `vtable`

【实例】：[vtable](05-vtable.cpp)

![](https://c.biancheng.net/uploads/allimg/190215/14431Q529-0.jpg)

图中左半部分是对象占用的内存，右半部分是虚函数表 vtable。在对象的开头位置有一个指针 vfptr，指向虚函数表，并且这个指针始终位于对象的开头位置。

可以看到，**基类的虚函数在虚函数表中的索引（下标）是固定的，不会随着继承层级的增加而改变**，派生类*新增的*虚函数放在最后。如果派生类中有同名的虚函数遮蔽（覆盖）了基类的虚函数，则直接将派生类的虚函数替换基类的虚函数。

通过指针调用虚函数 `p->display();` ，其具体过程如下：

```cpp
( *( *(p+0) + 0 ) )(p);
```

从内至外进行分析：
- `0` 为vfptr在对象中的偏移，`p+0` 是vfptr的地址
- `*(p+0)` 是vfptr的值，vfptr是指向vtable的指针，所以这个是vtable的地址
- display()在vtable中的索引是0，所以 `(*(p+0)+0)` 也是display()的地址
- 得到了display()的地址，最后就是进行函数调用，即 `(*(*(p+0)+0))(p)` ，这里传入的 `p` 是指针实参，会给 `this` 指针赋值

> **转换后的表达式没有用到与 p 的类型有关的信息，只需要知道 p 的指向**；
> 而名字编码 Name Mangling，会根据函数所在的*命名空间、所属的类、参数列表等信息*进行重命名，二者之间有本质上的区别。

# 5.6 C++ typeid运算符：获取类型信息

**类型信息对编程语言非常重要，它描述了数据的各种属性**：
- 对于基本类型（int、float等C++内置类型）的数据，类型信息：
	- 主要是指*数据的类型*
- 对于*类类型的数据（对象）*，类型信息：
	- **对象所属的类**
	- **所包含的成员**
	- **所在的继承关系**
	- ...
- **类型信息是创建数据的模板**
	- 决定了数据占用多大内存，进行什么样的操作，该如何操作等

### typeid运算符

typeid 运算符：获取一个表达式的类型信息
	返回 type_info 对象的引用

- 两种用法：

```cpp
typeid(dataType)
typeid(expression)
```

- dataType：数据类型
- expression：表达式
- 和sizeof类似，但sizeof有时候可以省略括号，但typeid必须加上括号

【示例】

```cpp
#include <iosrteam>
#include <typeinfo>
using namespace std;

class Base{};
struct STU{};

int main(){
    //获取一个普通变量的类型信息
    int n = 100;
    const type_info &nInfo = typeid(n);
    cout<<nInfo.name()<<" | "<<nInfo.raw_name()<<" | "<<nInfo.hash_code()<<endl;

    //获取一个字面量的类型信息
    const type_info &dInfo = typeid(25.65);
    cout<<dInfo.name()<<" | "<<dInfo.raw_name()<<" | "<<dInfo.hash_code()<<endl;

    //获取一个对象的类型信息
    Base obj;
    const type_info &objInfo = typeid(obj);
    cout<<objInfo.name()<<" | "<<objInfo.raw_name()<<" | "<<objInfo.hash_code()<<endl;

    //获取一个类的类型信息
    const type_info &baseInfo = typeid(Base);
    cout<<baseInfo.name()<<" | "<<baseInfo.raw_name()<<" | "<<baseInfo.hash_code()<<endl;

    //获取一个结构体的类型信息
    const type_info &stuInfo = typeid(struct STU);
    cout<<stuInfo.name()<<" | "<<stuInfo.raw_name()<<" | "<<stuInfo.hash_code()<<endl;

    //获取一个普通类型的类型信息
    const type_info &charInfo = typeid(char);
    cout<<charInfo.name()<<" | "<<charInfo.raw_name()<<" | "<<charInfo.hash_code()<<endl;

    //获取一个表达式的类型信息
    const type_info &expInfo = typeid(20 * 45 / 4.5);
    cout<<expInfo.name()<<" | "<<expInfo.raw_name()<<" | "<<expInfo.hash_code()<<endl;

    return 0;
}
```

```cpp
运行结果：  
int | .H | 529034928  
double | .N | 667332678  
class Base | .?AVBase@@ | 1035034353  
class Base | .?AVBase@@ | 1035034353  
struct STU | .?AUSTU@@ | 734635517  
char | .D | 4140304029  
double | .N | 667332678
```

- type_info类的几个成员函数
	- name() 返回类型的名字
	- raw_name() 返回名字编码（name mangling）算法产生的新名字。[02.C++类和对象（class和object）](02.C++类和对象（class和object）.md)
	- hash_code() 返回当前类型对应的hash值
		- hash值，标志当前类型的整数，依赖于编译器的实现，不同编译器下hash值不同，但都唯一和某个类型对应

## 判断类型是否相等

typeid运算符常用来判断两个类型是否相等

### 对内置类型的比较

```cpp
char *str;
int a = 2;
int b = 10;
float f;
```

类型判断结果为：  

|类型比较|结果|类型比较|结果|
|---|---|---|---|
|`typeid(int) == typeid(int)`|true|`typeid(int) == typeid(char)`|false|
|`typeid(char*) == typeid(char)`|false|`typeid(str) == typeid(char*)`|true|
|`typeid(a) == typeid(int)`|true|`typeid(b) == typeid(int)`|true|
|`typeid(a) == typeid(a)`|true|`typeid(a) == typeid(b)`|true|
|`typeid(a) == typeid(f)`|false|`typeid(a/b) == typeid(int)`|true|

- 注意：
	- 为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，只会为使用了 typeid 运算符的类型创建
	- *带虚函数的类（包括继承的），不管有没有typeid运算符，编译器都会为带虚函数的类创建 type_info 对象*

### 类的比较

给出下边定义：

```cpp
class Base{};
class Derived: public Base{};

Base obj1;
Base *p1;
Derived obj2;
Derived *p2 = new Derived;
p1 = p2;
```

类型判断结果为：  

|类型比较|结果|类型比较|结果|
|---|---|---|---|
|`typeid(obj1) == typeid(p1)`|false|`typeid(obj1) == typeid(*p1)`|true|
|`typeid(&obj1) == typeid(p1)`|true|`typeid(obj1) == typeid(obj2)`|false|
|`typeid(obj1) == typeid(Base)`|true|`typeid(*p1) == typeid(Base)`|true|
|`typeid(p1) == typeid(Base*)`|true|`typeid(p1) == typeid(Derived*)`|false|

- 表达式`typeid(*p1) == typeid(Base)`和`typeid(p1) == typeid(Base*)`的结果为 true 可以说明：即使将派生类[指针](https://c.biancheng.net/c/80/) p2 赋值给基类指针 p1，p1 的类型仍然为 Base*

# 5.7 C++ RTTI机制

**运行时类型识别 Run-Time Type Identification，RTTI**：在程序运行后确定对象的类型信息的机制

C++中，只有当*类中包含了虚函数*时才会启用 RTTI 机制，其他情况都可以在*编译阶段*确定类型信息。

之前提到过，虚函数和多态是相辅相成的，所以，当存在多态时，有些表达式的类型在编译期间是无法确定的，必须要*等到程序运行后*根据实际的环境来确定。下面是一个存在多态需要等待表达式类型的实例

```cpp
#include <iostream>
using namespace std;

//基类
class Base{
public:
    virtual void func();
protected:
    int m_a;
    int m_b;
};
void Base::func(){ cout<<"Base"<<endl; }

//派生类
class Derived: public Base{
public:
    void func();
private:
    int m_c;
};
void Derived::func(){ cout<<"Derived"<<endl; }

int main(){
    Base *p;
    int n;

	// 关键问题在于这里
	// 基类指针p指向基类还是派生类，需要等到程序运行时根据用户输入才能确定
	// 从而使得编译器无法在编译阶段确定*p所表示的对象
	// 即，typeid(*p)表达式的获取的类型就不确定
    cin>>n;
    if(n <= 100){
        p = new Base();
    }else{
        p = new Derived();
    }
    cout<<typeid(*p).name()<<endl;

    return 0;
}
```

**补充知识：**
- 如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量。
- 如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表。
	- **该类的对象内存中还会额外增加*类型信息*，也即 type_info 对象**
- 如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表。

基类和派生类的对象内存模型如下图所示：

![](Pasted%20image%2020231116144447.png)

- 编译器会在虚函数表 vftable 的开头插入一个指针，指向当前类对应的 type_info 对象
	- `**(p->vfptr-1)`
	- 观察内存模型图可以发现，插入的类型信息在虚函数表的最首位，而 vfptr 所指向的位置是基类/派生类的成员函数，所以这里的地址要 `-1`
- 影响：
	- 占用更多内存，效率降低
- 所以，根据上面分析，C++的多态是面向对象的一个重要特征，极大增加了程序的灵活性，但也相应的带来了很大的代价
	- **部分信息无法在编译期间确定，导致编译器需要提前申请更大的内存空间，等待程序运行后才能获取**
	- 导致消耗更多的内存和CPU资源

# 5.8 C++静态绑定和动态绑定

- C/C++ 中：
	- 变量：存储数据
	- 函数：定义可以重复使用的代码
- *都要放到内存中才能供 CPU 使用*

**CPU 访问内存时，需要的是地址，而不是变量名和函数名，这两种名字只是面向编程者的助记符，在源文件被编译和链接成可执行文件后，都会被替换为地址。**

*编译和链接过程的一项重要任务，就是找到这些名称所对应的地址*

假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算`c = a + b;`将会被转换成类似下面的形式：

```cpp
0X3000 = (0X1000) + (0X2000);
```

`( )`表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存。

这里将变量名和函数名统称为**符号 Symbol**，找到符号对应的地址的过程叫做**符号绑定**

## 函数绑定

**找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。**

- *静态绑定 static binding*
	- 编译期间（包括链接期间）就能找到函数名对应的地址，完成函数绑定
- *动态绑定 dynamic binding*
	- 必须等到程序运行后根据具体环境或用户操作才能决定

由于 C++ 是一门静态语言，会尽力在编译期间找到函数的地址，以提高运行效率，但有时候只能等到程序运行后再执行一段代码才能找到函数地址。

例如通过指针调用虚函数时，`( *( *(p+0) + 0 ) )(p);` ，这里的指针 p 就有两个可能指向的对象，编译器不能提前确定，需要等到程序运行

# 5.9 C++ RTTI机制下的对象内存模型

> 在 C++ 中，除了 typeid 运算符，dynamic_cast 运算符和异常处理也依赖于 RTTI 机制，并且要能够通过派生类获取基类的信息，或者说要能够判断一个类是否是另一个类的基类，这样上节讲到的内存模型就不够用了，我们必须要在基类和派生类之间再增加一条`绳索`，把它们`连接`起来，形成一条通路，让程序在各个对象之间`游走`。**在面向对象的编程语言中，我们称此为继承链（Inheritance Chain）**。
> 关于 dynamic_cast 运算符和异常处理，这里暂时只需要知道它们依赖于 RTTI 机制。

总之，像之前建立的简单的基类和派生类的内存模型是无法完整描述真实的内存模型的

这里给出一个简单的例子：

```cpp
class A{
protected:
    int a1;
public:
    virtual int A_virt1();
    virtual int A_virt2();
    static void A_static1();
    void A_simple1();
};

class B{
protected:
    int b1;
    int b2;
public:
    virtual int B_virt1();
    virtual int B_virt2();
};

class C: public A, public B{
protected:
    int c1;
public:
    virtual int A_virt2();
    virtual int B_virt2();
};
```

最终根据上述代码所得到的内存模型如下图所示，[>>>图片来源]([http://www.openrce.org/articles/full_view/23](http://www.openrce.org/articles/full_view/23))

![](Pasted%20image%2020231116150547.png)

> 如果你希望深入了解上图的结构，请查看下面几篇文章：
> - [VC++逆向：类、方法和 RTTI](http://www.openrce.org/articles/full_view/23)
> - [RTTI结构详细分析(VC++)](http://bbs.pediy.com/showthread.php?t=196996)
> - [C++中RTTI机制剖析](http://blog.csdn.net/pi9nc/article/details/21742355)
> - [C++ dynamic_cast实现原理](http://blog.csdn.net/passion_wu128/article/details/38511957)
> - [dynamic_cast, RTTI， 整理](http://www.cnblogs.com/dirichlet/p/3221066.html)

- 静态语言由于类型的限制会降低编码的速度，但是它的执行效率高，适合开发大型的、系统级的程序；
- 动态语言则比较灵活，编码简单，部署容易，在 Web 开发中大显身手



