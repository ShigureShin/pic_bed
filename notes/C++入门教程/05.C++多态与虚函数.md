#编程基础 #cpp 

面向对象程序设计语言有**封装**、**继承**和**多态**三种机制

- “多态（polymorphism）”指的是同一名字的事物可以完成不同的功能
	- 编译时的多态:*在编译时就能根据实参确定应该调用哪个函数*
		- 函数的重载（包括运算符的重载）、对重载函数的调用
	- **运行时的多态**：***本章的主要内容***
		- 和继承、虚函数等概念有关

# 5.1 C++多态和虚函数快速入门教程

根据上一章内容，通过基类指针只能访问派生类的成员变量，*不能访问派生类的成员函数*

- *虚函数 virtual function*
	- C++提供多态的目的：
		- 可以**通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问**，*尤其是成员函数*。
		- 如果没有多态，我们只能访问成员变量
	- 在派生类的成员函数的声明处，加上virtual；定义可以加但不需要加
	- `virtual void display();`

**多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态。**

```cpp
#include <iostream>
using namespace std;

//基类People
class People{
public:
    People(char *name, int age);
    virtual void display();  //声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是个无业游民。"<<endl;
}

//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  //声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是一名教师，每月有"<<m_salary<<"元的收入。"<<endl;
}

int main(){

    People *p = new People("王志刚", 23);
    // 使用的是基类的成员函数
    p -> display(); // 王志刚今年23岁了，是个无业游民。

	// 使用的是派生类的成员函数
    p = new Teacher("赵宏佳", 45, 8200);
    p -> display();// 赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
    
    return 0;
}
```

> 有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。
> 换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态（Polymorphism）**。

像上边这个例子中，同一条语句 `p->display();` 可以执行不同的操作，看起来有不同表现方式，这就是多态。

## 借助引用也可以实现多态

> Hint!
> **引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据**。
> 所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。

```cpp
int main(){
    People p("王志刚", 23);
    Teacher t("赵宏佳", 45, 8200);
   
    People &rp = p;
    People &rt = t;
   
    rp.display(); // 王志刚今年23岁了，是个无业游民。
    rt.display(); // 赵宏佳今年45岁了，是一名教师，每月有8200元的收入。

    return 0;
}
```

## 多态的用途

小项目中很少会用到多态

【实例】：假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。

```cpp
#include <iostream>
using namespace std;

//军队
class Troops{
public:
    virtual void fight(){ cout<<"Strike back!"<<endl; }
};

//陆军
class Army: public Troops{
public:
    void fight(){ cout<<"--Army is fighting!"<<endl; }
};
//99A主战坦克
class _99A: public Army{
public:
    void fight(){ cout<<"----99A(Tank) is fighting!"<<endl; }
};
//武直10武装直升机
class WZ_10: public Army{
public:
    void fight(){ cout<<"----WZ-10(Helicopter) is fighting!"<<endl; }
};
//长剑10巡航导弹
class CJ_10: public Army{
public:
    void fight(){ cout<<"----CJ-10(Missile) is fighting!"<<endl; }
};

//空军
class AirForce: public Troops{
public:
    void fight(){ cout<<"--AirForce is fighting!"<<endl; }
};
//J-20隐形歼击机
class J_20: public AirForce{
public:
    void fight(){ cout<<"----J-20(Fighter Plane) is fighting!"<<endl; }
};
//CH5无人机
class CH_5: public AirForce{
public:
    void fight(){ cout<<"----CH-5(UAV) is fighting!"<<endl; }
};
//轰6K轰炸机
class H_6K: public AirForce{
public:
    void fight(){ cout<<"----H-6K(Bomber) is fighting!"<<endl; }
};

int main(){
    Troops *p = new Troops;
    p ->fight(); // Strike back!
    //陆军
    p = new Army;
    p ->fight(); // --Army is fighting!
    p = new _99A;
    p -> fight(); // ----99A(Tank) is fighting!
    p = new WZ_10;
    p -> fight(); // ----WZ-10(Helicopter) is fighting!
    p = new CJ_10;
    p -> fight(); // ----CJ-10(Missile) is fighting!
    //空军
    p = new AirForce;
    p -> fight(); // --AirForce is fighting!
    p = new J_20;
    p -> fight(); // ----J-20(Fighter Plane) is fighting!
    p = new CH_5;
    p -> fight(); // ----CH-5(UAV) is fighting!
    p = new H_6K;
    p -> fight(); // ----H-6K(Bomber) is fighting!

    return 0;
}
```

根据案例可以发现，只需要声明一个指针变量p，就可以调用所有派生类的虚函数，从而避免了需要创建多个派生类自己的指针变量，容易造成混乱。

通过虚函数与多态，使得只需要一个指针变量就可以完成多个虚函数的调用。从而使得具有复杂继承关系的大中型程序的代码更简洁（只需要一个指针变量）与灵活（实现多个派生类中虚函数的调用）。

# 5.2 C++虚函数注意事项以及构成多态的条件

1) 只需要在**虚函数的声明处加上 virtual 关键字**，函数定义处可以加也可以不加。
2) 为了方便，你可以**只将基类中的函数声明为虚函数**，这样**所有派生类中具有遮蔽关系的同名函数**都将**自动成为虚函数**。
3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。
4) 只有派生类的虚函数覆盖基类的虚函数（**函数原型相同**）才能构成多态（通过基类指针访问派生类函数）
	- 例：
		- **基类虚函数**的原型为`virtual void func();`，
		- **派生类虚函数**的原型为`virtual void func(int);`，
		- 那么**当基类指针 p 指向派生类对象**时，
			- 语句`p -> func();`将调用基类的函数
			- 语句`p -> func(100);`将会出错
5) 构造函数不能是虚函数
6) 析构函数可以声明为虚函数，**而且有时候必须要声明为虚函数**

## 构成多态的条件

三大特征：
- 封装：
	- 所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数
		- public、protected、private
- 继承：
	- 一个类从另一个类获取成员变量和成员函数的过程
- **多态**：
	- 通过**基类的指针**既可以访问**基类的成员**，也可以访问**派生类的成员**
	- 这里的成员就同时包括了成员变量和成员函数

- 构成多态的条件：
	- 必须存在继承关系
	- 继承关系中必须要有同名虚函数，并且是覆盖关系（函数原型相同）
	- 存在基类指针，通过该指针调用虚函数

- 尝试缕清下面这个代码

```cpp
#include <iostream>
using namespace std;

//基类Base
class Base{
public:
    virtual void func();
    virtual void func(int);
};
void Base::func(){
    cout<<"void Base::func()"<<endl;
}
void Base::func(int n){
    cout<<"void Base::func(int)"<<endl;
}

//派生类Derived
class Derived: public Base{
public:
    void func();
    void func(char *);
};
void Derived::func(){
    cout<<"void Derived::func()"<<endl;
}
void Derived::func(char *str){
    cout<<"void Derived::func(char *)"<<endl;
}

int main(){
    Base *p = new Derived(); // 申明基类指针，但是指向派生类对象
    p -> func();  //输出void Derived::func()，构成多态的语句
    p -> func(10);  //输出void Base::func(int)
    p -> func("http://c.biancheng.net");  //compile error，因为函数原型不同，派生类中void func(char *);与基类中没有相同的函数原型，且不是虚函数

    return 0;
}
```

## 什么时候声明虚函数

- 首先看成员函数所在的类是否会作为基类。
- 然后看成员函数在类的继承后有无可能被更改功能
	- 如果希望更改其功能的，一般应该将它声明为虚函数。
	- 如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。

# 5.3 C++虚析构函数的必要性

构造函数不能是虚函数：
- 因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义。  
- C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。

**析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数**

- 【举例】析构函数的必要性

```cpp
#include <iostream>
using namespace std;

//基类
class Base{
public:
    Base();
    ~Base();
protected:
    char *str;
};
Base::Base(){
    str = new char[100];
    cout<<"Base constructor"<<endl;
}
Base::~Base(){
    delete[] str;
    cout<<"Base destructor"<<endl;
}

//派生类
class Derived: public Base{
public:
    Derived();
    ~Derived();
private:
    char *name;
};
Derived::Derived(){
    name = new char[100];
    cout<<"Derived constructor"<<endl;
}
Derived::~Derived(){
    delete[] name;
    cout<<"Derived destructor"<<endl;
}

int main(){
   Base *pb = new Derived();
   delete pb;

   cout<<"-------------------"<<endl;

   Derived *pd = new Derived();
   delete pd;

   return 0;
}
运行结果：  
Base constructor  
Derived constructor  
Base destructor  
-------------------  
Base constructor  
Derived constructor  
Derived destructor  
Base destructor
```

- 此时，基类和派生类中的析构函数都不是虚函数
	- 基类指针无法访问到派生类中的析构函数
		- 从而无法释放派生类中的100个char类型的内存空间
		- 为什么？
			- 因为这里析构函数不是虚函数，而指针又是根据自身类型调用函数的，从而只调用了基类的析构函数
	- 派生类指针调用析构函数，然后调用基类的析构函数
		- 这里的指针是派生类指针，从而能够根据类型匹配到派生类的析构函数
		- 而调用派生类的析构函数又会（隐式）调用到基类的析构函数，参考：[[04.继承与派生#C++基类和派生类的析构函数]]

- **将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数**，参考：[[05.C++多态与虚函数#C++虚函数注意事项以及构成多态的条件]]
	- 大部分情况下都应该将**基类的析构函数**声明为虚函数

# 5.4 C++纯虚函数和抽象类

将虚函数声明为纯虚函数，语法格式：
```cpp
virtual 返回值类型 函数名(函数参数) =0；
```

- 纯虚函数没有函数体，只有函数声明
- 在虚函数结尾加上 ` =0` ，表明该虚函数为纯虚函数
	- 注意：这里的` = 0` 只是形式上的作用，不影响函数返回值及类型，只是告诉编译器这个是纯虚函数
	- 只有类中的虚函数才能被声明为纯虚函数
		- 普通成员函数和顶层函数都不可以

**抽象类 abstract class：包含纯虚函数的类**
- 抽象：指无法实例化，无法创建对象
	- 原因：纯虚函数没有函数体，不是完整的函数，无法调用，也无法分配内存空间
- 一般作为基类，声明纯虚函数。然后将纯虚函数留给派生类去实现。
- **派生类必须要实现全部的纯虚函数才能被实例化**
- 目的：
	- 利用抽象基类，提前声明一些基类不需要的或无法实现的，但是其派生类可能会用到的一些功能（并且强制派生类必须要完成函数体定义）

- 【实例】线-矩形-长方体-正方体

```cpp
#include <iostream>
using namespace std;

//线
class Line{
public:
    Line(float len);
    virtual float area() = 0;
    virtual float volume() = 0;
protected:
    float m_len;
};
Line::Line(float len): m_len(len){ }

//矩形
class Rec: public Line{
public:
    Rec(float len, float width);
    float area();
protected:
    float m_width;
};
Rec::Rec(float len, float width): Line(len), m_width(width){ }
float Rec::area(){ return m_len * m_width; }

//长方体
class Cuboid: public Rec{
public:
    Cuboid(float len, float width, float height);
    float area();
    float volume();
protected:
    float m_height;
};
Cuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height){ }
float Cuboid::area(){ return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); }
float Cuboid::volume(){ return m_len * m_width * m_height; }

//正方体
class Cube: public Cuboid{
public:
    Cube(float len);
    float area();
    float volume();
};
Cube::Cube(float len): Cuboid(len, len, len){ }
float Cube::area(){ return 6 * m_len * m_len; }
float Cube::volume(){ return m_len * m_len * m_len; }

int main(){
    Line *p = new Cuboid(10, 20, 30);
    cout<<"The area of Cuboid is "<<p->area()<<endl;
    cout<<"The volume of Cuboid is "<<p->volume()<<endl;
  
    p = new Cube(15);
    cout<<"The area of Cube is "<<p->area()<<endl;
    cout<<"The volume of Cube is "<<p->volume()<<endl;

    return 0;
}
```

- 注意
	- 这里的rec只实现了area，而没有实现volume，仍然无法实例化

# 5.5 C++虚函数表，多态的实现机制

指针访问类的成员函数时：

- 如果是非虚函数，则编译器根据指针的*类型*寻找该函数
- 如果是虚函数，且派生类有同名的函数遮蔽，则编译器会根据指针的*指向*找到函数
	- 指针指向的对象属于哪个类就调用哪个类的函数，**这就是多态**

> **编译器能够通过指针指向的对象找到虚函数，是因为创建对象时额外增加了虚函数表**

描述：

如果一个类包含了虚函数，那么在创建类的对象的时候就会额外地增加一个*存放了每一个虚函数的地址*的数组，该数组和对象是分开存储的。

为了将对象和数组进行关联，编译器会在对象中设置一个指针，指向数组的起始位置。

这里的数组就是**虚函数表（Virtual function table）**，简写为 `vtable`

【实例】：[vtable](05-vtable.cpp)

![](https://c.biancheng.net/uploads/allimg/190215/14431Q529-0.jpg)

图中左半部分是对象占用的内存，右半部分是虚函数表 vtable。在对象的开头位置有一个指针 vfptr，指向虚函数表，并且这个指针始终位于对象的开头位置。

可以看到，**基类的虚函数在虚函数表中的索引（下标）是固定的，不会随着继承层级的增加而改变**，派生类*新增的*虚函数放在最后。如果派生类中有同名的虚函数遮蔽（覆盖）了基类的虚函数，则直接将派生类的虚函数替换基类的虚函数。

通过指针调用虚函数 `p->display();` ，其具体过程如下：

```cpp
( *( *(p+0) + 0 ) )(p);
```

从内至外进行分析：
- `0` 为vfptr在对象中的偏移，`p+0` 是vfptr的地址
- `*(p+0)` 是vfptr的值，vfptr是指向vtable的指针，所以这个是vtable的地址
- display()在vtable中的索引是0，所以 `(*(p+0)+0)` 也是display()的地址
- 得到了display()的地址，最后就是进行函数调用，即 `(*(*(p+0)+0))(p)` ，这里传入的 `p` 是指针实参，会给 `this` 指针赋值

> **转换后的表达式没有用到与 p 的类型有关的信息，只需要知道 p 的指向**；
> 而名字编码 Name Mangling，会根据函数所在的*命名空间、所属的类、参数列表等信息*进行重命名，二者之间有本质上的区别。

# 5.6 C++ typeid运算符：获取类型信息



