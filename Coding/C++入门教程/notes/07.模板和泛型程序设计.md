#编程基础 #cpp 

**泛型程序设计 generic programming**：
- 一种算法在实现时不指定具体要操作的数据的类型的程序设计方法
- 泛型：算法只需要实现一边，就能适用于多种数据类型
	- 能减少重复代码的编写
- 大量编写模板、使用模板的程序设计

> *泛型程序设计的概念最早出现于 1983 年的 Ada 语言，其最成功的应用就是 C++ 的标准模板库（STL）*

**模板**
- 函数模板
	- 编写函数时要思考能不能写成函数模板
- 类模板
	- 编写类时要思考能不能编写成类模板

# 7.1 C++函数模板

利用函数重载，可以是同一个函数具有多种灵活的功能，例如之前创建的交换两个变量的值的 `Swap()` 函数

```cpp
//交换 int 变量的值
void Swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}

//交换 float 变量的值
void Swap(float *a, float *b){
    float temp = *a;
    *a = *b;
    *b = temp;
}

//交换 char 变量的值
void Swap(char *a, char *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}

//交换 bool 变量的值
void Swap(bool *a, bool *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}
```

但是，这种函数重载本质上还是*定义了三个功能相同、函数体相同的函数*。

**可以利用函数模板来将这三个函数压缩为一个**

> 在 C++ 中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。

**值（Value）和类型（Type）是数据的两个主要特征，它们在C++中都可以被参数化**

**函数模板 Function Template**：建立一个通用函数，其所用到的数据的类型（返回值类型、形参类型、局部变量类型）都可以不指定，而是用一个*虚拟的类型*代替（标识符占位），等发生函数调用时再根据传入实参来逆推类型。

即，*函数模板实现了值的参数化，也实现了类型的参数化*

所以，`Swap()` 函数可以改写为：

```cpp
template<typename T> void Swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}
```

- `template<typename T>`被称为模板头
	- 使用 T、T1、T2、Type 等已经成为了一种惯例

定义模板函数的语法：  

```cpp
template <typename 类型参数1 , typename 类型参数2 , ...> 返回值类型  函数名(形参列表){  
    //在函数体中可以使用类型参数  
}
```

类型参数可以有多个，它们之间以逗号`,`分隔。类型参数列表以`< >`包围，形式参数列表以`( )`包围。

需要注意：

- **模板头和函数定义（声明）是一个不可分割的整体，它们可以换行，但中间不能有分号**

# 7.2 C++类模板

类模板目的，同样是将数据的类型参数化

声明类模板的语法为：

```cpp
template<typename 类型参数1 , typename 类型参数2 , …> class 类名{  
    //TODO:  
};
```

类模板和函数模板都是以 template 开头（当然也可以使用 class，目前来讲它们没有任何区别），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开

假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如：

- x = 10、y = 10
- x = 12.88、y = 129.65
- x = "东经180度"、y = "北纬210度"

  
这个时候就可以使用类模板，请看下面的代码：

```cpp
template<typename T1, typename T2>  //这里不能有分号
class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const;  //获取x坐标
    void setX(T1 x);  //设置x坐标
    T2 getY() const;  //获取y坐标
    void setY(T2 y);  //设置y坐标
private:
    T1 m_x;  //x坐标
    T2 m_y;  //y坐标
};
```

**在类外定义成员函数时仍然需要带上模板头**

格式为：

```cpp
template<typename 类型参数1 , typename 类型参数2 , …>  
返回值类型 类名<类型参数1 , 类型参数2, ...>::函数名(形参列表){  
    //TODO:  
}
```

实现：

```cpp
template<typename T1, typename T2>  //模板头
T1 Point<T1, T2>::getX() const /*函数头*/ {
    return m_x;
}

template<typename T1, typename T2>
void Point<T1, T2>::setX(T1 x){
    m_x = x;
}

template<typename T1, typename T2>
T2 Point<T1, T2>::getY() const{
    return m_y;
}

template<typename T1, typename T2>
void Point<T1, T2>::setY(T2 y){
    m_y = y;
}
```

**除了 template 关键字后面要指明类型参数，类名 Point 后面也要带上类型参数，只是不加 typename 关键字了**

## 使用类模板创建对象

**使用类模板创建对象时，需要指明具体的数据类型**

```cpp
Point<int, int> p1(10, 20);
Point<int, float> p2(10, 15.5);
Point<float, char*> p3(12.4, "东经180度");

// 对象指针
Point<float,float> *p1 = new Point<float, float>(10.6, 109.3);
Point<char*, char*> *p = new Point<char*, char*>("东经180度", "北纬210度");
// 赋值号两边都要指明具体的数据类型，且要保持一致
```

【实例2】用类模板实现可变长数组

```cpp
#include <iostream>
#include <cstring>
using namespace std;
template <class T>
class CArray
{
    int size; //数组元素的个数
    T *ptr; //指向动态分配的数组
public:
    CArray(int s = 0);  //s代表数组元素的个数
    CArray(CArray & a);
    ~CArray();
    void push_back(const T & v); //用于在数组尾部添加一个元素v
    CArray & operator=(const CArray & a); //用于数组对象间的赋值
    T length() { return size; }
    T & operator[](int i)
    {//用以支持根据下标访问数组元素，如a[i] = 4;和n = a[i]这样的语句
        return ptr[i];
    }
};
template<class T>
CArray<T>::CArray(int s):size(s)
{
     if(s == 0)
         ptr = NULL;
    else
        ptr = new T[s];
}
template<class T>
CArray<T>::CArray(CArray & a)
{
    if(!a.ptr) {
        ptr = NULL;
        size = 0;
        return;
    }
    ptr = new T[a.size];
    memcpy(ptr, a.ptr, sizeof(T ) * a.size);
    size = a.size;
}
template <class T>
CArray<T>::~CArray()
{
     if(ptr) delete [] ptr;
}
template <class T>
CArray<T> & CArray<T>::operator=(const CArray & a)
{ //赋值号的作用是使"="左边对象里存放的数组，大小和内容都和右边的对象一样
    if(this == & a) //防止a=a这样的赋值导致出错
    return * this;
    if(a.ptr == NULL) {  //如果a里面的数组是空的
        if( ptr )
            delete [] ptr;
        ptr = NULL;
        size = 0;
        return * this;
    }
     if(size < a.size) { //如果原有空间够大，就不用分配新的空间
         if(ptr)
            delete [] ptr;
        ptr = new T[a.size];
    }
    memcpy(ptr,a.ptr,sizeof(T)*a.size);   
    size = a.size;
     return *this;
}
template <class T>
void CArray<T>::push_back(const T & v)
{  //在数组尾部添加一个元素
    if(ptr) {
        T *tmpPtr = new T[size+1]; //重新分配空间
    memcpy(tmpPtr,ptr,sizeof(T)*size); //拷贝原数组内容
    delete []ptr;
    ptr = tmpPtr;
}
    else  //数组本来是空的
        ptr = new T[1];
    ptr[size++] = v; //加入新的数组元素
}
int main()
{
    CArray<int> a;
    for(int i = 0;i < 5;++i)
        a.push_back(i);
    for(int i = 0; i < a.length(); ++i)
        cout << a[i] << " ";   
    return 0;
}
```

# 7.3 C++模板编程

编程语言根据，“定义变量时，是否需要显式指明数据类型”，分为强类型语言和弱类型语言

#### 1) 强类型语言

强类型语言在定义变量时需要显式地指明数据类型，并且一旦为变量指明了某种数据类型，该变量以后就不能赋予其他类型的数据了，除非经过强制类型转换或隐式类型转换。典型的强类型语言有 C/[C++](https://c.biancheng.net/cplus/)、[Java](https://c.biancheng.net/java/)、[C#](https://c.biancheng.net/csharp/) 等。

#### 2) 弱类型语言

弱类型语言在定义变量时不需要显式地指明数据类型，编译器（解释器）会根据赋给变量的数据自动推导出类型，并且可以赋给变量不同类型的数据。典型的弱类型语言有 [JavaScript](https://c.biancheng.net/js/)、[Python](https://c.biancheng.net/python/)、[PHP](https://c.biancheng.net/php/)、Ruby、Shell、Perl 等。

**类型对于编程语言来说非常重要，不同的类型支持不同的操作**

*强类型语言和弱类型语言，在编译器（解释器）内部都有一个类型系统来维护变量的各种信息*


弱类型语言一般是一边执行一边翻译，这种一边执行一边编译的语言称为解释型语言，而将传统的先编译后执行的语言称为编译型语言。

> 强类型语言较为严谨，在编译时就能发现很多错误，适合开发大型的、系统级的、工业级的项目；
> 而弱类型语言较为灵活，编码效率高，部署容易，学习成本低，在 Web 开发中大显身手。
> 
> 另外，强类型语言的 IDE 一般都比较强大，代码感知能力好，提示信息丰富；而弱类型语言一般都是在编辑器中直接书写代码

**模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（Generic Programming）**

> C++ 模板也是被迫推出的，最直接的动力来源于对[数据结构](https://c.biancheng.net/data_structure/)的封装


**C++ 模板有着复杂的语法，可不仅仅是前面两节讲到的那么简单，它的话题可以写一本书。C++ 模板也非常重要，整个标准库几乎都是使用模板来开发的，[STL](https://c.biancheng.net/stl/) 更是经典之作。**

> STL（Standard Template Library，标准模板库）就是 C++ 对数据结构进行封装后的称呼。

# 7.4 C++函数模板的重载

并非所有的类型都使用同一种算法，有些特定的类型需要单独处理，为了满足这种需求，C++ 允许对函数模板进行重载

例如，Swap() 函数，使用指针和引用的实现方法如下：

```cpp
//方案①：使用指针
template<typename T> void Swap(T *a, T *b){
    T temp = *a;
    *a = *b;
    *b = temp;
}

//方案②：使用引用
template<class T> void Swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}
```

这两种方案都可以交换 int、float、char、bool 等基本类型变量的值，但是**却不能交换两个数组**

**交换两个数组唯一的办法就是逐个交换所有的数组元素**

两个数组交换的代码如下：

```cpp
template<typename T> void Swap(T a[], T b[], int len){
    T temp;
    for(int i=0; i<len; i++){
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
```

在该函数模板中，最后一个参数的类型为具体类型（int），而不是泛型。并*不是所有的模板参数都必须被泛型化*

# 7.5 C++函数模板的实参推断

**使用类模板创建对象时，需要显式指明实参的具体类型**

```cpp
template<typename T1, typename T2> class Point;

Point<int, int> p1(10, 20); //在栈上创建对象
Point<char*, char*> *p = new Point<char*, char*>("东京180度", "北纬210度"); //在堆上创建对象
```

在上述代码中，已经显式指明了T1和T2的类型，编译器不需要自己推断

**函数模板，调用函数时可以不显式指明实参类型**

```cpp
//函数声明
template<typename T> void Swap(T &a, T &b);

//函数调用
int n1 = 100, n2 = 200;
Swap(n1, n2);
float f1 = 12.5, f2 = 56.93;
Swap(f1, f2);
```

在上述代码中，直接将实参传入函数之中，而不需要指明实参的类型

> 在模板实参推断过程中，编译器**使用函数调用中的实参类型**来寻找类型参数的具体类型

## 模板实参推断过程中的类型转换

在普通的函数（非模板函数）的调用时，实参的类型会被进行适当转换以适应形参的类型。比如：
- 算术转换：int转float，char转int，double转int等
- 派生类到基类的转换：即向上转型，[04.继承与派生](04.继承与派生.md)
- const转换：非const转换为const，如 `char *` 到 `const char*`
- 数组或函数指针转换：如果函数形参不是引用类型，数组名会转换为数组指针，函数名也会转换为函数指针
- 用户自定的类型转换

考虑下面的例子：

给出两个函数原型，并调用

```cpp
void func1(int n, float f);
void func2(int *arr, const char *str);

int num[5];
char *url = "http://c.biancheng.net";
func1(12.5, 45);
func2(nums, url);
```

对于 `func1(12.5, 45);` ，12.5会从double转为int，45会从int转为float；
对于 `func2(nums, url);`，nums从 `int[5]` 转为 `int*`，url从 `char *` 转为 `const char*`

*对于函数模板，类型转换仅能进行【const转换】和【数组或函数指针转换】*


```cpp
template<typename T> void func1(T a, T b);
template<typename T> void func2(T *buffer);
template<typename T> void func3(const T &stu);
template<typename T> void func4(T a);
template<typename T> void func5(T &a);

int name[20];
Student stu1("张华", 20, 96.5);  //创建一个Student类型的对象
func1(12.5, 30);  //Error
func2(name);  //name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 int
func3(stu1);  //非const转换为const，T 的真实类型为 Student
func4(name);  //name的类型从 int [20] 换转换为 int *，所以 T 的真实类型为 int *
func5(name);  //name的类型依然为 int [20]，不会转换为 int *，所以 T 的真实类型为 int [20]
```

- 对于`func1(12.5, 30)`，12.5 的类型为 double，30 的类型为 int，编译器不知道该将 T 实例化为 double 还是 int，也不会尝试将 int 转换为 double，或者将 double 转换为 int，所以调用失败。  
  
而 name 本来的类型是`int [20]`：
- 对于`func2(name)`和`func4(name)`，name 的类型会从 `int [20]` 转换为 `int *`，也即将数组转换为指针，所以 T 的类型分别为 `int *` 和 `int`。
- 对于`func5(name)`，name 的类型依然为 `int [20]`，不会转换为 `int *`，所以 T 的类型为 `int [20]`。

**可以发现，当函数形参为引用类型时，数组不会转换为指针，这里就有一个需要注意的问题**，代码如下：

```cpp
template<typename T> void func(T &a, T &b);

int str1[20];
int str2[10];
func(str1, str2); // error
```

代码分析：
- 这里str1类型为 `int [20]`，str2类型为 `int [10]`
- 调用的函数 `func` 为函数模板，此时对于编译器是无法确定应该将T实例化为 `int[20]`还是 `int[10]`，最终导致调用失败

## 为函数模板显式地指明实参（也就是具体的类型）

虽然函数模板能够自行根据传入的实参类型来推断类型参数的具体类型，但是当类型参数的个数较多时，会出现个别的类型无法推断。

此时就需要**显式指明实参类型**

```cpp
template<typename T1, typename T2> void func(T1 a){
	T2 b;
}

func(10);
```

根据代码，func()有两个类型参数，T1和T2，但根据传入实参，只能推断出T1的类型，T2仍是未知的，*此时就需要显式指明*

函数模板的显式指明实参类型和类模板的形式类似，如下：

```cpp
func<int, int>(10);
```

- 此时模板实参会根据“从左到右”的顺序与对应的模板参数匹配（只有尾部即最右的类型参数实参可以省略，*前提是它可以从传入函数的其他实参中推断出来*）

将上述代码修改如下：

```cpp
template<typename T1, typename T2> void func(T2 a){
	T1 b;
}

func<int>(10); // 省略T2的类型，但是可以根据传入的实参10推断出T2的类型
func<int,int>(20); // 显式指明T1、T2
```

## 显式地指明实参时可以应用正常的类型转换

前边提到的，*函数模板仅能进行【const转换】和【数组或函数指针转换】*，是基于编译器自己进行实参推断的前提下。但如果此时进行了*显式地指明类型参数的实参*，就可以正常进行类型转换

如下代码：

```cpp
template<typename T> void func(T a, T b);

func(10, 23.5); // Error，没有显式指明，无法进行类型转换
func<float>(20, 93.7) // 正确，显式指明了类型
```

# 7.6 C++模板的显式具体化

这部分相当于扩充模板的使用方式

先前用 Swap() 函数来举例说明函数模板的使用，但如果涉及到交换两个类就无能为力了。或者是用来获取两个变量中更大的一方的 Max() 函数，`>` 时不能用来比较结构变量、对象及数组的大小的，除非对运算符进行重载。

所以，这就涉及到了对某些特殊的类型进行单独处理。

即，*在创建模板中，针对某种具体的类型进行单独的模板声明，相当于对模板进行了重载*

**模板的显示具体化 Explicit Specialization**

## 函数模板的显式具体化

- 下边的例子中
- 单独针对结构体 STU 进行了显式具体化，使得函数能够对该结构体进行比较

```cpp
#include <iostream>
#include <string>
using namespace std;

typedef struct{
    string name;
    int age;
    float score;
} STU;

//函数模板
template<class T> const T& Max(const T& a, const T& b);
//函数模板的显示具体化（针对STU类型的显示具体化）
template<> const STU& Max<STU>(const STU& a, const STU& b);
//重载<<
ostream & operator<<(ostream &out, const STU &stu);

int main(){
    int a = 10;
    int b = 20;
    cout<<Max(a, b)<<endl;
   
    STU stu1 = { "王明", 16, 95.5};
    STU stu2 = { "徐亮", 17, 90.0};
    cout<<Max(stu1, stu2)<<endl;

    return 0;
}

template<class T> const T& Max(const T& a, const T& b){
    return a > b ? a : b;
}

template<> const STU& Max<STU>(const STU& a, const STU& b){
    return a.score > b.score ? a : b;
}

ostream & operator<<(ostream &out, const STU &stu){
    out<<stu.name<<" , "<<stu.age <<" , "<<stu.score;
    return out;
}
```

- 注意函数声明和定义的格式

```cpp
// 函数声明 Max<STU> 这里的STU是可选的
template<> const STU& Max(const STU& a, const STU& b);

// 函数定义 这里的 Max<STU> 也是同样
template<> const STU& Max(const STU& a, const STU& b){
    return a.score > b.score ? a : b;
}
```

- 调用函数的优先顺序（上到下优先级降低）
	- 非模板函数
	- 显式具体化函数模板
	- 常规模板

## 类模板的显式具体化

【示例】建立 Point 类，输出坐标。要求当横纵坐标中都是字符串时，以 `|` 分割，其余情况均使用 `,` 分割

```cpp
#include <iostream>
using namespace std;

//类模板
template<class T1, class T2> class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const{ return m_x; }
    void setX(T1 x){ m_x = x; }
    T2 getY() const{ return m_y; }
    void setY(T2 y){ m_y = y; }
    void display() const;
private:
    T1 m_x;
    T2 m_y;
};

template<class T1, class T2>  //这里要带上模板头
void Point<T1, T2>::display() const{
    cout<<"x="<<m_x<<", y="<<m_y<<endl;
}

//类模板的显示具体化（针对字符串类型的显示具体化）
template<> class Point<char*, char*>{
public:
    Point(char *x, char *y): m_x(x), m_y(y){ }
public:
    char *getX() const{ return m_x; }
    void setX(char *x){ m_x = x; }
    char *getY() const{ return m_y; }
    void setY(char *y){ m_y = y; }
    void display() const;
private:
    char *m_x;  //x坐标
    char *m_y;  //y坐标
};

//这里不能带模板头template<>
void Point<char*, char*>::display() const{
    cout<<"x="<<m_x<<" | y="<<m_y<<endl;
}

int main(){
    ( new Point<int, int>(10, 20) ) -> display();
    ( new Point<int, char*>(10, "东京180度") ) -> display();
    ( new Point<char*, char*>("东京180度", "北纬210度") ) -> display();

    return 0;
}
```

- 类模板的显式具体化语法

```cpp
// 类模板的显式具体化声明
```template<> class Point<char*, char*>{}
// 因为，类型已经确定
// 所以，对应的成员函数就不需要加上模板头了
void Point<char*, char*>::display() const{}
```

## 部分显式具体化

也可以只对类型参数中的一部分提供实参，*部分显式具体化*

**部分显式具体化只能用于类模板，不能用于函数模板**

- 这里对上一个 Point 类的例子进行修改，现在要求只要横坐标为字符串类型就以 `|` 分隔输出

```cpp
#include <iostream>
using namespace std;

//类模板
template<class T1, class T2> class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const{ return m_x; }
    void setX(T1 x){ m_x = x; }
    T2 getY() const{ return m_y; }
    void setY(T2 y){ m_y = y; }
    void display() const;
private:
    T1 m_x;
    T2 m_y;
};

template<class T1, class T2>  //这里需要带上模板头
void Point<T1, T2>::display() const{
    cout<<"x="<<m_x<<", y="<<m_y<<endl;
}

//类模板的部分显示具体化
template<typename T2> class Point<char*, T2>{
public:
    Point(char *x, T2 y): m_x(x), m_y(y){ }
public:
    char *getX() const{ return m_x; }
    void setX(char *x){ m_x = x; }
    T2 getY() const{ return m_y; }
    void setY(T2 y){ m_y = y; }
    void display() const;
private:
    char *m_x;  //x坐标
    T2 m_y;  //y坐标
};

template<typename T2>  //这里需要带上模板头
void Point<char*, T2>::display() const{
    cout<<"x="<<m_x<<" | y="<<m_y<<endl;
}

int main(){
    ( new Point<int, int>(10, 20) ) -> display();
    ( new Point<char*, int>("东京180度", 10) ) -> display();
    ( new Point<char*, char*>("东京180度", "北纬210度") ) -> display();

    return 0;
}
```

- 注意代码中25行
	- 这里是类模板的部分显式具体化声明
	- `template<typename T2> class Point<char*, T2>{}`
		- 模板头 `template<typename T2>` 中声明的是没有被具体化的类型参数
		- 类名 `Point<char*, T2>` 中列举的是全部类型参数，包括未具体化的和已经被具体化的
			- *类名这里要列举所有参数目的是让编译器确认是哪个类型参数被具体化*

# 7.7 C++模板中的非类型参数

模板，一种泛型技术，目的是*将数据的类型参数化*，增强C++语言（强类型语言）的灵活性

除了类型参数，模板中还可以包括非类型参数

当调用一个函数模板或者通过一个类模板创建对象时，非类型参数会被用户提供的、或者编译器推断出的值所取代

## 在函数模板中使用非类型参数

这里同样回顾在函数模板的重载中 Swap() 函数交换两个数组值的例子，我们创建的函数如下：

```cpp
template<typename T> void Swap(T a[], T b[], int len);
```

- 注意到，这里需要传递一个形参 `len` 来将数组的长度传入函数之中（因为数组名传入函数会被隐式转换为指针，从而在函数体内部是无法通过 `sizeof` 来求得数组长度的）
- 这样对于函数模板的重载，其实用于数组交换的 Swap() 函数的参数就比用于基本数据类的 Swap() 函数，多出来一个需要传入的参数 `len`
- *那么如果想要将多出来这个参数消除，就可以通过模板中的类型参数将其消除*，建立的新 Swap() 函数代码如下

```cpp
template<typename T, unsigned N> void Swap(T (&a)[N], T &b[N]){
	T temp;
	for (int i=0; i<N; i++){
		temp = a[i];
		a[i] = b[i];
		b[i] = temp;
	}
}
```

- 代码分析：
	- 这里的 `T (&a)[N]` 表明 `a` 是一个引用，其数据类型是 `T[N]`；`T (&b)[N]` 同理

此时，只需要将数组名字传入，代码如下；

```cpp
int a[5] = { 1, 2, 3, 4, 5 };
int b[5] = { 10, 20, 30, 40, 50 };
Swap(a, b);
```

- 代码分析：
	- 此时只需要传入数组名字
	- 编译器会根据数组类型 `int` 来代替类型参数 `T`
	- 使用数组长度 `5` 来代替非类型参数 `N`

完整实例如下：

```cpp
#include <iostream>
using namespace std;

template<class T> void Swap(T &a, T &b);
template<typename T, unsigned N> void Swap(T (&a)[N], T (&b)[N]);
template<typename T, unsigned N> void printArray(T (&arr)[N]);

int main(){
    //交换基本类型的值
    int m = 10, n = 99;
    Swap(m, n);  //匹配模板①
    cout<<m<<", "<<n<<endl;

    //交换两个数组
    int a[5] = { 1, 2, 3, 4, 5 };
    int b[5] = { 10, 20, 30, 40, 50 };
    Swap(a, b);  //匹配模板②
    printArray(a);
    printArray(b);

    return 0;
}

template<class T> void Swap(T &a, T &b){
	T temp=a;
	a=b;
	b=temp;
}

template<typename T, unsigned N> void Swap(T (&a)[N], T (&b)[N]){
    T temp;
    for(int i=0; i<N; i++){
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}

template<typename T, unsigned N> void printArray(T (&arr)[N]){
    for(int i=0; i<N; i++){
        if(i == N-1){
            cout<<arr[i]<<endl;
        }else{
            cout<<arr[i]<<", ";
        }
    }
}
```

## 在类模板中使用非类型参数

- 静态数组 static array
	- 数组容量不能动态增加或减小
- **动态数组 dynamic array**
	- 数组容量能够在*使用的过程中*随时增大或减小

```cpp
#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;

template<typename T, int N>
class Array{
public:
    Array();
    ~Array();
public:
    T & operator[](int i);  //重载下标运算符[]
    int length() const { return m_length; }  //获取数组长度
    bool capacity(int n);  //改变数组容量
private:
    int m_length;  //数组的当前长度
    int m_capacity;  //当前内存的容量（能容乃的元素的个数）
    T *m_p;  //指向数组内存的指针
};

template<typename T, int N>
Array<T, N>::Array(){
    m_p = new T[N];
    m_capacity = m_length = N;
}

template<typename T, int N>
Array<T, N>::~Array(){
    delete[] m_p;
}

template<typename T, int N>
T & Array<T, N>::operator[](int i){
    if(i<0 || i>=m_length){
        cout<<"Exception: Array index out of bounds!"<<endl;
    }
    return m_p[i];
}

template<typename T, int N>
bool Array<T, N>::capacity(int n){
    if(n > 0){  //增大数组
        int len = m_length + n;  //增大后的数组长度
        if(len <= m_capacity){  //现有内存足以容纳增大后的数组
            m_length = len;
            return true;
        }else{  //现有内存不能容纳增大后的数组
            T *pTemp = new T[m_length + 2 * n * sizeof(T)];  //增加的内存足以容纳 2*n 个元素
            if(pTemp == NULL){  //内存分配失败
                cout<<"Exception: Failed to allocate memory!"<<endl;
                return false;
            }else{  //内存分配成功
                memcpy( pTemp, m_p, m_length*sizeof(T) );
                delete[] m_p;
                m_p = pTemp;
                m_capacity = m_length = len;
            }
        }
    }else{  //收缩数组
        int len = m_length - abs(n);  //收缩后的数组长度
        if(len < 0){
            cout<<"Exception: Array length is too small!"<<endl;
            return false;
        }else{
            m_length = len;
            return true;
        }
    }
}


int main(){
    Array<int, 5> arr;

    //为数组元素赋值
    for(int i=0, len=arr.length(); i<len; i++){
        arr[i] = 2*i;
    }
   
    //第一次打印数组
    for(int i=0, len=arr.length(); i<len; i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;
   

    //扩大容量并为增加的元素赋值
    arr.capacity(8);
    for(int i=5, len=arr.length(); i<len; i++){
        arr[i] = 2*i;
    }

    //第二次打印数组
    for(int i=0, len=arr.length(); i<len; i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;

    //收缩容量
    arr.capacity(-4);

    //第三次打印数组
    for(int i=0, len=arr.length(); i<len; i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;

    return 0;
}
```

## 非类型参数的限制

*只能是一个整数，或是一个指向对象或函数的指针/引用*

- 当非类型参数是整数时，传递的实参，或由编译器推导出的实参必须是一个*常量表达式*
	- 如：`10、2*30、18+23-4`等，不能是 `n、n+10` 等，n是变量
- 当非类型参数是一个指针（引用）时，绑定到该指针的实参**必须具有静态的生存期**
	- 实参必须存储在虚拟地址空间中的*静态数据区*
	- 局部变量位于栈区，动态创建的对象位于堆区，二者都不能用于实参

# 7.8 C++模板的实例化

模板 Templet 不是真正的函数或类，也不会占用内存。最终生成的函数或类才会占用内存。

**模板的实例化 Instantiate**：由模板生成函数或类的过程

**模板的一个实例 Instantiation**：针对某个类型生成的特定版本的函数或类

*模板的实例化是按需进行的，需要哪个类型就针对哪个类型生成函数或类*

> 编译器会根据传递给类型参数的实参（也可以是编译器自己推演出来的实参）来生成一个特定版本的函数或类，并且相同的类型只生成一次

实例如下；

```cpp
template<typename T> void Swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}

int main(){
    int n1 = 100, n2 = 200, n3 = 300, n4 = 400;
    float f1 = 12.5, f2 = 56.93;
   
    Swap(n1, n2);  //T为int，实例化出 void Swap(int &a, int &b);
    Swap(f1, f2);  //T为float，实例化出 void Swap(float &a, float &b);
    Swap(n3, n4);  //T为int，调用刚才生成的 void Swap(int &a, int &b);

    return 0;
}
```

- 在代码的11行已经实例化了两个参数都为 int 类型的交换函数，所以在13行，再次对两个参数都为 int 类型的实参进行交换时，调用的是之前已经生成过的函数

需要注意类模板的实例化，**通过类模板创建对象时并不会实例化所有的成员函数，只有等到真正调用它们时才会被实例化**

*类的实例化是延迟的、局部的，编译器并不着急生成所有的代码*

通过类模板创建对象时，一般只需要实例化成员变量和构造函数。
- 成员变量被实例化后就知道对象的大小了（占用的字节数）
- 构造函数被实例化后就能够知道如何初始化了
- *对象的创建过程就是分配一块大小已知的内存，并对这块内存进行初始化*

给出下面例子来说明，

```cpp
#include <iostream>
using namespace std;

template<class T1, class T2>
class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const{ return m_x; }
    void setX(T1 x){ m_x = x; }
    T2 getY() const{ return m_y; };
    void setY(T2 y){ m_y = y; };
    void display() const;
private:
    T1 m_x;
    T2 m_y;
};

template<class T1, class T2>
void Point<T1, T2>::display() const{
    cout<<"x="<<m_x<<", y="<<m_y<<endl;
}

int main(){
    Point<int, int> p1(10, 20);
    p1.setX(40);
    p1.setY(50);
    cout<<"x="<<p1.getX()<<", y="<<p1.getY()<<endl;

    Point<char*, char*> p2("东京180度", "北纬210度");
    p2.display();

    return 0;
}
```

- 代码中，
	- p1调用了所有的成员函数，所以此时整个类会被完整地实例化
	- p2只调用了构造函数和display()函数，其他成员函数不会被实例化
- *需要注意*
	- `Point<int,int>` 和 `Point<char*,char*>` 是两个独立的类
		- 类型不同
		- 不兼容
		- 不能自动转换类型
			- 故，`p1=p2;` 这种语句是错误的，除非重载了 ` = `

# 7.9 将C++模板应用于多文件编程

在将函数应用于多文件编程时，我们通常是将函数定义放在源文件（`.cpp`文件）中，将函数声明放在头文件（`.h`文件）中，使用函数时引入（`#include`命令）对应的头文件即可

- **函数声明和函数定义为什么可以分离**
	- 编译是针对单个源文件的，只要有函数声明，编译器就能知道函数调用是否正确
	- 而函数调用和函数定义相对应起来的过程，可以延迟到链接时期
	- 所以，正是因为链接器的存在，函数声明和函数定义才可以分离
- 类的多文件变成也是同理
	- 通过类的声明已经包含了所有成员变量的定义和成员函数的声明
	- 从而编译器可以知道如何创建对象以及如何调用成员函数，只是需要等到链接器将函数调用和函数实现对应起来
- **然而，对于模板的声明和定义，却是将二者全都放到头文件中**
	- *模板的实例化是按需进行的*，用到哪个类型就生成针对哪个类型的函数或类，不会提前生成过多的代码；
	- *模板的实例化是由编译器完成的*，而不是由链接器完成的；
	- *在实例化过程中需要知道模板的所有细节，包含声明和定义*。

# 7.10 C++模板的显式实例化

但，想要将模板的声明和定义分散到不同文件也是有办法的

比如通过代码告诉编译器需要针对*哪个类型*进行实例化，**显式实例化**

## 函数模板的显式实例化

以上节的compare() 函数为例，针对 double 类型的显式实例化代码为：

```cpp
template void Swap(double &a, double &b);
```

将这行代码放到 func.cpp 文件的最后就可以了

再包含函数调用的源文件 main.cpp 中，有一条可选的语句：

```cpp
extern template void Swap(doube &a, double &b);
```

- 作用是明确告诉编译器，该版本的函数实力在其他文件中，需要在链接期间查找
- 当然也可以不写

## 类模板的显式实例化

类模板的显式实例化和函数模板类似，对应的语法为：

```cpp
template class Point<char*, char*>;

//对应的声明形式
extern template class Point<char*, char*>;
```

- 对于类的显式实例化，*会一次性实例化该类的所有成员，包括成员变量和成员函数*

## 显式实例化的缺陷

*必须要在模板的定义文件（实现文件）中对所有使用到的类型进行实例化*

这意味着每次更改了使用模板使用文件（调用函数模板的文件，或者通过类模板创建对象的文件），也要相应地更改模板定义文件，增加对新类型的实例化，或者删除无用类型的实例化

这反而让模板失去了本身的意义。

**所以，最好将模板的声明和定义（实现）全部都放到头文件中去**

# 7.11 C++类模板与继承

## 类模板从类模板派生

```cpp
template <class T1, class T2>
class A
{
    Tl v1; T2 v2;
};
template <class T1, class T2>
class B : public A <T2, T1>
{
    T1 v3; T2 v4;
};
template <class T>
class C : public B <T, T>
{
    T v5;
};
int main()
{
    B<int, double> obj1;
    C<int> obj2;
    return 0;
}
```

- 第18行
	- 编译器用 `int` 替换类模板 B 的 `T1`，`double` 替换 `T2`，生成 `B<int,double>` 类
	- `B<int,double>` 的基类是 `A<double,int>`，进而编译器生成`A<double,int>` 类
- 第19行
	- 编译器生成 `C<int>` 类
	- 以及其直接基类 `B<int,int>` ，以及 `B<int,int>` 的基类 `A<int,int>`

## 类模板从模板类派生

```cpp
template<class T1, class T2>
class A{ T1 v1; T2 v2; };

template <class T>
class B: public A <int, double>{T v;};

int main() { B <char> obj1; return 0; }
```

- 第4行
	- `A<int,double>` 是一个具体的类的名字，并且是一个模板类
- 第5行
	- `B<Char>obj1;` 自动生成两个模板类
		- `A<int,double>`
		- `B<char>`

## 类模板从普通类派生

```cpp
class A{ int v1; };

template<class T>
class B: public A{
	T v;
};

int main (){ B <char> obj1; return 0; }
```

## 普通类从模板类派生

```cpp
template <class T>
class A{ T v1; int n; };

class B: public A <int>{
	double v;
};

int main() { B obj1; return 0; }
```

# 7.12 C++类模板与友元

## 函数、类、类的成员函数作为类模板的友元

```cpp
void Func1() {  }
class A {  };
class B
{
public:
    void Func() { }
};
template <class T>
class Tmpl
{
    friend void Func1();
    friend class A;
    friend void B::Func();
};
int main()
{
    Tmpl<int> i;
    Tmpl<double> f;
    return 0;
}
```


- 类模板实例化时，除了类型参数被替换外，其他所有内容都原样保留，因此任何从 Tmp1 实例化得到的类都包含上面三条友元声明，因而也都会把 Func1、类 A 和 B::Func 当作友元

## 函数模板作为类模板的友元

## 函数模板作为类的友元

## 类模板作为类模板的友元

# 7.13 C++类模板中的静态成员

*类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员*




