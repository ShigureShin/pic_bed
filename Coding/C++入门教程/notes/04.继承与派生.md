#编程基础 #cpp 

# 4.1 C++继承和派生

继承是类与类之间的关系

- **继承 Inheritance**
	- 一个类从另一个类获取成员变量和成员函数的过程
- **派生 Derive**
	- 继承的另一个角度

- 父类/基类
	- 被继承的类
- 子类/派生类
	- 继承的类
- 父类-子类 / 基类-派生类，称呼分别对应

**使用继承的场景**：
- 创建的新类与现有的类相似，只是多出若干成员变量或成员函数
- 需要创建多个类，并且拥有很多个相似的成员变量或成员函数

- 【举例】

- 基类People

	```cpp
// 基类People
class People{
public:
	void setname(char *name);
	void setage(int age);
	char *getname();
	int getage();
private:
	char *m_name;
	int m_age;
};
void People::setname(char *name){ m_name = name; }
void People::setage(int age){ m_age = age; }
char* People::getname(){ return m_name; }
int People::getage(){ return m_age;}
```

- 派生类Student

	```cpp
//派生类 Student
class Student: public People{
public:
	void setscore(float score);
	float getscore();
private:
	float m_score;
};
void Student::setscore(float score){ m_score = score; }
float Student::getscore(){ return m_score; }
```

- 继承的一般语法：

```cpp
class 派生类名:[继承方式 private（默认）、public、protected] 基类名{
派生类新增加的成员（变量/函数）
}；
```

# 4.2 C++三种继承方式

## public、protected、private 修饰类的成员

- 类成员的访问权限由高到低依次为 public --> protected --> private
	- public 成员可以通过对象来访问
	- private、protected 成员不能通过对象访问
- **当存在继承关系时，protected 和 private 不一样**
	- **基类中的 protected 成员可以在派生类中使用**
	- **基类中的 private 成员不能在派生类中使用**

## public、protected、private 指定继承方式

**1) public继承方式**
- 基类中所有 public 成员在派生类中为 public 属性；
- 基类中所有 protected 成员在派生类中为 protected 属性；
- 基类中所有 private 成员在派生类中**不能使用**。 
**2) protected继承方式**
- 基类中的所有 public 成员在派生类中为 protected 属性；
- 基类中的所有 protected 成员在派生类中为 protected 属性；
- 基类中的所有 private 成员在派生类中**不能使用**。
**3) private继承方式**
- 基类中的所有 public 成员在派生类中均为 private 属性；
- 基类中的所有 protected 成员在派生类中均为 private 属性；
- 基类中的所有 private 成员在派生类中**不能使用**。

**分析结论**：
- 基类成员在派生类中的访问权限不得高于继承方式中指定的权限
- 基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）
	- 希望基类成员能被派生类继承并使用，声明为public或protected
	- 不希望使用，声明为private
	- 希望基类成员不暴露（不能通过对象调用），但能在基类中使用，声明为protected
- 基类的private成员不能在派生类中使用，**但是能够被继承的**，并且**还会占用派生对象的内存**，只是不可见无法使用
- **派生类中访问基类private成员的唯一方法**
	- 借助基类的非private成员函数
	- 如果基类无非private成员函数，则无法访问

|继承方式/基类成员|public成员|protected成员|private成员|
|---|---|---|---|
|public继承|public|protected|不可见|
|protected继承|protected|protected|不可见|
|private继承|private|private|不可见|

## 改变访问权限

using 关键字：
- 只能改变基类中public和protected的访问权限
- private无法改变

```cpp
class Student : public People{
public:
	void leanring();
public:
	// protected -> public
	using People::m_name;
	using People::m_age;
	float m_socre;
private:
	// public -> private
	using People::show;
};
```

# 4.3 C++继承时的名字遮蔽问题

- **基类成员**会被**派生类中重名成员**遮蔽
	- 如果想要访问被遮蔽的基类成员
		- 加上类名和域解析符
		- `stu.People::show();`

## 基类成员函数和派生类成员函数不构成重载

- 对于成员函数
	- 重名问题会导致遮蔽
	- **不会有重载问题**
		- 话句话说，重载只会发生在同一个作用域中的同名函数之间
		- 不同作用域之间的同名函数会互相遮蔽
		- 优先匹配自身作用域，再去匹配外层作用域，**永远不会去自身所包含的更次级的作用域中匹配**

# 4.4 C++类继承时的作用域嵌套

类 -> 作用域

继承关系使得派生类的作用域被嵌套在基类的作用域之内，如下图


![类继承时的作用域嵌套](https://c.biancheng.net/uploads/allimg/190214/16450K5H-1.jpg)

- 内层作用域 inner scope：被嵌套/被包含的作用域
- 外层作用域：包含着别的作用域的作用域

- **名字查找 name lookup**
	- 在作用域链中寻找所用名字最匹配的声明或定义的过程
	- **只会由自己所在作用域向外层逐层匹配，不会从本作用域向内层匹配**

# 4.5 C++继承时的对象内存模型

无继承时，成员变量和成员函数分开存储：
- 成员变量
	- 存储在栈区或堆区（new创建对象时）
- 成员函数
	- 单独存放在代码区
- 参考：[[02.C++类和对象（class和object）#2.4 C++对象的内存模型]]

## 继承时的内存模型

obj_a 为基类对象，obj_b 为派生类对象

**成员变量按照派生的层级依次排列，新增成员变量始终在最后**

![](https://c.biancheng.net/uploads/allimg/190214/164629A03-0.jpg)
![](https://c.biancheng.net/uploads/allimg/190214/1646293113-1.jpg)

*所有成员函数仍然存放在代码区*

## 有成员变量遮蔽时的内存分布

![](https://c.biancheng.net/uploads/allimg/190214/16462a427-3.jpg)

- **总结：**
	- 在派生类的对象模型中，会包含所有基类的成员变量。
	- 这种设计方案的优点
		- 访问效率高，能够在派生类对象中直接访问基类变量，无需经过好几层间接计算

# 4.6 C++基类和派生类的构造函数

**类的构造函数不能被继承**，只有普通的成员函数会被继承

- 问题：
	- 基类中存在一些private成员变量，在派生类中无法被访问，因而建立派生类的构造函数时，会出现无法对一些基类成员初始化的异常
	- 这种矛盾在C++继承中普遍存在
- 解决思路：
	- 在派生类的构造函数中**调用基类的构造函数**

```cpp
class Student:public People{
private:
	float m_score;
public:
	Student(char *name, int age, float score);
	...
};
// 基类构造函数调用只能这么放在初始化列表中（函数头部），放在函数体中是错误的
// 函数头部是对基类构造函数的调用，而不是声明，所以括号里的参数是实参
// 还可以可以这么写People("XiaoMing", 10)
Student::Student(char *name, int age, float score):People(name, age),m_score(score){}
...
```

- **派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码）**

## 构造函数的调用顺序

- **构造函数的调用顺序**是按照**继承的层次自顶向下**、**从基类再到派生类**的
	- 创建派生类对象：
		- 先调用**基类构造函数**
		- 再调用**派生类构造函数**
	- **注意：**
		- 派生类构造函数的调用，只能是**直接基类的构造函数**
			- 如`A类构造函数 --> B类构造函数 --> C类构造函数`
			- C无法调用A的构造函数，这种调用其实是*隐式*实现的，因为B中会调用A的

# 4.7 C++基类和派生类的析构函数

析构函数**同样不能**被继承

- 与构造函数不同的
- 在派生类的析构函数中**不用显式地调用**基类的析构函数
- 因为**每个类只有一个析构函数**，编译器知道如何选择，无需程序员干涉

- 构造函数的执行顺序
	- 创建派生类对象时，构造函数的执行顺序**和继承顺序相同**
		- 先执行**基类构造函数**
		- 再执行**派生类构造函数**
- 析构函数的执行顺序
	- 销毁派生类对象时，析构函数的执行顺序**和继承顺序相反**
		- 先执行**派生类析构函数**
		- 再执行**基类析构函数**

# 4.8 C++多继承（多重继承）

派生类
- 只有一个基类 -> **单继承 Single Inheritance**
- 有多个基类 -> **多继承 Multiple Inheritance**

> 多继承容易让代码逻辑复杂、思路混乱，中小型项目中较少使用

多继承的语法也很简单，将多个基类用逗号隔开即可。例如已声明了类A、类B和类C，那么可以这样来声明派生类D：

```cpp
class D: public A, private B, protected C{  
    //类D新增加的成员  
}
```

D 是多继承形式的派生类，它以公有的方式继承 A 类，以私有的方式继承 B 类，以保护的方式继承 C 类。D 根据不同的继承方式获取 A、B、C 中的成员，确定它们在派生类中的访问权限。

# 4.9 C++多继承时的对象内存模型

基类对象的排列顺序和继承时声明的顺序相同

A、B为基类，C为派生类

![](https://c.biancheng.net/uploads/allimg/190610/1-1Z61013103M49.gif)

# 4.10 借助指针访问private、protected属性的成员变量

指针可以突破访问限制，从而获取private和protected属性的成员变量

- private、protected的这种限制，**仅仅是语法层面**

## 使用偏移

涉及到对内存地址的操作

![](https://c.biancheng.net/uploads/allimg/190214/1F25G5O-0.jpg)

- 思路：
	- 图中假设 obj 对象的起始地址为 0X1000，m_a、m_b、m_c 与对象开头分别相距 0、4、8 个字节，这段距离称为**偏移（Offset）**。
	- 一旦知道了对象的起始地址，再加上偏移就能够求得成员变量的地址，知道了成员变量的地址和类型，也就能够轻而易举地知道它的值。


```cpp
A *p = newA(40, 50, 60);
int b = p->m_b;
```

此时编译器内部会发生类似下面的转换：

```cpp
int b = *(int*)( (int)p + sizeof(int) );
```

- p 是对象 obj 的指针，`(int)p`将指针转换为一个整数，这样才能进行加法运算；
- `sizeof(int)`用来计算 m_b 的偏移；
- `(int)p + sizeof(int)`得到的就是 m_b 的地址
- 因为此时是`int`类型，所以还需要强制转换为`int *`类型；
- 开头的`*`用来获取地址上的数据

![](https://c.biancheng.net/uploads/allimg/190214/1F25K924-1.jpg)

## 突破访问权限的限制

C++ 的成员访问权限**仅仅是语法层面**上的
- 是指访问权限仅对取成员运算符`.`和`->`起作用
- 无法防止直接通过指针来访问

# 4.11 C++虚继承和虚基类

多继承带来的问题：
- 其中之一：命名冲突

【例1】

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: public A{
protected:
    int m_b;
};

//直接基类C
class C: public A{
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    void seta(int a){ B::m_a = a; }  //正确，指明继承自B
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

## 虚继承（Virtual Inheritance）

- 目的：解决多继承时的命名冲突和冗余数据问题
- 方案：**虚继承**，在派生类中只保留一份间接基类的成员
	- 继承方式前面加上 virtual 关键字就是虚继承
	- 虚继承的目的是让某个类做出声明，承诺愿意**共享它的基类**（虚基类 virtual base class）
- 问题：
	- **必须在虚继承的真实需求出现前完成虚派生的操作**

【例2】

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

- 通过虚继承，在派生类D中只保留一份成员变量`m_a`

# 4.12 C++虚继承时的构造函数

...

# 4.13 C++虚继承下的内存模型

...

# 4.14 C++将派生类赋值给基类（向上转型）

- 数据类型转换的前提是
	- **编译器知道如何对数据进行取舍**
```cpp
int a = 10.9;
printf("%d\n", a); // 10，不会四舍五入，而是小数部分直接丢掉
```

**赋值的本质：向内存填充数据**

- 类其实也是一种数据类型，也可以发生数据类型转换
	- 基类与派生类之间才有意义
	- 只能将派生类赋给基类：*会忽略派生类新增的成员*，这一赋值过程不可逆（即基类不能给派生类赋值）
		- 派生类对象赋值给基类对象
		- 派生类指针赋值给基类指针
		- 派生类引用赋值给基类引用
	- 由于对象的内存中只有成员变量，所以对象之间的赋值本质是*成员变量之间的赋值*
- 在 C++ 中称为**向上转型（Upcasting）**
	- 非常安全，编译器自动完成
- 相应地，**将基类赋值给派生类称为向下转型（Downcasting）**
	- 有风险，需要手动干预

## 将派生类对象赋值给基类对象

- 【实例1-对象】
```cpp
#include <iostream>
using namespace std;

//基类
class A{
public:
    A(int a);
public:
    void display();
public:
    int m_a;
};
A::A(int a): m_a(a){ }
void A::display(){
    cout<<"Class A: m_a="<<m_a<<endl;
}

//派生类
class B: public A{
public:
    B(int a, int b);
public:
    void display();
public:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"Class B: m_a="<<m_a<<", m_b="<<m_b<<endl;
}


int main(){
    A a(10);
    B b(66, 99);
    //赋值前
    a.display();
    b.display();
    cout<<"--------------"<<endl;
    //赋值后
    a = b;
    a.display();
    b.display();

    return 0;
}
运行结果：  
Class A: m_a=10  
Class B: m_a=66, m_b=99  
----------------------------  
Class A: m_a=66  
Class B: m_a=66, m_b=99
```

## 将派生类指针赋值给基类指针

- 【实例2-指针】
```cpp
#include <iostream>
using namespace std;

//基类A
class A{
public:
    A(int a);
public:
    void display();
protected:
    int m_a;
};
A::A(int a): m_a(a){ }
void A::display(){
    cout<<"Class A: m_a="<<m_a<<endl;
}

//中间派生类B
class B: public A{
public:
    B(int a, int b);
public:
    void display();
protected:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"Class B: m_a="<<m_a<<", m_b="<<m_b<<endl;
}

//基类C
class C{
public:
    C(int c);
public:
    void display();
protected:
    int m_c;
};
C::C(int c): m_c(c){ }
void C::display(){
    cout<<"Class C: m_c="<<m_c<<endl;
}

//最终派生类D
class D: public B, public C{
public:
    D(int a, int b, int c, int d);
public:
    void display();
private:
    int m_d;
};
D::D(int a, int b, int c, int d): B(a, b), C(c), m_d(d){ }
void D::display(){
    cout<<"Class D: m_a="<<m_a<<", m_b="<<m_b<<", m_c="<<m_c<<", m_d="<<m_d<<endl;
}


int main(){
    A *pa = new A(1);
    B *pb = new B(2, 20);
    C *pc = new C(3);
    D *pd = new D(4, 40, 400, 4000);

    pa = pd;
    pa -> display();

    pb = pd;
    pb -> display();

    pc = pd;
    pc -> display();

    cout<<"-----------------------"<<endl;
    cout<<"pa="<<pa<<endl;
    cout<<"pb="<<pb<<endl;
    cout<<"pc="<<pc<<endl;
    cout<<"pd="<<pd<<endl;

    return 0;
}
运行结果：  
Class A: m_a=4  
Class B: m_a=4, m_b=40  
Class C: m_c=400  
-----------------------  
pa=0x9b17f8  
pb=0x9b17f8  
pc=0x9b1800  
pd=0x9b17f8
```

- 对象指针之间的赋值并**没有拷贝对象的成员**，也**没有修改对象本身的数据**，**仅仅是改变了指针的*指向***
- 注意这里，`pa = pd; pa -> display();`，这里虽然将a的指针指向了d，但是使用display成员函数**仍然为a自己的成员函数**。而又由于指针已经从a指向了d，所以display内部使用的却是d类对象的成员变量
	- 原因：
		- 编译器通过指针访问成员变量，指针指向哪个对象就使用哪个对象的数据
		- 编译器通过指针的*类型*访问成员函数，对于pa，它的类型始终是A，不管指向哪个对象，都是使用A类自己的成员函数
			- 参考：[[02.C++类和对象（class和object）#2.5 C++函数编译原理和成员函数的实现]]
			- 成员函数与类绑定，而与创建的实例对象无关，所以是根据*指针的类型*访问成员函数

## 将派生类引用赋值给基类引用

- 引用在本质上是通过指针的方式实现的

```cpp
int main(){
    D d(4, 40, 400, 4000);
   
    A &ra = d;
    B &rb = d;
    C &rc = d;
   
    ra.display();
    rb.display();
    rc.display();

    return 0;
}
运行结果：  
Class A: m_a=4  
Class B: m_a=4, m_b=40  
Class C: m_c=400
```

- ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 display() 函数，从运行结果可以发现，虽然**使用了派生类对象的成员变量**，但是却**没有使用派生类的成员函数**，这和指针的表现是一样的。

# 4.15 将派生类指针赋值给基类指针时到底发生了什么？

- 使用int和double类型之间的赋值进行铺垫
	- 下面例子中输出结果可以看到pi和n的数值其实并不相同
	- 即：赋值虽然是对内存数值的拷贝，但*编译器会在赋值前进行处理*
	- 这里从double赋值给int的具体过程：
		- 首先*编译器会将小数点及之后的部分全部丢弃*，将double型数据转换为int型数据（**赋值前的操作**）
		- 然后才会将这个int型数据*赋值*给变量n（**真正的赋值操作**）
		- *这里的第一步“将double型数据转换为int型数据”是理解上一节中复制指针地址不同问题的关键*
```cpp
#include <iostream>
using namespace std;

int main(){
    double pi = 3.14159;
    int n = pi;
    cout<<pi<<", "<<n<<endl;
    return 0;
}
运行结果：  
3.14159, 3
```

- 将派生类指针赋值给基类的指针时也是同理

需要明确一个前提，对象的指针必须要指向*对象的起始位置*。

先给出D类对象的内存模型：![](https://c.biancheng.net/uploads/allimg/190214/1G5491A0-0.jpg)

可以看到，A、B类的子对象在D类对象的内存中的位置和D类对象一样，所以直接pd赋值给pa和pb；

但是对于C类子对象，按照内存模型，其地址举例D类对象的地址是有一定*偏移*的，所以将pd赋值时，需要先经由编译器处理，即*加上这个偏移*，从而指向C类子对象的地址，再进行*赋值*。

所以，`pc=pd;`这一过程用代码描述为：

```cpp
pc = (C*)((int)pd+sizeof(B));
```

先经过编译器对地址的偏移调整，变成了C类子对象的地址，再进行赋值

> 个人理解：
> 	可以按照类型转换的方式理解
> 	指针pc的类型为C类，指针pd的类型为D类。将pd赋值给pc，类似于将double赋值给int（直观上的理解），都是将目标类型中不需要的部分移除，从需要的部分开始获取。
> 	所以，从double转为int，去掉了小数点及之后的数值。而从D类转为C类，则去掉了D类中继承自A、B类的部分。






