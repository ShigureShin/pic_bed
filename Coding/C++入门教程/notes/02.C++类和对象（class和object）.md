#编程基础 #cpp
# 2.1 C++类的定义和对象的创建

## 类的定义

```cpp
class Student{
public:
// member variable
	const char *name;
	int age;
	float score;
// member function
	void say(){
		std::cout<<name<<age<<score<<std::endl;
	}
};
```

类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。

每个对象都是类的一个具体实例（Instance），拥有类的成员变量和成员函数

**类只是一个模板（Template），编译后不占用内存空间**，所以*在定义类时不能对成员变量进行初始化，因为没有地方存储数据*。只有在**创建对象以后才会给成员变量分配内存**，这个时候就可以赋值了。

对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。

## 创建对象

```cpp
Student liLei; // create object
Student allStu[100];
class Student liLei; // ok, too
```

## 访问类的成员

通过点号`.`来访问**成员变量**和**成员函数**

```cpp
int main(){
	Student stu;
	
	stu.name = "XiaoMing";
	stu.age = 16;
	stu.score=92.5f;
	stu.say();
	
	return 0;
}
```

- stu 是一个Student类的*对象*，占据内存空间

## 使用对象指针

- 在栈上创建类的对象
	- 栈上创建出来的对象都有一个名字，比如stu
	- 使用指针指向不是必须的
```cpp
Student stu;
Student *pStu = &stu; // 通过 & 操作符获取地址
```

- 在堆上创建类的对象
	- 使用 new 创建出来的对象在堆上分配内存，没有名字
	- 只能得到一个指向它的指针
	- 即：**new 在堆上创建出来的对象是匿名的，必须用一个指针指向再借助指针访问成员**
	- 可以使用 delete 删除 new 创建出来的对象，从而释放内存，避免无用内存堆积
```cpp
// 在堆上创建对象
Student *pStu = new Student;
// 访问对象使用 ->
pStu->name = "XiaoMing";
pStu->age = 15;
pStu->score = 92.5f;
pStu->say();

delete pStu; // 删除对象
```

## 总结

- 两种创建对象的方式
	- 栈上创建 `Student stu;`
		- 对象有名字 stu
		- 不要求有指针指向
	- 堆上创建 `Student *pStu = new Student;`
		- 堆上创建对象没有名字，必须要用指针指向
		- 要用 delete 删除不再使用的对象
- 访问对象成员
	- 通过名字访问：`.`
	- 通过指针访问：`->`

# 2.2 C++类的成员变量和成员函数

定义类的时候不能对成员变量赋值，因为类本身只是一种数据类型或模板，本身不占用内存控件。

- 类的成员函数与普通函数的区别：
	- 成员函数：
		- 是类的一个成员
		- 作用范围由类决定
	- 普通函数：
		- 独立
		- 作用范围全局或某个命名空间

**在类体中声明成员函数，在类体外定义成员函数**：

```cpp
class Student{
public:
	const char *name;
	int age;
	float score;
	// 声明成员函数
	void say();
};
// 定义成员函数
void Student::say(){
	std::cout<<name<<age<<score<<std::endl;
}
```

- **注意：**
	- 在类体外定义成员函数要在函数名前加上类名加以限定
		- `void Student::say(){};`
		- `::` 域解析符（作用域运算符或作用域限定符），指明属于哪个类

**成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前**

## 在类体中和类体外定义成员函数的区别

- 在类体中和类体外定义成员函数的区别：
	- 在类体中定义的成员函数会自动成为内联函数
	- 在类体外定义的不会

> **内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义**

# 2.3 C++类成员的访问权限以及类的封装

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员

**C++中的类没有共有私有之分**

- 类的内部：无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制
- 类的外部：只能通过对象访问成员
	- public：可以访问
	- private，protected不可以访问

## 类的封装

> 根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，而**只将允许通过对象调用的成员函数声明为 public**。

**所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数**

# 2.4 C++对象的内存模型

- 类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中
- 对象是实实在在的数据，需要内存来存储
	- 创建时会在栈区或堆区分配内存

对于不同对象之间，编译器会将成员变量和成员函数分开存储：
- 分别对每个成员变量分配内存
- 所有对象共享一段函数代码

成员变量在堆区或栈区分配内存，成员函数在代码区分配内存

# 2.5 C++函数编译原理和成员函数的实现

## C++函数的编译

- C语言中的函数在编译时名字不变，或者只是简单的加一个下划线`_`（不同的编译器有不同的实现）
- C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名
	- 对函数重命名的过程叫做**名字编码（Name Mangling）**
		- 这一过程可逆
		- 确保函数名的唯一性
		- 命名空间、所属的类、包含的参数列表有一个不同，最后的新函数名也不同

## 成员函数的调用

> C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量

```cpp
void Demo::display(){
	std::cout<<a<<endl;
	std::cout<<b<<endl;
}
```

编译后的代码类似于：

```cpp
void new_function_name(Demo * const p){
	std::cout << p->a << endl;
	std::cout << p->b << endl;
}
```

- 最后需要提醒的是，`Demo * const p`中的 const 表示指针不能被修改，p 只能指向当前对象，不能指向其他对象

# 2.6 C++构造函数

- 构造函数：constructor
	- 类的成员函数
	- 名字与类名相同
	- 无返回值
		- 不管声明还是定义，函数名前都不能加返回值类型，**void也不行**
		- 函数体中不能有 return 语句
	- 不需要显式调用，在创建对象时自动执行
		- **构造函数必须是 public 属性的**，否则创建对象时无法调用

## 构造函数的重载

- 允许重载
- 创建对象时，根据传递的实参来判断调用哪一个构造函数
	- 创建对象时只有一个构造函数会被调用
- 构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，例如对成员变量赋值、预先打开文件等。

## 默认构造函数

- （没有自定义构造函数时）编译器会自动生成默认的构造函数
	- 默认创建：一个空函数体，无形参，不执行任何操作的构造函数
	- **调用没有参数的构造函数也可以省略括号**
		- `Student *pstu = new Student()` 或 `Student *pstu = new Student`

# 2.7 C++构造函数初始化列表

- 构造函数最重要目的：
	- **对成员变量进行初始化**

```cpp
#include <iostream>

class Student{
private:
	char *m_name;
	int m_age;
	float m_score;
public:
	Student(char *name, int age, float score);
	void show();
};
// 初始化列表
Student::Student(char *name, int age, float score):m_name(name),m_age(age),m_score(score){}
void Student::show(){
	std::cout << m_name << m_age << m_score << std::endl;
}
int main(){
	Student stu("XiaoMing", 15, 92.5f);
	stu.show();
	Student *pstu = new Student("LiHua", 16, 96);
	pstu->show();
	return 0;
}
```

- 注意其中的初始化成员列表
	- 在函数首部与函数体之间添加了一个冒号`:`，后面紧跟`m_name(name), m_age(age), m_score(score)`语句
	- 这个语句的意思相当于函数体内部的`m_name = name; m_age = age; m_score = score;`语句，也是赋值的意思。
	- **成员变量的初始化顺序与初始化列表中的顺序无关，只与成员变量在类中声明的顺序有关**

## 初始化 const 成员变量

- **初始化 const 成员变量的唯一方法就是使用初始化列表**

```cpp
class VLA{
private:
	const int m_len;
	int *m_arr;
public:
	VLA(int len);
};
VLA::VLA(int len){
	m_len = len;
	m_arr = new int[len];
}
```

# 2.8 C++析构函数

- 与构造函数对应：
- ==销毁对象时系统也会自动调用一个函数来进行清理工作==
	- 例如释放分配内存、关闭打开的文件等
- **析构函数**
	- 析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行
	- 析构函数的名字是在类名前面加一个`~`符号
- **注意**
	- 没有参数，不能重载
		- 所以，一个类只能由一个析构函数
	- 编译器可以自动生成
	- 析构函数名中的`~`是一个特殊情况

## 析构函数的执行时机

- **析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关**
	- **全局对象**：所有函数之外创建的对象
		- 内存分区：全局数据区
		- **程序结束执行时**调用析构函数
	- **局部对象**：函数内部创建的对象
		- 内存分区：栈区，类似于局部变量
		- **函数执行结束时**调用析构函数
	- new 创建的对象
		- 内存分区：堆区
		- delete 删除时才调用析构函数；，没有 delete 不会执行析构函数

# 2.9 C++对象数组（数组的每个元素都是对象）

- C++ 允许数组的每个元素都是对象，这样的数组称为对象数组
	- **每个元素都需要用构造函数初始化**
	- 具体哪些元素用哪些构造函数初始化，取决于定义数组时的写法

```cpp
#include <iostream>
using namespace std;
class CSample{
public:
	CSample(){ // 析构函数1
		cout << "Constructor 1 Called" << endl;
	}
	CSample(int n){ // 析构函数2
		cout << "Constructor 2 Called" << endl;
	}
};

int main(){
    cout<<"stepl"<<endl;
    CSample arrayl[2]; // 未指明初始化参数

    cout<<"step2"<<endl;
    CSample array2[2] = {4, 5}; // 指明成员各自的初始化参数

    cout<<"step3"<<endl;
    CSample array3[2] = {3}; // 只指明一个成员的初始化参数

    cout<<"step4"<<endl;
    CSample* array4 = new CSample[2]; // 未指明初始化参数
    delete [] array4;

    return 0;
}
```

- 执行结果：
```cpp
stepl  
Constructor 1 Called  
Constructor 1 Called  
step2  
Constructor 2 Called  
Constructor 2 Called  
step3  
Constructor 2 Called  
Constructor 1 Called  
step4  
Constructor 1 Called  
Constructor 1 Called
```

# 2.10 C++成员对象和封闭类详解

- 一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class）

## 成员对象的初始化

- **封闭类构造函数的初始化列表**

构造函数初始化列表的写法如下：

```cpp
类名::构造函数名(参数表): 成员变量1(参数表), 成员变量2(参数表), ...  
{  
    //TODO:  
}
```

举例：
- 建立“轮胎类”和“引擎类”
```cpp
// 轮胎类
class Tyre{...};
// 轮胎类的构造函数
Tyre::Tyre(int radius, int width) : m_radius(radius), m_width(width){...}
// 引擎类
class Engine{...};
// 引擎类的构造函数
Engine::Engine(float displacement) : m_displacement(displacement) {...}
// 汽车类：封闭类
// 有两个成员对象
class Car{
public:
	Car(int price, int radius, int width);
	...
private:
	int m_price;
	Trye m_trye;
	Engine m_engine;
};
// 汽车类的构造函数
// 在初始化列表中对轮胎类和引擎类进行初始化（传入参数，从而调用各自的构造函数）
Car::Car(int price, int radius, int width): m_price(price), m_tyre(radius, width)/*指明m_tyre对象的初始化方式*/{...};
```

## 成员对象的消亡

- 封闭类对象生成时
	- 先执行**所有成员对象**的构造函数
		- 执行次序：与成员对象在*类定义中*的次序一致
	- 然后执行**封闭类自己的构造函数**

- 封闭类对象消亡时
	- 先执行**封闭类的析构函数**
	- 然后执行**成员对象的析构函数**
		- 执行次序：与成员对象在*类定义中*的次序*相反*

# 2.11 C++ `this` 指针

- `this`
	- C++中的关键字
	- const 指针
	- 指向当前对象，使用`->`来访问成员变量或成员函数
	- **只有在对象被创建后才会给this赋值**，且赋值过程为隐式由编译器自动完成
- **注意**
	- this 是 const 指针，不能修改值
	- 只能在**成员函数内部**使用
	- 只有**当对象被创建后**才有意义，不能在 static 成员函数中使用

## this 到底是什么

- 成员函数的隐式形参，由编译器在编译阶段将其添加到参数列表
	- 本质上是*成员函数的局部变量*
- 在调用成员函数时，将对象的地址作为实参传递给this
- 由于成员函数最终会被编译成与对象无关的普通函数（内存分配），除了成员变量，会丢失所有信息，所以需要在编译时在成员函数中添加一个额外参数（即this），把当前对象的首地址传入，从而关联成员变量和成员函数

# 2.12 C++ static静态成员变量

在同类的不同对象之间共享数据

- 使用 static 修饰，静态成员变量

```cpp
class Student{
public:
	Studnet(char *name, int age, float socre);
	...
public:
	static inti m_total; // 静态成员变量
private:
	char *m_name;
	int m_age;
	float m_score;
};
```

- static成员变量**属于类**，不属于某个对象
- 多个对象之间只会给 m_total 分配一份内存

- **注意：**
	- **static成员变量必须在类声明的外部初始化**
	- `type class::name=value;`
	- 初始化时不需要再加static，但必须有数据类型type
	- 被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化
- **static 成员变量的内存**既不是在声明类时分配，也不是在创建对象时分配，而是**在（类外）初始化时分配**
- **所以不创建对象也可以访问static成员变量**

```cpp
int main(){
//创建==匿名对象==
(new Student("小明", 15, 90)) -> show();
(new Student("李磊", 16, 80)) -> show();
(new Student("张华", 16, 99)) -> show();
(new Student("王康", 14, 60)) -> show();
// 使用匿名对象无法回收内存，会导致内存泄露
return 0;
}
```

## 几点说明

1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它
2) static 成员变量和普通 static 变量一样，都==在内存分区中的全局数据区分配内存，到程序结束时才释放。==这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存
3) 静态成员变量必须初始化，而且只能在类体外进行
	- 初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0
	- ==全局数据区的变量都有默认的初始值 0==
	- ==而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。==
4) 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。

# 2.13 C++ static静态成员函数

- **静态成员函数只能访问静态成员**
	- 这也是静态成员函数的目的

- 静态成员函数与普通成员函数区别
	- 普通成员函数
		- 有this指针
		- 可以访问类中任意成员
		- 只能创建对象后通过对象调用
	- 静态成员函数
		- 无this指针
		- 只能访问静态成员（变量和函数）
		- 无论有没有创建对象，都可以调用（可以直接通过类调用）

# 2.14 C++ const成员变量和成员函数（常成员函数）

**用const来防止某些数据被修改**

## const成员变量
- 声明时加上const关键字
- 初始化时只能通过构造函数的初始化列表
- 值不可修改
## const成员函数（常成员函数）
- 可以访问类中所有的成员变量
- 但是不能修改它们的值
- **常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字**
	- *注意是声明和定义时都需要在函数头部结尾处加上*

```cpp
class Student{
public:
    Student(char *name, int age, float score);
    void show();
    //声明常成员函数
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }

void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

//定义常成员函数
char * Student::getname() const{
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}
```

- 区分一下const位置：
	- 函数开头的 const 用来**修饰函数的返回值**，表示返回值是 const 类型
	- 函数头部的结尾加上 const 表示常成员函数，这种函数**只能读取成员变量的值**，而不能修改成员变量的值

# 2.15 C++ const对象（常对象）

定义常对象的语法和定义常量的语法类似：

```cpp
const  class  object(params);  
class const object(params);
```

当然你也可以定义 const [指针](https://c.biancheng.net/c/80/)：

```cpp
const class *p = new class(params);  
class const *p = new class(params);
```

`class`为类名，`object`为对象名，`params`为实参列表，`p`为指针名。两种方式定义出来的对象都是常对象。

- 对象被定义为常对象，**只能访问被 const 修饰的成员**
	- 因为非const成员可能会修改对象的数据

# 2.16 C++友元函数和友元类（C++ friend关键字）

**借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员**

## 友元函数

# 2.17 类其实也是一种作用域

- 每个类都会定义它自己的作用域
- 在类的作用域之外，
	- 普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问
	- 静态成员既可以通过对象访问，又可以通过类访问
	- ==typedef 定义的类型只能通过类来访问==

```cpp
#include<iostream>
using namespace std;

class A{
public:
    typedef int INT;
    static void show();
    void work();
};
void A::show(){ cout<<"show()"<<endl; }
void A::work(){ cout<<"work()"<<endl; }
A::INT A::return_Num(){return 0;} // 这里必须要加上A::来指明INT的定义

int main(){
    A a;
    a.work();  //通过对象访问普通成员
    a.show();  //通过对象访问静态成员
    A::show();  //通过类访问静态成员
    A::INT n = 10;  //通过类访问 typedef 定义的类型

    return 0;
}
```

# 2.18 C++ class和struct到底有什么区别

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
- 类的成员
	- 使用 class 时，类中的成员默认都是 private 属性的
	- 使用 struct 时，结构体中的成员默认都是 public 属性的
- 类的集成
	- **class 继承默认是 private 继承**
	- **struct 继承默认是 public 继承**
- class 可以使用模板，而 struct 不能

# 2.19 C++ string # 字符串

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string s1; // 默认初始化为""，空字符串
    string s2 = "c plus plus"; // string的结尾没有'\0'
    string s3 = s2;
    string s4 (5, 's'); // 5 个's'字符组成的字符串“sssss”
    
	string s = "http://c.biancheng.net";
	int len = s.length(); // length()得到长度
	cout<<len<<endl; // string没有'\0'，所以得到的长度是真实长度
	
    return 0;
}
```

## 转换为C风格的字符串

- 使用C语言中的 fopen() 函数打开文件，必须将 string 字符串转换为C风格的字符串
```cpp
string path = "D:\\demo.txt";
FILE *fp = fopen(path.c_str(), "rt"); // c_str()来转换为c风格字符串
```

## string 字符串的输入输出

输入运算符`>>`默认会忽略空格，遇到空格就认为输入结束

## 访问字符串中的字符

string 字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符。string 字符串的起始下标仍是从 0 开始

## 字符串的拼接

- 可以使用`+`或`+=`运算符来直接拼接字符串
	- 不用担心空间不够会溢出

## string 字符串的增删改查

### 一. 插入字符串

- insert() 函数可以在 string 字符串中指定的位置插入另一个字符串
	- pos 表示要插入的位置，也就是下标（有越界可能）
	- str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串
```cpp
string& insert (size_t pos, const string& str);
```

### 二. 删除字符串

- erase() 函数可以删除 string 中的一个子字符串
	- pos 表示要删除的子字符串的起始下标，
	- len 表示要删除子字符串的长度。
		- 如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len = str.length - pos）
		- 待删除字符串最多只能删除到字符串结尾
```cpp
string& erase (size_t pos = 0, size_t len = npos);
```

### 三. 提取子字符串

- substr() 函数用于从 string 字符串中提取子字符串
	- pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。
		- 如果 pos 越界，会抛出异常；
		- 如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。
```cpp
string substr (size_t pos = 0, size_t len = npos) const;
```

### 四. 字符串查找

#### 1) find() 函数

- find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：

```cpp
size_t find (const string& str, size_t pos = 0) const;  
size_t find (const char* s, size_t pos = 0) const;
```

- 第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。
- 返回的是子字符串**第一次出现**在字符串中的起始下标

#### 2) rfind() 函数

- rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回 string::npos

#### 3) find_first_of() 函数

- find_first_of() 函数用于查找子字符串和字符串==共同具有的字符在字符串中首次出现的位置==。

# 2.20 C++ string的内部究竟是什么样的？

在C语言中，有两种方式表示字符串：

- 一种是用字符数组来容纳字符串，例如`char str[10] = "abc"`，这样的字符串是可读写的；
- 一种是使用字符串常量，例如`char *str = "abc"`，这样的字符串只能读，不能写。

- **string 在内部封装了与内存和容量有关的信息**
	- 具体地说，C++ string 对象知道自己在内存中的开始位置、包含的字符序列以及字符序列长度；当内存空间不足时，string 还会自动调整，让内存空间增长到足以容纳下所有字符序列的大小
- string类的**内存布局**（C++标准没有规定）
	- **但必须保证string的行为一致性**
- string **内存分配规则**明确规定
	- 允许但不要求以引用计数（reference counting）的方式实现
	- 但无论是否采用引用计数，其语义都必须一致
		- 在C语言中，**每个字符型数组**都占据**各自的物理存储区**。
		- 在 C++ 中，独立的几个 string 对象**可以占据也可以不占据**各自特定的物理存储区
		- **但采用引用计数避免了保存同一数据的拷贝样本，则各个对象（在处理上）必须表现得像是独自拥有各自的存储区一样**
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1("12345");
    string s2 = s1;
    cout << (s1 == s2) << endl;
    s1[0] = '6';
    cout << "s1 = " << s1 << endl;  //62345
    cout << "s2 = " << s2 << endl;  //12345
    cout << (s1 == s2) << endl;

    return 0;
}

在 GCC 下的运行结果：  
1  
s1 = 62345  
s2 = 12345  
0
```
- **只有当字符串被修改的时候才创建各自的拷贝，这种实现方式称为写时复制（copy-on-write）策略**
- 但遗憾的是，在多线程程序中，几乎不可能安全地使用引用计数来实现





