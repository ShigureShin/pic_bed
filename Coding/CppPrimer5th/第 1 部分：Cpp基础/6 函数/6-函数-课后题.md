#cpp 

---

## 6.3 返回类型和return语句

### 6.3.2 有返回值的函数

#### [练习 6.30](src/6-30.cpp)

> 编译第200页的 str_subrange 函数，看看你的编译器是如何处理函数中错误的。

解：

错误信息如下：
```cpp
warning: control reaches end of non-void function [-Wreturn-type] 
```

#### 练习 6.31

> 什么情况下返回的引用无效？什么情况下返回常量的引用无效？

解：

- 返回的引用为局部变量时，返回的引用无效
- 需要修改函数返回值时，返回常量的引用无效

#### 练习 6.32

> 下面的函数合法吗？如果合法，说明其功能；如果不合法，修改其中的错误并解释原因。

```c
int &get(int *array, int index) { return array[index]; }
int main()
{
    int ia[10];
    for (int i = 0; i != 10; ++i)
        get(ia, i) = i;
}
```

解：

合法。
get 函数接收一个整型数组指针和索引值，并返回该数组在给定索引位置的元素引用

#### [练习 6.33](src/6-33.cpp)

> 编写一个递归函数，输出 vector 对象的内容。

#### 练习 6.34

> 如果 factorial 函数的停止条件如下所示，将发生什么？

```c
if (val != 0)
```

解：

factorial 函数为：
```cpp
int factorial(int val)
{
	if(val>1)
		return factorial(val-1)*val;
	return 1;
}
```

修改为题目中的中止条件后，计算的结果不会发生变化，具体执行步骤中多计算了一次与 1 的相乘

#### 练习 6.35

> 在调用 factorial 函数时，为什么我们传入的值是 val-1 而非 val--？

解：

- 如果传入 val--，因为是后置自减运算符，会导致先使用 val 的值调用 factorial 函数，再对 val-1
- 而此时，被调用的 factorial 函数之中又会再次进行 val--的操作，从而导致一直递归调用下去，直至函数调用栈使用完毕

### 6.3.3 返回数组指针

#### 练习 6.36

> 编写一个函数声明，使其返回数组的引用并且该数组包含10个 string 对象。不用使用尾置返回类型、decltype 或者类型别名。

解：

```cpp
string (&func())[10];
```

#### 练习 6.37

> 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。你觉得哪种形式最好？为什么？

解：

```cpp
// 类型别名
typedef string STR[10];
STR &func();

// 尾置返回类型
auto func()->string(&)[10];

// decltype关键字
string str[10];
decltype(str) &func();
```

尾置返回类型更好，书写简便，类型明了

#### 练习 6.38

> 修改arrPtr函数，使其返回数组的引用。

解：

```cpp
decltype(odd)& arrPtr(int i)
{
    return (i % 2) ? odd : even;
}
```

#### 练习 6.39

> 说明在下面的每组声明中第二条语句是何含义。如果有非法的声明，请指出来。

```c
(a) int calc(int, int);
	int calc(const int, const int);
(b) int get();
	double get();
(c) int *reset(int *);
	double *reset(double *);
```

解：
a. 非法。顶层 const 不影响传入的对象，编译器无法区分这两个函数
b. 非法。函数重载应该是形参的数量或类型不同，而与返回值的类型无关
c. 合法。

## 6.5 特殊用途语言特性

### 6.5.1 默认参数

#### 练习 6.40

> 下面的哪个声明是错误的？为什么？

```c
(a) int ff(int a, int b = 0, int c = 0); // 正确
(b) char *init(int ht = 24, int wd, char bckgrnd);//错误，设置了默认值的形参之后的所有形参都必须设置默认值
```

#### 练习 6.41

> 下面的哪个调用是非法的？为什么？哪个调用虽然合法但显然与程序员的初衷不符？为什么？

```c
char *init(int ht, int wd = 80, char bckgrnd = ' ');
(a) init();
(b) init(24,10);
(c) init(14,'*');
```

a. 非法。ht 不是默认参数
b. 合法
c. 合法。但违背初衷。原因是第二个形参类型为 int，而传入的是 char 类型，虽然不会出错，但违背初衷

#### [ 练习 6.42](src/6-42.cpp)

> 给 make_plural 函数的第二个形参赋予默认实参's', 利用新版本的函数输出单词 success 和 failure 的单数和复数形式。


### 6.5.2 内联函数与 constexpr 函数

#### 练习 6.43

> 你会把下面的哪个声明和定义放在头文件中？哪个放在源文件中？为什么？

```c
(a) inline bool eq(const BigInt&, const BigInt&) {...}
(b) void putValues(int *arr, int size);
```

解：
a 为内联函数，b 为函数声明，二者都应该放在头文件中

#### 练习 6.44

> 将6.2.2节的isShorter函数改写成内联函数。

解：

```cpp
inline bool isShorter(const string &s1, const string &s2)
{
	return s1.size() < s2.size();
}
```

#### 练习 6.45

> 回顾在前面的练习中你编写的那些函数，它们应该是内联函数吗？如果是，将它们改写成内联函数；如果不是，说明原因。

解：内联机制通常用于优化规模较小、流程直接、频繁调用的函数

#### 练习 6.46

> 能把isShorter函数定义成constexpr函数吗？如果能，将它改写成constxpre函数；如果不能，说明原因。

解：不能。constexpr 函数要求形参和返回值都为字面值类型

#### [练习 6.47](src/6-47.cpp)

> 改写6.3.2节练习中使用递归输出 vector 内容的程序，使其有条件地输出与执行过程有关的信息。例如，每次调用时输出 vector 对象的大小。分别在打开和关闭调试器的情况下编译并执行这个程序。

#### 练习 6.48

> 说明下面这个循环的含义，它对 assert 的使用合理吗？

```c
string s;
while (cin >> s && s != sought) { } //空函数体
assert(cin);
```

解：
循环含义，判断输入的字符串 s 是否为'sought'
应该为：`assert(s == sought)`



