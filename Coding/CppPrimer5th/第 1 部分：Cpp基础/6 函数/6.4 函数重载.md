#cpp 

---

**重载函数**：同一作用域中的几个*函数名字相同*但*形参列表不同*

> main 函数不能重载

**重载函数的返回类型必须相同**

形参列表的不同可以是*形参数量不同*，也可以是*形参类型不同*，编译器会根据传入的实参类型确定需要调用的函数

**判短两个形参的类型是否相异**

- 下面声明的是同一个函数
```cpp
Record lookup(const Account &acct);
Record lookup(const Account&); // 省略了形参名字
// 形参名字只起到帮助记忆的作用，有没有并不影响形参列表的内容

typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&); // Telno和Phone的类型相同
// 这里的Telno只是Phone的别名
```

**重载和 const 形参**

- 顶层 const 不影响传入函数的对象，所以*拥有顶层 const 的形参*无法和另一个*没有顶层 const 的形参*区分开来

```cpp
Record lookup(Phone);
Record lookup(const Phone); // 重复声明

Record lookup(Phone*);
Record lookup(Phone* const); // 重复声明
```

- 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时 const 是底层的

```cpp
Record lookup(Account&); // Account引用
Record lookup(const Account&); // 常量引用
```

当*传递一个非常量对象或指向非常量对象的指针*时，编译器*优先选择非常量版本*的函数

> **何时不应该重载函数**
> 需要函数的名字来使得程序更容易理解

**const_cast 和重载**

```cpp
const string &shorterString(const string &s1, const string &s2)
{
	return s1.size() <= s2.size() ? s1:s2;
}
```

这个函数的参数和返回类型都为 const string 的引用，如果传递两个非常量的 string 实参，返回类型仍然是 const string 的引用

为了使得传入实参为非常量时获得非常量的返回，可以使用 `const_cast`

```cpp
string &shorterString(string &s1, string &s2)
{
	auto &r = shorterString(const_cast<const string&>(s1),
							const_cast<const string&>(s2));
	return const_cast<string&>(r);
}
```

### 6.4.1 重载与作用域

**不同作用域种无法重载函数名**，*内层作用域中声明名字*，将会*隐藏外层作用域*中声明的同名实体
