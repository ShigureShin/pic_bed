#computer

---

# 什么是静态链表

用数组的方式实现的链表

- 单链表：结点在内存中散布
- **静态链表**：分配一整片连续的内存空间，结点集中安置
	- 每个位置保存：
		- 数据元素
		- 下一个节点的*数组下标/游标*
	- 0 号结点为头节点

![](img/Pasted%20image%2020231209145259.png)

- 如果每个数据元素 4 B、每个游标 4 B（一个节点共 8 B）
- 起始地址为：*addr*
- 则：$e_1$ 的存放地址为：`addr+8 * index`

# 如何定义一个静态链表

```c
#define MaxSize 10;
// 链表节点
struct Node{
	ElemType data;
	int next;
};
void testSLinkList()
{
	struct Node a[MaxSize]; // 数组a为静态链表
}
```

- 另一种写法：
	- 区别仅仅是为了便于阅读
	- 上边的写法第一眼看上去是一个节点的数组
	- 下边的写法第一眼看上去可以知道这是一个静态链表
	- *本质上是一样的*

```c
#define MaxSize 10;
// 链表节点
typedef struct{
	ElemType data;
	int next;
}SLinkList[MaxSize];

void testSLinkList()
{
	SLinkList a; // 这里的a是一个含有10个node的linklist
}
```

# 基本操作的实现

- 初始化：头节点 `a[0]->next = -1`
- 查找：
	- 从头节点出发遍历查找某个*位序*的节点 O (n)
- 插入位序为 i 的节点
	- *在静态链表所在的内存空间中找到一块空闲区域*，即空节点，存入数据元素
		- 这些空节点的判断方式：
			- 可以在初始化的时候都初始化为某一个值
			- 例如-2，从而可以查看每个位置的 data 是否为-2，来确定该位置是否为空
	- 从头节点出发找到位序为 i-1 的节点，修改其 next 为新插入的节点的存放位置
	- 同样记得修改新节点的 next 
- 删除：
	- 同样记得删除游标next，以及修改 data 为自己设置的默认的空节点数据，例如上边的-2

# 特点

- 优点：增、删操作不需要移动大量元素
- 缺点：不能随机存取，只能从头节点开始依次往后查找，*容量固定不可变*

- 适用场景
	- 不支持指针的低级语言
	- 数据元素数量固定不变的场景（如操作系统的文件分配表FAT）



