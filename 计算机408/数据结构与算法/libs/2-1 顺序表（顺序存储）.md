#computer 

---
# 什么是顺序表

**顺序表**：以*顺序存储*（物理结构）方式实现的*线性表*（逻辑结构）
- 本质：用顺序存储的这种*物理结构*实现线性表这种*逻辑结构*

![](img/Pasted%20image%2020231208104529.png)

# 定义：代码实现

## 静态分配

长度在定义时就确定，无法改变

![](img/Pasted%20image%2020231208104841.png)

```c
#define MaxSize 10;
typedef struct
{
	ElemType data[MaxSize]; // 静态数组存放
	int length; // 存放当前长度
}Sqlist;

// 初始化
void InitList(SqList &L)
{
	for (int i=0;i<MaxSize; i++)
	{
		L.data[i]=0; // 初始化为默认值
	}
	L.length = 0;
}
```

## 动态分配

- C：malloc、free 函数，stdlib. h 头文件
	- malloc 函数会分配一片连续的存储空间
	- malloc 函数返回一个指针，需要强制转型为定义的数据元素类型指针
	- `(int *)malloc(Size*sizeof(int));`
- C++：new、delete 关键字

```c
#include <stdlib.h> // malloc和free的头文件
#define InitSize 10; // 设置初始长度
typedef struct
{
	ElemType *data; // 动态分配数组的指针
	int MaxSize; // 顺序表最大容量
	int length; // 顺序表当前长度
} SeqList;

// 初始化动态分配的顺序表
void InitList(SeqList &L)
{
	L.data = (ElemType *)malloc(sizeof(ElemType)*InitSize);
	L.length = 0;
	L.MaxSize = InitSize;
}

// 增加顺序表的长度
void IncreaseSize(SeqList &L, int len)
{
	ElemType *p = L.data; // 临时存放原顺序表的指针
	// 申请新的内存空间
	L.data = (ElemType *)malloc((L.MaxSize+len)*sizeof(ElemType));
	for (int i=0; i<L.length; i++)
	{
		L.data[i] = p[i]; // 将旧数据复制到新申请到的内存位置
	}
	L.MaxSize = L.MaxSize + len; // 更新当前顺序表的最大容量
	free(p); // 释放掉临时指针指向的旧数据区域
}
```

- 最终图中的 p 指针指向的旧数据区域会被释放掉![](img/Pasted%20image%2020231208105630.png)

## 顺序表特点

- *随机访问*：可以在 O (1)时间内找到第 i 个元素，直接通过 `[i]` 下标运算符获取对应位置元素
- 存储密度高，每个节点只存储数据元素
- 要求大片连续存储空间，扩展容量不方便（动态分配的时间复杂度也比较高）
- 插入、删除操作不方便，需要移动大量元素

---

# 基本操作的实现

## 静态实现

### 插入元素

`ListInsert(&L, i, e)` 插入操作，在表 L 中的第 i 个位置上插入指定元素 e

```c
#define MaxSize 10;
typedef struct{
	ElemType *data[MaxSize]; // 静态表实现
	int length; // 记录当前长度
} SqList;
```

- *插入位置元素及之后的元素都要后移*，length+1

```c
bool ListInsert(SqList &L, int i, ElemType e)
{
	if(i<1||i>L.lengt+1) // 当前插入位置不合法
		return false;
	if(L.length >= MaxSize) // 当前存储空间已满
		return false;
	
	for (int j=L.length;j>=i;j--)
	{
		L.data[j] = L.data[j-1]; // 将指定位置之后的元素都向后移动
	}
	L.data[i-1]=e;
	L.length++;
	return true;
}
```

- 注意：
	- 代码的健壮性（插入位置是否合法，顺序表是否已经填满）
	- 可读性：返回操作是否成功
- 时间复杂度：
	- 最好：插入顺序表最后一个位置，O(1)
	- 最坏：插入表头位置，移动 n 个元素，O(n)
	- 平均：O(n)

### 删除元素

删除顺序表 L 中的第 i 个元素（第 i 个元素 = 下标为 i-1）

- *删除位置之后的元素都要前移*，length-1

```c
bool ListDelete(SqList &L, int i, int &e)
{
	if(i<1||i>L.length) // i不合法
		return false;
	e=L.data[i-1];
	for (int j=i;j<L.length;j++)// 将第i个位置之后的元素前移
		L.data[j-1] = L.data[j];
	
	L.length--; // 更新长度
	return true;
}
```

- 注意：
	- 代码的健壮性（删除位置是否合法，顺序表是否已经为空）
	- 可读性：返回操作是否成功
- 时间复杂度：
	- 最好：删除表尾，不需要移动其他元素，O(1)
	- 最坏：删除第一个元素，需要移动剩下全部的元素，O(n)
	- 平均：计算插入不同位置的复杂度期望， O (n)

- *注意修改顺序表的长度 length*
- 注意删除或插入的位置是*第 i 个元素*，还是*下标为 i* 
### 查找元素

#### 按位查找

- `GetElem(L, i)` 获取表 L 中第 i 个位置的元素的值

```c
ElemType GetElem(SqList L, int i)
{
	if (i>1 && i<L.length())
		return L.data[i-1];
	else
		return NULL;
}
```

- 复杂度分析
	- 顺序表的各个元素在内存中连续存放，所以可以根据起始地址和数据元素的类型大小快速定位到第 i 个元素位置，即*随机存储*的特性 (利用下标运算符)
	- O (1)

#### 按值查找

`LocateElem(L, e)` 在表 L 中查找具有给定关键字值的元素，并返回位序

```c
int LocateElem(SeqList L, ElemType e)
{
	for (int i=0;i<L.length;i++)
		if(L.data[i]==e)
			return i+1; // 下标为i，表示位序为i+1
	return 0;
}
```

- 时间复杂度
	- 最好：目标元素在表头，O(1)
	- 最坏：目标元素在表尾，O(n)
	- 平均：O(n)

## 动态实现

![](img/Pasted%20image%2020231210175239.png)

```c
#include <stdlib.h>
#define InitSize 10
typedef struct{
	int *data; // 动态分配数组的指针
	int MaxSize; // 最大容量
	int length; // 当前长度
}SeqList;

// 初始化
void initList(SeqList &L)
{
	L.data = (int *)malloc(InitSize * sizeof(int));
	L.length = 0;
	L.MaxSize = InitSize;
}

// 增加动态数组的长度
void IncreaseSize(SeqList &L, int len)
{
	int *p = L.data;
	L.data = (int *)malloc((L.MaxSize+len)*sizeof(int));
	for(int i=0;i<L.length;i++){
		L.data[i] = p[i];
	}
	L.MaxSize += len;
	free(p);
}
```

```c
bool deleteMin(SeqList &L, int &x)
{
	if (L.length == 0)
	{
		std::couot << "List is empty!" << std::endl;
		return false;
	}
		
	int min=L[0], index=0;
	for(int i=0;i<L.length;++i)
	{
		if(min>L[i])
			min = L[i];
			index = i;
	}
	L[index] = L[L.length-1];
	--L.length;
	return true;
}
```


