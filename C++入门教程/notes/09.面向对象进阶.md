#编程基础 #cpp 

C++面向对象的进阶内容，主要涉及**对象的拷贝**和**类型转换**
- *对象拷贝*
	- 用一个已经存在的对象去创建一个新的对象
- *类型转换*
	- 类也是一种数据类型，和其他数据类型之间也可以进行数据转换

# 9.1 C++拷贝构造函数（复制构造函数）

## 拷贝构造函数

拷贝：对计算机来说，是将一份*原有的、已经存在的数据*创建出一份*新的数据*，最终结果是*多了一份相同的数据*

在C++中，拷贝，指用已经存在的对象创建出一个新的对象。那么要理解拷贝，就需要回顾以下对象的创建过程。

**对象的创建包括两个阶段**
- **分配内存空间**：
	- 在堆区、栈区或全局数据区留出足够多的字节
	- 此时内存是指被划分给了对象，其中包含的数值是“无意义”的
- **初始化**：
	- 初始化就是对分配好的内存空间进行*首次*赋值，使其具有“意义”
	- 初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或提前进行一些计算等
	- **本质上其实是调用构造函数**

据此，可以判断出，*拷贝的过程发生在初始化的阶段*，即*使用其他对象的内存中的数据来初始化新对象的内存中的数据*

- 这里用一个字符串的拷贝来进行举例

```cpp
#include <iostream>
#include <string>
using namespace std;

void func(string str){
    cout<<str<<endl;
}

int main(){
    string s1 = "http://c.biancheng.net";
    string s2(s1);
    string s3 = s1;
    string s4 = s1 + " " + s2;
    func(s1);
    cout<<s1<<endl<<s2<<endl<<s3<<endl<<s4<<endl;
   
    return 0;
}
```

> 注意代码第11行，`string s2(s1);`
> 我自己根据这里的格式在vscode中试验了以下，聚合类型没有测试，目前可以推测基本的数据类型都内置了这样的语法格式的，即都有对应的拷贝构造函数
> 例如：`int i=5; double a(i);` 就可以给 a 拷贝一份 i 的数据过去，当然这其中还涉及到了隐式转换。

- 这里以上述代码中的 func() 函数为例，
	- *函数的形参 str，在定义函数的时候并没有被创建*
	- 一直*等到调用函数 func() 时*，才会创建函数的形参，此时形参具有了内存
	- 之后再将传入的实参对象的数据拷贝给 str 来*完成初始化*

这里给出另一个使用到拷贝构造函数的例子：

```cpp
#include <iostream>
#include <string>
using namespace std;

class Student{
public:
    Student(string name = "", int age = 0, float score = 0.0f);  //普通构造函数
    Student(const Student &stu);  //拷贝构造函数（声明）
public:
    void display();
private:
    string m_name;
    int m_age;
    float m_score;
};

Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score){ }

//拷贝构造函数（定义）
Student::Student(const Student &stu){
    this->m_name = stu.m_name;
    this->m_age = stu.m_age;
    this->m_score = stu.m_score;
   
    cout<<"Copy constructor was called."<<endl;
}

void Student::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    Student stu1("小明", 16, 90.5);
    Student stu2 = stu1;  //调用拷贝构造函数
    Student stu3(stu1);  //调用拷贝构造函数
    stu1.display();
    stu2.display();
    stu3.display();
   
    return 0;
}
```

- 注意代码第8行，声明的拷贝构造函数
	- 这里传入的参数是*const类型的对象的引用*
- **为什么必须是当前类的引用？**
	- 如果不是类的引用，而是类的对象，那么在调用拷贝构造函数时，是相当于将一个对象直接拷贝给了函数的形参（*参照上边对func()函数的分析，在调用函数的时候将传入的实参拷贝给形参*）
	- 从而触发了另一次拷贝，于是又会触发对应类的拷贝函数，从而导致陷入死循环
	- **只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数**
- **为什么是const引用？**
	- 第一个原因
		- 因为拷贝构造函数目的是用其他对象的数据来初始化新的对象，没有更改数据的打算，添加const使得含义更加明确
	- 第二个原因
		- 添加const限制，使得形参可以接收*const对象和非const对象*
		- 如果没有const限制，则无法接收const对象

## 默认拷贝构造函数

- 如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。
	- 使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值

*对于简单的类，默认拷贝函数一般是够用的*

**当类持有其它资源时**，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们**必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据**。

# 9.2 什么时候调用拷贝函数

当 *以拷贝的方式* *初始化对象*时会调用拷贝函数

两个关键点：
- **以拷贝的方式**
- **初始化对象**

## 初始化对象

这里需要明确，初始化和赋值之间的区别

**初始化对象**：为对象分配内存后*第一次*向内存中填充数据

给出初始化和赋值之间的区别：
- **初始化**：initialization
	- *在定义的同时*进行赋值
		- 只能有一次
- **赋值** assignment
	- *定义完成以后*再赋值（不管定义的时候有没有赋值）
	- 可以有多次

基本数据类型的数据对于初始化和赋值并没有那么敏感，但是*对于类，区分这两者就非常重要了*

**对于类：**
- 初始化时调用构造函数
- 以拷贝的方式初始化会调用拷贝构造函数
- 赋值时会调用重载过的赋值运算符

## 以拷贝的方式初始化对象

初始化对象时会调用构造函数，**不同的初始化方式**会调用不同的构造函数：

- 如果**用传递进来的实参**初始化对象，那么会调用普通的构造函数，我们不妨将此称为普通初始化；
- 如果**用其它对象（现有对象）的数据**来初始化对象，那么会调用拷贝构造函数，这就是以拷贝的方式初始化。

## 拷贝的方式初始化对象的案例

### **将其他对象作为实参**

```cpp
Student stu1("小明", 16, 90.5);  //普通初始化
Student stu2(stu1);  //以拷贝的方式初始化
```

### **在创建对象的同时赋值**

```cpp
Student stu1("小明", 16, 90.5);  //普通初始化
Student stu2 = stu1;  //以拷贝的方式初始化
```

### **函数的形参作为类类型**

```cpp
void func(Student s){
    //TODO:
}

Student stu("小明", 16, 90.5);  //普通初始化
func(stu);  //以拷贝的方式初始化
```

函数是一段可以重复使用的代码，只有等到**真正调用函数时才会为局部数据（形参和局部变量）在栈上分配内存**。对于上面的 func()，虽然它的形参 s 是一个对象，但在定义函数时 s 对象并没有被创建，只有等到调用函数时才会真正地创建 s 对象，并在栈上为它分配内存。

而**创建 s 对象，就是以拷贝的方式进行的**，它等价于下面的代码：

```cpp
Student s = stu;
```

### **函数返回值为类类型**

- 当函数的返回值为类类型时，return 语句会返回一个对象
	- 不过为了防止局部对象被销毁
	- 也为了防止通过返回值修改原来的局部对象
- 编译器并不会直接返回这个对象，而是
	- *根据这个对象先创建出一个临时对象（匿名对象），再将这个临时对象返回*

**创建临时对象的过程，就是以拷贝的方式进行的**，会调用拷贝构造函数

```cpp
Student func(){
    Student s("小明", 16, 90.5);
    return s;
}

Student stu = func();
```

> 现代编译器都支持返回值优化技术，会尽量避免拷贝对象，以提高程序运行效率

# 9.3 C++深拷贝和浅拷贝（深复制和浅复制）

## 浅拷贝

对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存，实例代码如下：

```cpp
class Base{
public:
    Base(): m_a(0), m_b(0){ }
    Base(int a, int b): m_a(a), m_b(b){ }
private:
    int m_a;
    int m_b;
};

int main(){
    int a = 10;
    int b = a;  //拷贝

    Base obj1(10, 20);
    Base obj2 = obj1;  //拷贝

    return 0;
}
```

**这种默认的拷贝行为就是浅拷贝，和调用 `memcpy()` 函数的效果非常类似**

## 深拷贝

当类持有其他资源，如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就无法进行这些资源的拷贝了，必须要**显式定义**拷贝构造函数，以完整拷贝对象所有的数据

这里以一个变长数据为例

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

//变长数组类
class Array{
public:
    Array(int len);
    Array(const Array &arr);  //拷贝构造函数
    ~Array();
public:
    int operator[](int i) const { return m_p[i]; }  //获取元素（读取）
    int &operator[](int i){ return m_p[i]; }  //获取元素（写入）
    int length() const { return m_len; }
private:
    int m_len;
    int *m_p;
};

Array::Array(int len): m_len(len){
    m_p = (int*)calloc( len, sizeof(int) );
}

Array::Array(const Array &arr){  //拷贝构造函数
    this->m_len = arr.m_len;
    this->m_p = (int*)calloc( this->m_len, sizeof(int) );
    memcpy( this->m_p, arr.m_p, m_len * sizeof(int) );
}

Array::~Array(){ free(m_p); }

//打印数组元素
void printArray(const Array &arr){
    int len = arr.length();
    for(int i=0; i<len; i++){
        if(i == len-1){
            cout<<arr[i]<<endl;
        }else{
            cout<<arr[i]<<", ";
        }
    }
}

int main(){
    Array arr1(10);
    for(int i=0; i<10; i++){
        arr1[i] = i;
    }

	// 显式定义拷贝函数的目的就是为了这里
    Array arr2 = arr1; 
    // 如果没有拷贝函数
    // 那么复杂类中涉及到指针的部分就会使得二者共同指向同一片内存区域

    arr2[5] = 100;
    arr2[3] = 29;
   
    printArray(arr1);
    printArray(arr2);
   
    return 0;
}
```

**这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的**

## 到底是浅拷贝还是深拷贝

- 如果一个类*拥有指针类型的成员变量*，那么绝大部分情况下就需要深拷贝
	- 只有这样才能将指针指向的内容复制一份，让原有对象与新对象相互独立
- 如果*类的成员变量没有指针*，一般浅拷贝就可以

**另一个需要深拷贝的情况是在创建对象时进行一些预处理工作**

有如下例子：

```cpp
#include <iostream>
#include <ctime>
#include <windows.h>  //在Linux和Mac下要换成 unistd.h 头文件
using namespace std;

class Base{
public:
    Base(int a = 0, int b = 0);
    Base(const Base &obj);  //拷贝构造函数
public:
    int getCount() const { return m_count; }
    time_t getTime() const { return m_time; }
private:
    int m_a;
    int m_b;
    time_t m_time;  //对象创建时间
    static int m_count;  //创建过的对象的数目
};

int Base::m_count = 0;

Base::Base(int a, int b): m_a(a), m_b(b){
    m_count++;
    m_time = time((time_t*)NULL);
}

Base::Base(const Base &obj){  //拷贝构造函数
    this->m_a = obj.m_a;
    this->m_b = obj.m_b;
    this->m_count++;
    this->m_time = time((time_t*)NULL);
}

int main(){
    Base obj1(10, 20);
    cout<<"obj1: count = "<<obj1.getCount()<<", time = "<<obj1.getTime()<<endl;
   
    Sleep(3000);  //在Linux和Mac下要写作 sleep(3);
   
    Base obj2 = obj1;
    cout<<"obj2: count = "<<obj2.getCount()<<", time = "<<obj2.getTime()<<endl;

    return 0;
}
```

这里建立了一个 Base 类，用该类创建的对象中 m_time 和 m_cout 分别代表对象的创建时间和创建数目，它们在不同对象中具有不同的值，所以需要*在初始化对象的时候提前处理一下*

- 所以必须要*显式定义拷贝构造函数*

# 9.4 C++重载=（赋值运算符）

- 当以拷贝的方式初始化一个对象时，会调用拷贝构造函数
- **当给一个对象赋值时，会调用重载过的赋值运算符**

> 即使没有显式重载赋值运算符，编译器也会以默认的方式重载。
> 默认重载的赋值运算符功能：*将原有对象的所有成员变量一一赋值给新对象*

但是同样对于复杂的类，例如含有*动态分配的内存、打开的文件、指向其他数据的指针、网络连接*等，默认的赋值运算符就不能处理了，**必须显式重载**

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

//变长数组类
class Array{
public:
    Array(int len);
    Array(const Array &arr);  //拷贝构造函数
    ~Array();
public:
    int operator[](int i) const { return m_p[i]; }  //获取元素（读取）
    int &operator[](int i){ return m_p[i]; }  //获取元素（写入）
    Array & operator=(const Array &arr);  //重载赋值运算符
    int length() const { return m_len; }
private:
    int m_len;
    int *m_p;
};

Array::Array(int len): m_len(len){
    m_p = (int*)calloc( len, sizeof(int) );
}

Array::Array(const Array &arr){  //拷贝构造函数
    this->m_len = arr.m_len;
    this->m_p = (int*)calloc( this->m_len, sizeof(int) );
    memcpy( this->m_p, arr.m_p, m_len * sizeof(int) );
}

Array::~Array(){ free(m_p); }

Array &Array::operator=(const Array &arr){  //重载赋值运算符
    if( this != &arr){  //判断是否是给自己赋值
        this->m_len = arr.m_len;
        free(this->m_p);  //释放原来的内存
        this->m_p = (int*)calloc( this->m_len, sizeof(int) );
        memcpy( this->m_p, arr.m_p, m_len * sizeof(int) );
    }
    return *this;
}

//打印数组元素
void printArray(const Array &arr){
    int len = arr.length();
    for(int i=0; i<len; i++){
        if(i == len-1){
            cout<<arr[i]<<endl;
        }else{
            cout<<arr[i]<<", ";
        }
    }
}

int main(){
    Array arr1(10);
    for(int i=0; i<10; i++){
        arr1[i] = i;
    }
    printArray(arr1);
   
    Array arr2(5);
    for(int i=0; i<5; i++){
        arr2[i] = i;
    }
    printArray(arr2);
    arr2 = arr1;  //调用operator=()
    printArray(arr2);
    arr2[3] = 234;  //修改arr1的数据不会影响arr2
    arr2[7] = 920;
    printArray(arr1);
   
    return 0;
}
```

对重载的赋值运算符的分析：

1) operator=() 的返回值类型为`Array &`，这样不但能够*避免在返回数据时调用拷贝构造函数*，还能够达到*连续赋值*的目的。下面的语句就是连续赋值：

```cpp
arr4 = arr3 = arr2 = arr1;
```
  
2) `if( this != &arr)`语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值：

```cpp
arr1 = arr1;  
arr2 = arr2;
```
 
3) `return *this`表示返回当前对象（新对象）。    

4) operator=() 的形参类型为`const Array &`，这样不但能够*避免在传参时调用拷贝构造函数*，还*能够同时接收 const 类型和非 const 类型的实参*，这一点已经在《[C++拷贝构造函数](https://c.biancheng.net/view/2334.html)》中进行了详细讲解。  
  
5) 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是*其它参数必须给出默认值*，例如：

```cpp
Array & operator=(const Array &arr, int a = 100);
```

# 9.5 C++拷贝控制操作（三/五法则）

**拷贝控制操作**
- 拷贝构造函数
	- 用同类型的另一个对象初始化新对象
- 赋值运算符
	- 将一个对象赋予同类型的另一个对象
- 析构函数
	- 此类型对象的销毁

> 由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。
> 在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”。
> 也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的。
> 为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。

## 需要析构函数的类也需要拷贝和赋值操作

## 需要拷贝操作的类也需要赋值操作，反之亦然

# 9.6 C++转换构造函数：将其它类型转换为当前类的类型

1) 默认构造函数。就是编译器自动生成的构造函数。以 Complex 类为例，它的原型为：

```cpp
Complex();  //没有参数
```

  
2) 普通构造函数。就是用户自定义的构造函数。以 Complex 类为例，它的原型为：

```cpp
Complex(double real, double imag);  //两个参数
```

  
3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以 Complex 类为例，它的原型为：

```cpp
Complex(const Complex &c);
```

  
4) 转换构造函数。将其它类型转换为当前类类型时调用。以 Complex 为例，它的原型为：

```cpp
Complex(double real);
```

**构造函数的本意——在创建对象时初始化对象**

- 在构造函数中增加默认参数，从而将两个普通的构造函数和一个转换构造函数合并为一个

```cpp
#include <iostream>
using namespace std;

//复数类
class Complex{
public:
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:
    friend ostream & operator<<(ostream &out, Complex &c);  //友元函数
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

//重载>>运算符
ostream & operator<<(ostream &out, Complex &c){
    out << c.m_real <<" + "<< c.m_imag <<"i";;
    return out;
}

int main(){
    Complex a(10.0, 20.0);  //向构造函数传递 2 个实参，不使用默认参数
    Complex b(89.5);  //向构造函数传递 1 个实参，使用 1 个默认参数
    Complex c;  //不向构造函数传递实参，使用全部默认参数
    a = 25.5;  //调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）

    return 0;
}
```

# 9.7 C++类型转换函数：将当前类的类型转换为其它类型

和转换构造函数作用相反，*类型转换函数 Type conversion function 目的是将当前类型转换为其他类型*

**只能以成员函数的形式出现**

语法格式如下：

```cpp
operator type(){
	// TODO;
	return data;
}
```

例如上一节中，将complex类转换为double类型

```cpp
class Comples{
public:
	Complex(): m_real(0.0), m_imag(0.0){}
	Complex(double real, double imag):m_real(real),m_imag(imag){}
public:
	...
	operator double() cosnt {return m_real;} // 类型转换函数
...
private:
	double m_real;
	double m_imag;
};
```

类型转换函数和运算符的重载非常相似，都使用 operator 关键字，因此也把类型转换函数称为类型转换运算符。

1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。  
  
2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。  
  
3) 类型转换函数可以被继承，可以是虚函数。  
  
4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。


# 9.9 C/C++类型转换的本质

> `type *`是一个具体类型的指针，例如`int *`、`double *`、`Student *`等，它们都可以直接赋值给`void *`指针。而反过来是不行的，必须使用强制类型转换才能将`void *`转换为`type *`，例如，==malloc() 分配内存后返回的就是一个`void *`指针，我们必须进行强制类型转换后才能赋值给指针变量==。

## 类型转换的本质

诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。也就是说，内存中的数据有多种解释方式，使用之前必须要确定

**这种「确定数据的解释方式」的工作就是由数据类型（Data Type）来完成的**

所谓数据类型转换，就是对数据所占用的二进制位做出重新解释。如果有必要，在重新解释的同时还会修改数据，改变它的二进制位。对于隐式类型转换，编译器可以根据已知的转换规则来决定是否需要修改数据的二进制位；而==对于强制类型转换，由于没有对应的转换规则，所以能做的事情仅仅是重新解释数据的二进制位，但无法对数据的二进制位做出修正==。这就是隐式类型转换和强制类型转换最根本的区别

## 为什么会有隐式类型转换和强制类型转换之分？

隐式类型转换和显式类型转换最根本的区别是：
- 隐式类型转换除了会**重新解释数据的二进制位**，还会**利用已知的转换规则对数据进行恰当地调整**；
- 而显式类型转换只能**简单粗暴地重新解释二进制位**，**不能对数据进行任何调整**。

## 强制类型转换也不是万能的

类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行

# 9.10 C++ static_cast、dynamic_cast、const_cast和reinterpret_cast（四种类型转换运算符）

|关键字|说明|
|---|---|
|static_cast|用于良性转换，一般不会导致意外发生，风险很低。|
|const_cast|用于 const 与非 const、volatile 与非 volatile 之间的转换。|
|reinterpret_cast|高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。|
|dynamic_cast|借助 RTTI，用于类型安全的向下转型（Downcasting）。|

这四个关键字的语法格式都是一样的，具体为：

```cpp
xxx_cast<newType>(data)
```




