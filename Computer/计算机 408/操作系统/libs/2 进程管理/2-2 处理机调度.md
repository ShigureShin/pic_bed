#computer 

---
# 2.2.1 调度的概念、层次

## 基本概念

资源有限、但需要处理的任务很多，因此需要根据*某种规则*来决定这些任务的处理顺序

## 三个层次

- 高级调度（**作业调度**）：按照一定规则，*从外存的作业后备队列*中选取一个作业调入内存，并创建进程
![](../../img/Pasted%20image%2020231228090938.png)

- 低级调度（**进程调度，处理机调度**）：按照某种策略，从*就绪队列*中选取一个进程，分配处理机
![](../../img/Pasted%20image%2020231228091004.png)
  
- 中级调度（**内存调度**）：按照某种策略，将*挂起状态的某个进程*重新调入内存
![](../../img/Pasted%20image%2020231228091014.png)

## 挂起状态/七状态模型

 ![](../../img/Pasted%20image%2020231228091046.png)

**注意**：
挂起态和阻塞态的进程位置，挂起在外存，阻塞仍在内存 

## 三种调度的对比

 ![](../../img/Pasted%20image%2020231228091127.png)

---
# 2.2.2 进程调度的时机、切换与过程、方式

![](../../img/Pasted%20image%2020231228091240.png)

## 进程调度的时机

根据**进程调度（低级调度）**，就是按照某种算法从就绪队列中选择一个进程为其分配处理机

**那么何时需要进程调度与切换？**

- 当前运行进程*主动放弃*处理机，具体有：
	- 进程正常终止
	- 运行过程中发生异常而终止
	- 进程请求阻塞（如等待IO）
- 当前运行进程*被动放弃*处理机，具体有：
	- 分配给进程的时间片用完
	- 需要处理更紧急的事情（如 IO 中断）
	- 更高优先级的进程进入就绪队列

进程主动还是被动，也需要考虑到不同系统各自的要求

**何时不能进程调度与切换？**

- *处理中断的过程中*：中断处理复杂，与硬件相关，很难做到中断处理中进程切换
- 进程在*操作系统内核程序临界区*中
	- 另一种说法：进程处于*临界区*时不能进行处理机调度（**错误**）
	- **临界资源**：一个时间段只允许一个进程使用的资源。各进程需要*互斥访问*
	- **临界区**：访问临界资源的那段代码
	- 故非内核程序临界区的资源，不会影响操作系统内核的管理工作，此时可以进行
	- 而在内核程序临界区的资源，因为涉及可能影响到内核中其他管理工作，所以此时不能进行进程调度与切换
- 在*原子操作过程中*（原语）：原子操作不可中断

根据不同系统对于进程主动还是被动调度可以分为两种方式

## 进程调度的方式

- **非剥夺式调度/非抢占方式**：只允许进程主动放弃处理机
	- 实现简单
	- 系统开销小
	- 无法及时处理紧急任务
	- 适合早期批处理系统
- **剥夺调度方式/抢占方式**：如果有更重要的进程需要处理机，则会暂停当前的进程并分配给更重要的进程
	- 可以优先处理紧急任务
	- 可以实现各进程按照时间片轮流执行功能（时钟中断）
	- 适合分时操作系统、实时操作系统

## 进程的切换与过程

**狭义的进程调度**：从就绪队列中*选中一个要运行的进程*
- 刚刚被暂停的进程
- 另一个进程：*此时会发生进程切换*
**进程切换**：一个进程让出处理机，由另一个进程占用处理机的过程

**广义的进程调度**：*选择一个进程*和*进程切换*两个步骤
- 对原来运行进程各种数据的保存
- 对新的进程各种数据的恢复
	- 程序计数器、程序状态字、各种数据寄存器等处理机现场信息
	- 一般都在程序控制块 PCB 中

**注意**：
- *进程切换有代价*
- 过于频繁的进程调度与切换，会降低系统的效率

---
# 2.2.3 调度器和闲逛进程

![](../../img/Pasted%20image%2020231228094034.png)

## 调度器/调度程序

调度器/程序（scheduler）即引发上图步骤 2 和 3 的程序，它决定两个事情
- 让谁运行？*根据调度算法*
- 运行多长时间？*根据时间片大小*

上一节中的*调度时机*，可以理解为*触发调度程序的事件*：
- *创建新进程*
- *进程退出*
- 运行*进程阻塞*
- *IO 中断*发生（可能唤醒某些阻塞进程）

同时还要结合采用的调度算法，
- 非抢占式调度策略：*运行进程阻塞或退出* -> 触发调度程序
- 抢占式调度策略：*每个时钟中断*或 k 个时钟中断 -> 触发调度程序

**上边考虑的调度对象为进程，如果调度对象为线程呢？**

例如，在不支持内核级线程的操作系统中，调度程序的处理对象是进程；而支持内核级线程的操作系统，调度程序的处理对象是*内核线程*

![](../../img/Pasted%20image%2020231228094624.png)

## 闲逛进程（idle）

没有其他就绪进程时，运行闲逛进程

特性：
- 优先级最低
- 可以是 0 地址指令（这种指令不需要访存，从而降低能耗），占用一个完整的指令周期（周期末尾同样会*例行检查中断*）
- 能耗低

---
# 2.2.4 调度算法的评价标准

![](../../img/Pasted%20image%2020231228094815.png)

![](../../img/Pasted%20image%2020231228101023.png)

## CPU 利用率

目的：让 CPU 尽可能多的工作

因此，需要一种评价标准

故，**CPU 利用率**：指 CPU 有效工作的时间占总运行时间的比例

![](../../img/Pasted%20image%2020231228095002.png)

## 系统吞吐量

让 CPU 尽可能多的工作还不足以满足要求，毕竟没有规定一件工作的时间开销

故，我们希望让 CPU 能够尽可能少的时间内处理完尽可能多的作业

从而有，**系统吞吐量**：单位时间内完成作业的数量

![](../../img/Pasted%20image%2020231228095124.png)

## 周转时间

实际情况中，一个作业在被 CPU 真正开始执行之前，还需要经过用户的提交过程

所以对于用户，从提交某个作业到作业真正完成这段时间，才是最值得关心的

故，这里另定义一个概念，**周转时间**：从作业被提交给系统开始，到作业完成的这段时间

四个部分：
- 作业在外存*等待作业调度（高级调度）* 的时间
- 进程*在就绪队列上等待进程调度（低级调度）* 的时间
- 进程在 CPU 上执行时间
- 进程等待 IO 操作完成的时间
其中，后三项可能在一个作业的处理过程中发生多次

对于用户，更关系单个作业
- （作业）**周转时间** = 作业完成时间-作业提交时间
对于操作系统，更关心系统的整体表现
- **平均周转时间** = 各作业周转时间之和/作业数

## 带权周转时间

这一概念具体描述的是，作业本身的执行时间和实际等待的时间

![](../../img/Pasted%20image%2020231228095736.png)

思考两个情况：
- 一个作业本身耗时不多如 1min，但却需要等待很久如 2h 才可以被处理
- 一个作业本身耗时很久如 2 h，而等待时间却很短如 1 min 就被处理
这两种情况给用户的感觉自然是不同的，**带权周转时间**就是为了描述这一“用户满意度”的概念

用户满意度高：
- 周转时间相同，实际运行时间长的作业（相同时间内被服务的时间更多），带权周转时间更小
- 实际运行时间相同，周转时间短的带权周转时间更小

可以发现：
- *带权周转时间必然 >=1*
- 带权周转时间和周转时间都是越小越好

同样，对于用户和系统各自关心的指标，前者是单个作业，后者则是平均水平：
![](../../img/Pasted%20image%2020231228100358.png)

## 等待时间

就像上一部分里提到的，作业的周转时间很短，如果等待很长时间自然会影响到用户的心情

故，**等待时间**：进程/作业处于等待处理机状态时间之和，也可以描述用户满意度

- 作业在后备队列*等待被服务/调度*（外存中）
- 作业调入内存，*建立对应进程*，此时同样可能需要经历*等待被服务*

对于进程，
- **等待时间** = *进程建立后*等待被服务的时间之和（等待 IO 完成期间进程是处于被服务状态，故不计入等待时间）
对于作业，
- **等待时间** = 建立进程后的等待时间 + *在外存后备队列中等待的时间*
**要注意**：区分计算进程和作业的等待时间，二者是不同的

![](../../img/Pasted%20image%2020231228100855.png)

## 响应时间

**响应时间**：从用户*提交请求*到*首次产生回应*的时间

例如，用户键盘输入指令，到系统接收到指令并首次回复的时间间隔

---
# 2.2.5 调度算法

## 早期批处理系统中的调度算法

![](../../img/Pasted%20image%2020231228101036.png)

需要了解：
1. 算法思想
2. 算法规则
3. 用于*作业调度*还是*进程调度*
4. 抢占式？非抢占式？
5. 优点和缺点
6. 是否*饥饿*？：某进程/作业长期得不到服务

### 先来先服务（FCFS）

算法规则：
- 按照作业/进程到达的先后顺服进行服务

用于作业/进程调度：
- 对于作业，考虑*作业到达后备队列*的先后顺序
- 对于进程，考虑*进程到达就绪队列*的先后顺序

是**非抢占式算法**，进程主动放弃处理机时才会选择下一个进程

例题：![](../../img/Pasted%20image%2020231228101702.png)

按照先来先服务思想，很容易得到调度顺序与进程的

![](../../img/Pasted%20image%2020231228101833.png)

从而可以很方便计算：
- 周转时间 = 完成时间-到达时间
	- ![](../../img/Pasted%20image%2020231228101907.png)
- 带权周转时间 = 周转时间 / 运行时间
	- ![](../../img/Pasted%20image%2020231228101921.png)
- 等待时间 = 周转时间 - 运行时间
	- ![](../../img/Pasted%20image%2020231228101938.png)

上述例题为纯计算问题，没有 IO 操作，如果有 IO 操作，则等待时间还需要再减去 IO 操作的时间：![](../../img/Pasted%20image%2020231228102023.png)

对于平均时间的计算：求和除以进程个数即可
![](../../img/Pasted%20image%2020231228102100.png)

优缺点：
- 优点：公平、算法实现简单
- 缺点：排在长作业/进程后的短作业/进程需要等待很长时间，带权周转周期大，即
	- **长作业有利**
	- **短作业不利**

**饥饿问题**：因为是按照顺序进行，所以不会导致

### 短作业优先（SJF，Shortest Job First）

![](../../img/Pasted%20image%2020231228103545.png)

例题：**非抢占式**![](../../img/Pasted%20image%2020231228102604.png)

调度顺序：![](../../img/Pasted%20image%2020231228102617.png)

![](../../img/Pasted%20image%2020231228102631.png)

![](../../img/Pasted%20image%2020231228102644.png)

例题：**抢占式**![](../../img/Pasted%20image%2020231228102730.png)

需要注意，此时排序原则为比较*新到达进程的剩余时间*和*当前运行进程剩余时间*，可以按照下图所示方式进行梳理：![](../../img/Pasted%20image%2020231228102948.png)

故最后的时间序列为：![](../../img/Pasted%20image%2020231228102956.png)

![](../../img/Pasted%20image%2020231228103025.png)

**几个需要注意的小细节**
- 短作业优先（SJF、Shortest Job First）：默认为非抢占式
- 这种说法：“SJF 调度算法的平均等待时间、平均周转时间最少”（不严谨，应该为最短剩余时间优先算法）
	- “*在所有进程同时可运行时*，采用 SJF 调度算法的平均等待时间、平均周转时间最少”
	- “在*所有进程都几乎同时到达*时，采用 SJF 调度算法的平均等待时间、平均周转时间最少”
	- 无上述前提条件，则为“*抢占式*的短作业/短进程优先调度算法（最短剩余时间优先，SRNT 算法）的平均等待时间、平均周转时间最少”
- SJF 算法相比于 FCFS 仍然很好![](../../img/Pasted%20image%2020231228103450.png)

### 两种算法的思考

- FCFS 算法考虑的是等待时间最长的进程/作业，没有考虑作业/进程的运行时间按，从而导致了短作业不友好的问题
- SJF 算法则选择执行时间最短的作业，没有考虑作业的等待时间，从而导致长作业不友好，甚至造成饥饿问题

考虑到作业等待时间、运行时间：**高响应比优先（HRRN，Highest Response Ratio Next）**

### 高响应比优先

![](../../img/Pasted%20image%2020231228104257.png)


例题：![](../../img/Pasted%20image%2020231228104045.png)

![](../../img/Pasted%20image%2020231228104202.png)

![](../../img/Pasted%20image%2020231228104223.png)

### 几个算法的对比

![](../../img/Pasted%20image%2020231228104308.png)

![](../../img/Pasted%20image%2020231228104359.png)

## 交互式系统的调度算法

![](../../img/Pasted%20image%2020231228104538.png)

### 时间片轮转（RR，Round-Robin）

![](../../img/Pasted%20image%2020231228113933.png)

例题：时间片轮转调度算法，常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间
![](../../img/Pasted%20image%2020231228113032.png)

时间片大小为 2时：
![](../../img/Pasted%20image%2020231228113421.png)

时间片大小为 5 时：
![](../../img/Pasted%20image%2020231228113525.png)
![](../../img/Pasted%20image%2020231228113536.png)

*时间片太大*会使得每一个进程都可以在一个时间片内完成（即*进程调度都发生在进程主动放弃处理机的时刻*），则 RR 会退化为 FCFS 算法，并且增大进程响应时间

*时间片太小*会使得进程切换过于频繁，导致系统大部分时间都在处理进程切换，实际用于进程执行的时间比例减少

一般，设计时间片时要让切换进程的开销占比不超过 1%

### 优先级调度算法

![](../../img/Pasted%20image%2020231228114932.png)

![](../../img/Pasted%20image%2020231228114105.png)
- 要注意优先数和优先级

![](../../img/Pasted%20image%2020231228114125.png)

![](../../img/Pasted%20image%2020231228114228.png)
![](../../img/Pasted%20image%2020231228114320.png)

补充：
- 就绪队列未必只有一个
- 优先级是否可以动态改变
	- *静态优先级*：创建进程时确定并保持不变
	- *动态优先级*：创建进程时有一个初始值，之后根据情况动态调整
- 合理设置进程优先级：
	- 系统进程 > 用户进程
	- 前台进程 > 后台进程
	- 操作系统更偏好 *IO 型进程*（IO 繁忙型进程）：让 IO 设备尽早投入工作，则资源利用率、系统吞吐量都可以得到提升
		- 相对的，计算型进程（CPU 繁忙型进程）
		- 二者可以并行工作
- 动态优先级何时调整
	- 从公平性、提升资源利用率等角度考虑
	- 某进程在就绪队列中等待了很长时间，则可以适当提升（与**高响应比优先算法**类似）
	- 某进程占用处理机运行了很长时间，则可以适当降低
	- 某一个进程频繁进行 IO 操作，则可以适当提升

### 思考

- FCFS 算法：公平
- SJF 算法：尽可能快处理完短作业工作
- 时间片轮转调度算法：让各个进程得到及时的响应
- 优先级调度算法：灵活调整各种进程被服务的机会

综合上述优点：**多级反馈队列调度算法**

### 多级反馈队列调度算法

![](../../img/Pasted%20image%2020231228115704.png)

![](../../img/Pasted%20image%2020231228115506.png)

![](../../img/Pasted%20image%2020231228115512.png)

### 几个算法的对比

![](../../img/Pasted%20image%2020231228115736.png)

![](../../img/Pasted%20image%2020231228115925.png)


