#computer 

---
**DFS**

# 与树的深度优先遍历之间的联系

树的深度优先遍历：**先根遍历**（图更类似），后根遍历

```cpp
void PreOrder(TreeNode *R)
{
	if (R!=NULL)
	{
		visit(R);
		while(R还有下一个子树)
			PreOrder(T);
	}
}
```

- 访问结点
- 检查是否还有子树
	- 有，递归访问

# 算法实现

![](../../img/Pasted%20image%2020231228180702.png)
![](../../img/Pasted%20image%2020231228180858.png)
![](../../img/Pasted%20image%2020231228180844.png)


# 算法存在的问题

同样对于非连通图，无法遍历所有节点

解决办法类似于，广度优先算法中的解决办法

![](../../img/Pasted%20image%2020231228180931.png)

# 复杂度分析

**空间复杂度**
![](../../img/Pasted%20image%2020231228181008.png)

**时间复杂度**
![](../../img/Pasted%20image%2020231228181048.png)


# 深度优先遍历序列

利用邻接表来锻炼手算：
![](../../img/Pasted%20image%2020231228181236.png)

- **注意**
	- 要分清目前是*广度优先*还是*深度优先*
	- 例如，以深度优先算法，从 3 开始，3 找到 4，下一步就需要从 4 开始找到第一个没被访问过的即 7，然后从 7 开始，依次寻找
	- 如果对应的链表中都被访问过，则返回上一层，寻找链表中没有被访问过的第一个结点
![](../../img/Pasted%20image%2020231228181522.png)

# 深度优先生成树

类比广度优先生成树

# 图的遍历和图的连通性

![](../../img/Pasted%20image%2020231228182119.png)

对于有向图，最关键在于图是否为强连通图
![](../../img/Pasted%20image%2020231228182147.png)











