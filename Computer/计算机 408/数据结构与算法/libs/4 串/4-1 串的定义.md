#computer 

---
# 定义

字符串，零个或多个字符组成的有限序列

串名，串的长度。空串

子串：串中任意个连续的字符组成的子序列

主串
字符在主串中的位置，子串在主串中的位置

串，一种特殊的线性表。
- **数据对象限定为字符集**
- 基本操作：增删改查，通常*以子串为操作对象*

# 基本操作

![](../../img/Pasted%20image%2020231213170129.png)

# 存储结构

## 顺序存储

```c
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN]; // 静态数组实现
	int length;
}SString;
typedef struct{
	char *ch;
	int length;
}HString; // 动态数组实现（堆分配存储）
HString S;
S.ch = (char *)malloc(MAXLEN*sizeof(char)); // 需要手动free
S.length = 0;
```

## 链式存储

```c
typedef struct StringNode{
	char ch;
	struct StringNode *next;
}StringNode, *String;
```
![](../../img/Pasted%20image%2020231213171341.png)

```c
typedef struct StringNode{
	char ch[4];
	struct StringNode *next;
}StringNode, *String;
```
![](../../img/Pasted%20image%2020231213171421.png)



## 基于顺序存储实现基本操作

`SubString (&Sub, S, pos, len)`：求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串

```c
bool SubString(&SString Sub, SString S, int pos, int len)
{
	if(pos+len-1 > S.length)
		return false;
	for (int i=pos;i<pos+len;i++)
		Sub.ch[i-pos+1] = S.ch[i];
	Sub.length = len;
	return true;
}
```

`StrCompare(S,T)`：比较操作。S>T，返回值>0；S=T，返回值=0；S<T，返回值<0

```c
int StrCompare(SString S, SString T)
{
	for(int i=1;i<=S.length && i<=T.length; i++)
	{
		if(S.ch[i]!=T.ch[i])
			return S.ch[i]-T.ch[i];
	}
	// 字符都相同，返回哪个更长
	return S.length-T.length;
}
```

`Index(S,T)`：定位操作。主串 S 中存在与串 T 相同的子串，则返回第一次出现的位置；否则返回 0
- 思路：
	- 从主串 S 中取出与串 T 相同长度的串，`SubString(&Sub, S, pos, len)`
	- 对比这个串和目标串 T 是否相等，`StrCompare(S,T)`

```c
int Index(SString S, SString T)
{
	int i =0, n=StrLength(S), m=StrLength(T);
	SString sub;
	while(i<=n-m+1)
	{
		SubString(sub, S,i,m);
		if(StrCompare(sub,T)!=0) ++i;
		else return i;
	}
	return 0; // S中不存在
}
```

