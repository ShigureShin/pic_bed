#computer 

---
# 二叉树基本概念

- 二叉树
	- 基本概念
	- 特殊的二叉树
		- 满二叉树
		- 完全二叉树
		- 二叉排序树
		- 平衡二叉树

![](../../img/Pasted%20image%2020231224180435.png)

![](../../img/Pasted%20image%2020231224180443.png)

特点：
- **每个结点最多有 2 个子树**
- **注意**：二叉树为有序树，及左右子树不能颠倒（*和度为 2 的有序树进行区别*）

# 二叉树的五种状态

![](../../img/Pasted%20image%2020231224180619.png)

# 几种特殊的二叉树

## 形态上特殊的二叉树

### 满二叉树

![](../../img/Pasted%20image%2020231224183025.png)

### 完全二叉树

完全二叉树中，如果某个结点只有一个孩子结点，那么一定是左结点![](../../img/Pasted%20image%2020231224183108.png)
### 二叉排序树

![](../../img/Pasted%20image%2020231225152447.png)

### 平衡二叉树

![](../../img/Pasted%20image%2020231225152606.png)

## 功能上特殊的二叉树

# 二叉树的常考性质

可以套用部分树的性质

![](../../img/Pasted%20image%2020231225153002.png)

![](../../img/Pasted%20image%2020231225153038.png)

![](../../img/Pasted%20image%2020231225153045.png)

# 完全二叉树的常考性质

![](../../img/Pasted%20image%2020231225153210.png)

另一个公式：![](../../img/Pasted%20image%2020231225153242.png)
注意两个公式中，向上取整和向下取整的书写方式

![](../../img/Pasted%20image%2020231225153315.png)

![](../../img/Pasted%20image%2020231225153531.png)

# 二叉树的存储结构

## 顺序存储

结点：数组 + 标记（是否为空）

完全二叉树的顺序存储，按照编号依次存储
![](../../img/Pasted%20image%2020231225154432.png)

实现的操作：
- 找到结点 i 的
	- 左孩子：2 i
	- 右孩子：2 i+1
	- 父节点：floor (i/2)
	- 所在层次：$ceil(\log_2(n+1))$ 或 $floor(\log_2n)+1$

若*完全二叉树*中共有 n 个结点，则
- 判断 i 是否有左孩子：2 i <= n
- 判断 i 是否有右孩子：2 i+1 <= n
- 判断 i 是否是叶子/分支结点：i > $floor(n/2)$

对于非完全二叉树，*要把二叉树的结点编号与完全二叉树对应起来*

![](../../img/Pasted%20image%2020231225155006.png)

![](../../img/Pasted%20image%2020231225155206.png)

则找到对应结点 i 的左孩子、右孩子、父节点、所在层次，和完全二叉树的判断条件一致

而对于下面三个判断，就不可以使用上述的条件了
- 判断 i 是否有左孩子
- 判断 i 是否有右孩子
- 判断 i 是否是叶子/分支结点
只能根据此时存储方式，先找到结点 i 的左孩子/右孩子的结点编号，然后去节点中查看空标签来确定

这种二叉树对于存储空间的利用不完全

*最坏的情况*：高度为 h 且只有 h 个结点的单支树（结点只有右孩子），也至少需要 $2^h-1$ 个存储单元

**结论**：二叉树的顺序存储结构，只适合存储完全二叉树。

实际应用中很少使用顺序存储方式来存储二叉树

## 链式存储

![](../../img/Pasted%20image%2020231225155615.png)

假设一个二叉树结点总数为 n，则该二叉树中指针域个数为 2 n，而这些指针域中真正有效存储了结点的个数为 n-1（去掉根节点剩下的都连接一个父节点），所以：
- 这些指针域中存在 n+1 个**空指针域**，即无效指针，或指向 NULL
- *这些指针域可以用于构造线索二叉树*
- 由于这种建立方式每个结点都有左右两个指针，所以这种实现方式也被称为**二叉链表**

具体的构建方式
![](../../img/Pasted%20image%2020231225160101.png)

- 找到结点 i 的左右孩子：直接通过指针访问
- 找到结点 i 的父节点：只能从根结点开始遍历
	- *如果实际应用情况下，需要经常查找父节点，可以给结点中增加一个父节点指针*（**三叉链表**）

# 二叉树的先/中/后序遍历

本节的先/中/后序遍历：利用二叉树的递归特性确定的次序规则

- 二叉树的递归特性
	- 要么是*空二叉树*
	- 要么是“*根节点+左子树+右子树*”组成的二叉树，根据访问顺序来分为三种遍历
		- **先序遍历**：NLR 根左右
		- **中序遍历**：LNR
		- **后序遍历**：LRN
	- （根节点的顺序）

![](../../img/Pasted%20image%2020231225162203.png)

- **分支节点逐层展开法**
	- ![](../../img/Pasted%20image%2020231225162513.png)

![](../../img/Pasted%20image%2020231225162600.png)

代码实现：

![](../../img/Pasted%20image%2020231225162808.png)

三种遍历方式：更换 visti 和递归遍历顺序更换一下

计算树的深度：![](../../img/Pasted%20image%2020231225163633.png)

## 二叉树的层序遍历

![](../../img/Pasted%20image%2020231225164032.png)

- 利用一个辅助队列
- 根节点入队
- 队列非空，头节点出队并访问，并将左右结点依次插入队尾（如果有）
- 重复上一步直到队列为空

这里使用的是链式队列

![](../../img/Pasted%20image%2020231225164639.png)

入队保存的其实是元素指针

## 遍历序列构造二叉树

以中序遍历为例

![](../../img/Pasted%20image%2020231225164909.png)

给定一个二叉树其中序遍历序列唯一，但给定中序遍历序列并不能唯一确定一个二叉树的结构

前序、后续、层次遍历也同理，也不能通过遍历序列唯一确定一个二叉树的结构

**结论**：只给出一棵二叉树的前中后层序遍历序列中的一种，不能唯一确定一棵二叉树

![](../../img/Pasted%20image%2020231225165108.png)

### 前序+中序遍历

前序遍历序列：根+左+右，确定根节点
中序遍历序列：左+根+右，确定根节点左子树的根节点

![](../../img/Pasted%20image%2020231225165208.png)

### 后序+中序遍历

![](../../img/Pasted%20image%2020231225165538.png)

### 层序+中序遍历

![](../../img/Pasted%20image%2020231225165747.png)


**总结**：
- 找到*根节点*
- 根据中序序列划分左右子树
- 再找到左右子树的根节点

# 线索二叉树

![](../../img/Pasted%20image%2020231226160435.png)

利用二叉树的中序遍历序列
- 找到指定结点 p 在中序遍历序列中的前驱？
- 找到 p 的中序后继？

![](../../img/Pasted%20image%2020231226160848.png)

**注意**：这里的前驱和后继都是以*中序遍历序列*为准的

线索二叉树作用：
- 方便从一个指定结点出发，找到其前驱、后继
- 方便遍历

## 中序线索二叉树

![](../../img/Pasted%20image%2020231226161042.png)

让空链域指向序列中的前驱和后继结点，这种指针被称为**线索**

这时再思考，如何找到给定节点 G 的后继？
- 通过后继线索即可找到

不过此时*还有一个问题*：如果给定结点例如 B 其右结点本身就不是空链域，那此时就无法通过这种方法找到该结点的后继

## 线索二叉树的存储结构

主要是与二叉树链式存储方式进行区分
![](../../img/Pasted%20image%2020231226161350.png)
给左右孩子增加了一个*线索标志位*
![](../../img/Pasted%20image%2020231226161356.png)

线索二叉树以链式存储方式实现，称为**线索链表**

同样有先序线索二叉树和后续线索二叉树，都是*以对应的遍历序列为依据进行“线索化”*

- 先序线索二叉树
	- 逻辑视角：![](../../img/Pasted%20image%2020231226161824.png)
	- 存储视角：![](../../img/Pasted%20image%2020231226161905.png)
- 后续线索二叉树
	- 逻辑视角：![](../../img/Pasted%20image%2020231226161938.png)
	- 存储视角：![](../../img/Pasted%20image%2020231226161946.png)

## 三种线索二叉树的对比

- 确定结点的先后关系时，需要根据此时序列是以何种方式进行遍历的
- **注意**
	- 这里的前驱和后继，例如中序前驱和中序后继，是指中序遍历序列中该结点的前一个结点和后一个结点
	- 先序前驱、先序后继和后序前驱、后序后继同理

## 二叉树的线索化（代码实现）

![](../../img/Pasted%20image%2020231226162434.png)
### 中序线索化

- **主要思路**
	- 利用 q 建立前驱线索 pre 
	- 利用 pre 建立后继线索 p 
		- 注意后继线索的建立，需要先确定前驱结点 `pre` 结点存在
	- 注意处理最后一个结点，检查其 rchild 是否为 NULL

**完整代码如下：**![](../../img/Pasted%20image%2020231226163515.png)
另一种写法：![](../../img/Pasted%20image%2020231226163714.png)
注意这里直接将最后一个结点进行了设置，因为中序遍历的最后一个节点的右结点指针必定为空

### 先序线索化

大体思路与中序线索化一致，但是存在一个可能会陷入无限循环的问题

先序遍历的代码为：![](../../img/Pasted%20image%2020231226164331.png)

如果继续使用中序遍历的线索化函数，则会出现下面这种情况：
- 对于当前的一个结点 T，由于 visit 中会对结点 T 的左右结点进行线索化
- 而在先序遍历函数中，对当前结点 T visit 完毕后，会对结点 T 的 lchild 进行 visit
- 此时 T 的 lchild 已经被线索化，*指向了结点 T*
- 于是陷入了无限的循环中

*如何解决这种问题？*
- 利用线索标志位
	- 当线索标志位为 1 时，才对结点 T 的左孩子进行遍历
	- 即![](../../img/Pasted%20image%2020231226164622.png)
- 本次结点 T 的右节点需要在更新 pre 时才会修改，所以此时并不影响

其余部分与中序线索化一致

另一种写法：![](../../img/Pasted%20image%2020231226164708.png)
### 后序线索化

后序遍历的代码：![](../../img/Pasted%20image%2020231226164831.png)

可以发现，在 visit 结点 T 之前已经对结点 T 的左右孩子进行了处理，所以此时是不会发生先序线索化中结点之间无限循环的问题

![](../../img/Pasted%20image%2020231226164959.png)


## 线索二叉树查找前驱和后继

### 中序线索二叉树

#### 找中序后继

给定结点 P 没有被线索化时，中序后继为结点 P 的右子树中最先被遍历的结点

![](../../img/Pasted%20image%2020231227154944.png)
#### 找中序前驱

给定结点 P 没有被线索化时，中序前驱为结点 P 的左子树中最后被遍历的结点

![](../../img/Pasted%20image%2020231227155245.png)

### 先序线索二叉树

#### 找先序后继

![](../../img/Pasted%20image%2020231227155456.png)

#### 找先序前驱

先序遍历中，如果结点的左右子树存在，则其左右子树中的结点只可能是根的后继，不可能是前驱（可以利用暴力法从头开始先序遍历找到结点前驱）

除非为三叉链表的方式实现，直接从结点访问父节点，下面对这种能够找到父节点的情况进行分析

![](../../img/Pasted%20image%2020231227155820.png)

### 后序线索二叉树
#### 找后序后继

和先序线索二叉树的找先序前驱类似，后序线索二叉树中给定结点的左右子树如果存在则只可能是根节点的前驱，不可能是后继。（也可以直接从头开始重新遍历寻找后序后继）

为了能够找到后序后继同样需要考虑特殊情况，即三叉链表存储线索树

![](../../img/Pasted%20image%2020231227160608.png)

#### 找后序前驱

![](../../img/Pasted%20image%2020231227155910.png)

### 小结

![](../../img/Pasted%20image%2020231227160638.png)
