#computer 

---
# 什么是单链表

**单链表**：用*链式存储*（物理/存储结构）实现*线性结构*（逻辑结构）

每个节点除了存放数据元素，还要存储指向下一个节点的指针
- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可以随机存取，需要耗费空间存放指针

```c
typedef struct LNode{
	ElemType data; // 该节点的数据元素
	struct LNode *next; // 下一个节点指针
}LNode, *LinkList;
```

- `LNode` 和 `*LinkList` 命名方式所代表的含义：
![](../../img/Pasted%20image%2020231207110408.png)

# 定义：代码实现

```c
typedef struct LNode{  //定义单链表节点类型
	ELemType data; // 节点存放数据元素
	struct LNode *next; // 下一个节点指针
}LNode, *LinkList;
```


## 不带头节点的单链表

- 空表判断 `L==NULL`

```c
// 初始化空的单链表
bool InitList(LinkList &L)
{
	L = NULL; // 空表
	return true;
}
// 判断是否为空
bool Empty(LinkList L)
{
	return (L == NULL);
}
void test()
{
	LinkList L; // 声明一个单链表指针
	// 初始化
	InitList(L);
	//...
}
```

## 带头节点的单链表

- 空表判断 `L->next==NULL`
- 头节点不存放数据，下一个节点才开始存放数据

```c
// 初始化空的单链表（头节点）
boo InitList(LinkList &L)
{
	L = (LNode *)malloc(sizeof(LNode)); // 分配一个节点
	if (L==NULL) // 内存不足，分配失败
		return false;
	L->next = NULL; // 头节点后暂无其他节点
	return true;
}
// 判断是否为空
bool Empty(LinkList L)
{
	return (L->next == NULL);
}
void test()
{
	LinkList L; // 声明一个单链表指针
	// 初始化
	InitList(L);
	//...
}
```

![](../../img/Pasted%20image%2020231207111624.png)

- *如上图，所以之前自己做 leetcode 题的时候会看到 `header->next` 和 `header->data` 这里的 header 其实是头节点的指针*

- 关键区别在于，第一个节点位置是否存放数据

# 基本操作的实现

## 单链表的插入

### 按位序插入

#### 带头结点

在第 i 个位置插入元素 e ：这里的 i 表示位序，头节点位置认为是 0 但头节点没有数据，头节点的位序只是为了描述方便）

- 找到第 i-1 个节点
- 将插入节点 e 的 next 指向原节点 i 
- 将节点 i-1 的 next 指向插入节点 e 

- *画画图，加深理解*

![](../../img/Pasted%20image%2020231207114824.png)

```c
// 在第i个位置插入元素e（带头节点）
bool ListInsert(LinkList &L, int i, Elemtype e)
{
	/* 判断i是否指向头节点之前 */
	if(i<1)
		return false;
	/* 声明一些参数 */
	LNode *p; // 记录p指向的节点
	int j=0; // 记录p指向的是第几个节点
	/* 开始查找第i-1个节点 */
	p = L; // 初始化p为头节点
	while (p!==NULL && j<i-1) // 找到第i-1个节点
	{
		p = p->next;
		j++;
	}

	/* 指定节点的后插操作 */
	/* 确认查找到的位置是否合法 */
	if(p==NULL)
		return false;
	LNode *s = (LNode *)malloc(sizeof(LNode));
	s->data = e;
	/* 注意这里的顺序不能变更 */
	s->next = p->next; // s连接原第i个节点
	p->next = s; // 原第i-1个节点连接插入的节点
	// 这里不能free掉s
	return true;
}
```

- 时间复杂度分析：
	- 最好的情况：在头节点之后插入，$O(1)$
	- 最坏的情况：在尾节点之后插入，$O(n)$
	- 平均情况：$O(n)$

#### 不带头节点

*头指针 L*

因为这种链表不存在头节点，即不存在节点 0，所以我们之前所想的“找到第 i-1 个节点”的想法是无法对所有情况成立的，所以此时关键在于：
- i=1 时的特殊情况处理
- 其余位置同带头节点

```c
bool ListInsert(LinkList &L, int i, ElemType e)
{
	if(i<1)
		return false;
	/* 对i==1时特殊讨论 */
	if(i==1)
		LNode *s = (LNode *)malloc(sizeof(LNode));
		s->data = e;
		s->next = L; // 这里的L相当于带头结点中的header->next
		L = s; // 在将L指向插入的节点
		return true;
	/* 找到参考节点 */
	LNode *p;
	int j=1; // 无头节点从1开始查找
	p = L;
	while (p!=NULL && j<i-1)
	{
		p=p->next;
		j++;
	}
	
	/* 指定节点的后插操作 */
	if(p==NULL)
		return false;
	LNode *s = (LNode *)malloc(sizeof(LNode));
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;
}
```

![](../../img/Pasted%20image%2020231207114803.png)

### 指定节点的后插操作

![](../../img/Pasted%20image%2020231207115927.png)

```c
bool InsertNextNode(LNode *p, ElemType e)
{
	if(p==NULL)
		return false;
	LNode *s = (LNode *)malloc(sizeof(LNode));
	if (s==NULL)
		return false;
	s->date = e;
	s->next = p->next;
	p->next = s;
	return true;
}
```

- 时间复杂度：$O(1)$

### 指定节点的前插操作

普通方式：
- 同时传入链表 L、指定节点 p 以及需要插入的数据 e 
- 依次查找链表 L 直到找到指向节点 p 的前置节点 q
- 执行对节点 q 的后插操作
- 时间复杂度：$O(n)$

**不需要知道节点 p 之前信息的方式**：
- 新建临时节点 s 执行： `s->next=p->next; s->data=p->data;`
- 再将原节点 p 执行：`p->data=e;`
- 时间复杂度：$O(1)$

![](../../img/Pasted%20image%2020231207120850.png)

- 节点 p 之前插入节点 s 
```c
bool InsertPriorNode(LNode *p, LNode *s)
{
	if(p==NULL || s==NULL)
		return false;
	s->next = p->next;
	p->next = s;
	ElemType temp = p->data;
	p->data=s->data;
	s->data=temp;
	return true;
}
```

## 单链表的删除

### 按位序删除

- 删除第 i 个节点
```c
bool ListDelete(LinkList &L, int i, ElemType &e)
{
	if(i<1)
		return false;
	LNode *p;
	int j=0;
	p=L;
	while (p!=NULL && j<i-1)
	{
		p=p->next;
		j++;
	}
	if(p==NULL) // i值不合法
		return false;
	//要删除的结点不存在
	if(p->next==NULL) // 节点i-1之后无节点
		return false;
	LNode *q=p->next;
	e = q->data;
	p->next=q->next;
	free(q);
	return true;
}
```

- 时间复杂度
	- 平均和最坏：$O(n)$
	- 最好：$O(1)$

### 指定节点的删除

- 不利用前驱节点的操作

```c
bool DeleteNode(LNode *p)
{
	if(p==NULL)
		return false;
	// 存在bug，如果此时p为最后一个节点
	// q为null，只能从前往后依次寻找
	LNode *q = p->next;
	p->data = q->data;
	p->next = q->next;
	free(q);
	return true;
}
```

- 时间复杂度：$O(1)$

- 总结：
	- 单链表的局限性，*无法逆向检索*

## 单链表的查找

*这里只讨论带头节点的情况*

### 按位查找

`GetElem(L,i)` 按位查找操作，获取表 L 中第 i 个位置的元素的值

```c
LNode * GetElem(LinkList L, int i)
{
	if (i<0)
		return NULL;
	LNode *p;
	int j=0;
	p=L; // 指向头节点
	while (p!=NULL && j<i){
		p=p->next;
		j++;
	}
	return p;
}
```

- O(n)

### 按值查找

`LoateElem(L,e)` 按值查找操作，在表 L 中查找具有给定关键字值的元素

```c
LNode * LocateElem(LinkList L, ElemType e)
{
	LNode *p = L->next;
	while (p!=NULL && p->data!=e)
		p = p->next;
	return p;
}
```

- 时间复杂度：O(n)


## 单链表的长度

```c
// 带头节点
int Length(LinkList L)
{
	int len=0;
	LNode *p=L;
	while (p->next != NULL)
	{
		p=p->next;
		len++;
	}
	return len;
}

// 不带头节点
int Length_noHead(LinkList L)
{
	int len=0;
	LNode *p=L;
	while (p != NULL)
	{
		p=p->next;
		len++;
	}
	return len;
}

```

- 时间复杂度 O (n)

## 单链表的建立

问题：将多个数据元素，存在一个单链表里

- 初始化一个单链表
- 每次取一个数据元素，插入到表头或表尾

### 尾插法

- 利用先前实现的后插操作，这样每次插入一个数据元素的时间复杂度为 O (1)
- 将全部 n 个数据元素插入完毕的时间复杂度为 O(n) 

不带头节点：需要判断链表是否为空来区分第一个元素的插入和其余位置的插入，前者单独讨论，后者同上

### 头插法

- 对头节点的后插操作
	- 此时需要注意：初始化创建头节点后要将头节点的 next 指向 null
	- 因为这里是对头节点后插，所以要保证头节点最开始指向的位置为 null，不然有可能是指向其他未知数据

不带头节点：通过节点前插操作




