#computer 
- 高级语言与机器级代码之间的对应关系
---

汇编语言基础知识

高级语言 -> 汇编语言 -> 机器语言

![](../img/Pasted%20image%2020231212120005.png)

- **机器级代码**
	- **机器语言**：二进制代码
	- **汇编语言**：助记符
		- 只关注x86汇编语言
		- 简单的C语言程序、汇编语言、机器语言表示
			- 看懂关键语句，常见指令、选择结构、循环结构、函数调用
		- 汇编语言、机器语言的一一对应
			- 结合汇编语言分析机器语言指令的格式、寻址方式

# x86汇编语言指令基础

Interl x86架构CPU
起源：代号为8086的cpu

- 指令的作用
	- 改变程序执行流
	- *处理数据*
- 指令格式：操作码+地址码
	- 操作码：怎么处理？
	- 地址码：数据在哪里？
		- 寄存器：指令中指出“寄存器名”
			- x86架构的cpu有哪些寄存器
		- 主存：指令中给出“主存地址”
			- 怎么在指令中指明读写长度
		- 指令中：直接在指令中给出要操作的数
			- 即，立即寻址

![](../img/Pasted%20image%2020231213085253.png)

## 数据在哪里？

### x86架构 cpu 的寄存器 

![](../img/Pasted%20image%2020231213085324.png)

- 变址寄存器用于线性表、字符串的处理
- 堆栈寄存器实现函数调用 
- 如果想用通用寄存器的低16bit，可以去掉寄存器名称的 e 
	- 使用8bit：AH、AL、BH、BL 等 
	- 其余两种寄存器只能固定使用32bit 

![](../img/Pasted%20image%2020231213085810.png)

### 总结

![](../img/Pasted%20image%2020231213085915.png)

## 怎么处理？

常用 x86汇编指令 
- 算术运算
- 逻辑运算
- 其他运算

### 常见的算术运算指令

- destination：目的（d 目的操作数） 
	- **目的操作数d**不可以是*常量*
	- 运算后结果会继续存在d中
- source：来源地（s 操作数） 
- 两个操作数不会同时来自主存

| 功能   | 汇编指令           | 注释                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| 加     | add d,s            | 计算`d+s`，结果存入d                                         |
| 减     | sub d,s            | 计算`d-s`，结果存入d                                         |
| 乘     | mul d,s / imul d,s | 无符号数`d*s`，结果存入d；有符号数`d*s`，结果存入d           |
| 除     | div s / idiv s     | 无符号数除法：`edx:eax/s`，商存入eax，余数存入edx ；无符号数 |
| 取负数 | neg  d             | d取负数，结果存入d                                           |
| 自增++ | inc d              | d++，结果存入d                                               |
| 自减-- | dec d              | d--，结果存入d                                                             |

- 除法：
	- 被除数是隐含的
	- 需要先把被除数进行位扩展，如32位/32位，需要先扩展为64位
		- 所以这里的寄存器是两个连起来用的：`edx:eax`
		- 高32位和低32位分别存在两个寄存器中

### 常见的逻辑运算指令

- 结果都放回到 d 所指位置

| 功能 | 汇编指令 | 注释                      |
| ---- | -------- | ------------------------- |
| 与   | and d,s  | d、s逐位相与，结果放回d   |
| 或   | or d,s   | 逐位相或                  |
| 非   | not d    | 逐位取反                  |
| 异或 | xor d,s  | 逐位异或                  |
| 左移 | shl d,s  | d逻辑左移s位，s通常为常量 |
| 右移 | shr d,s  | d逻辑右移s位，s通常为常量                          |

### 其他指令

- 用于实现*分支结构、循环结构*的指令：cmp、test、jmp、jxxx
- 用于*实现函数调用*的指令：push、pop、call、ret
- 用于*实现数据转移*的指令：mov


# AT&T 格式 v.s. Intel 格式（x 86）

- AT&T 格式
	- Unix、Linux 的常用格式
- Intel
	- windows 常用格式

![](../img/Pasted%20image%2020231213091734.png)

- at&t 格式
	- 两个操作数位置和 x 86 的格式是相反的
	- 寄存器名称之前要加% 
	- 立即数之前加$
	- 主存地址用小括号：()
	- 指令后读写长度，在指令后以 b、w、l 结尾表示不同的读写长度
	- 主存地址偏移量的写法
		- ![](../img/Pasted%20image%2020231213092219.png)

# 选择语句的机器级表示

## 程序中的选择语句（分支结构）

注：Intel x 86 处理器中
- 程序计数器 PC（Program Counter） 通常被称为*IP*（Instruction Pointer）

### 跳转指令

- 使用汇编语言中的标号来标记位置

![](../img/Pasted%20image%2020231213095414.png)

但此时无法根据条件跳转

### 条件转移指令--jxxx

![](../img/Pasted%20image%2020231213101201.png)

- 一个示例：
![](../img/Pasted%20image%2020231213101303.png)

![](../img/Pasted%20image%2020231213102327.png)

# 循环语句的机器级表示

## 用条件指令实现循环

![](../img/Pasted%20image%2020231213102715.png)

## 用 loop 指令实现循环

![](../img/Pasted%20image%2020231213103017.png)

- loop 默认指定 ecx 来进行循环计数器
- loopx 类指令，在 ecx!=0 的基础上再增加某种判断条件

# 函数调用的机器表示

两条相关的语句：
- call
- ret

函数调用栈（一片内存区域）
- 函数的*栈帧 StackFrame* ：保存函数大括号内定义的*局部变量*、保存*函数调用*相关的信息

## 函数调用的过程

- add：用函数名作为函数起始地址的<标号>
- call add：即为调用 add 函数
- ret 为返回指令
![](../img/Pasted%20image%2020231213104320.png)

分析指令的作用：
- call 指令
	- 将 IP 旧值*压栈保存*（保存在函数的栈帧顶部），相当于：push(IP)
	- 设置 IP 新值，*无条件转移*至被调用函数的第一条指令，相当于：jmp add
- ret 指令
	- 从栈帧的顶部*找到 IP 旧值*，将其*出栈并恢复* IP 寄存器
	- ![](../img/Pasted%20image%2020231213104703.png)

**问题**：
- 函数如何传递参数、返回值？
- 如何访问栈帧的数据？
- 栈帧内可能保存什么内容？
- ![](../img/Pasted%20image%2020231213105347.png)

## 如何访问栈帧中的数据？

**问题**：如何访问栈帧中的数据

### 函数调用栈在内存中的位置

- 栈底：高地址
- 栈顶：低地址

![](../img/Pasted%20image%2020231213110520.png)

### 标记栈帧范围：EBP、ESP 寄存器

- 一个 cpu 内部只有一个 EBP 和一个 ESP
	- EBP：堆栈基指针 BasePointer
	- ESP：堆栈顶指针 StackPointer
- 当前栈帧结束后要退回到下一个栈帧的“顶”和“底”
![](../img/Pasted%20image%2020231213110641.png)

### 访问栈帧数据
#### push 、pop 指令

- x 86 中 push 和 pop 默认为 4 字节为单位
![](../img/Pasted%20image%2020231213111227.png)

*只能访问栈顶位置*

#### mov 指令

访问栈帧中的位置

![](../img/Pasted%20image%2020231213111533.png)

- 利用 mov 指令，结合 esp、ebp 指针访问栈帧数据
- 减法/加法指令，即 sub/add 修改栈顶指针 esp 的值


### 总结

1. push/pop 指令
2. mov 指令

由于一个 cpu 只有一个 ebp 和一个 esp，所以进行函数调用的时候需要进行*栈帧的切换*

## 如何切换栈帧？

- 函数调用：修改栈帧范围
- 函数返回：修改栈帧范围

*一定要注意 IP 指向的是当前指令的下一条指令*

回想函数调用的过程：
- call add：
	- 将 IP 旧值压栈保存，push (IP)
	- 设置 IP 新值，无条件转移到被调用函数的第一条指令，jmp add
- 被调用函数开头的例行处理：*保存上一层*函数的栈帧基址并*设置当前*函数的栈帧基址
![](../img/Pasted%20image%2020231213112248.png)



![](../img/Pasted%20image%2020231213112835.png)

函数 ret 返回之前例行处理 leave 
- ret 指令的作用
	- 从函数的栈帧顶部找到 IP 旧值，将其出栈并恢复 IP 寄存器

![](../img/Pasted%20image%2020231213113030.png)


## 栈帧内容包含什么？

### 栈帧的底部和顶部：上一层栈帧基址和旧的 IP 地址

- *栈帧最底部*一定是*上一层栈帧基址*（ebp 旧值）
- *栈帧最顶部*一定是*返回地址*（当前函数的栈帧除外）
	- 因为调用其他函数前肯定会保存当前的 IP 地址
	- 然后才会进入被调用函数中保存上一层的栈帧基址

![](../img/Pasted%20image%2020231213113851.png)

### 栈帧底部一侧和顶部一侧：当前函数的局部变量，所调用函数的参数

- 示例代码
![](../img/Pasted%20image%2020231213114809.png)
- *局部变量*通常被集中存储在*栈帧底部*区域
	- 通过当前栈帧的 ebp 来访问
		- `[ebp-4]` 最后一个被定义的变量，即图中 sum 
		- `[ebp-8]`
![](../img/Pasted%20image%2020231213114820.png)

- *调用参数*集中存储在*栈帧顶部*区域
	- 访问上一层传过来的参数
	- 使用当前函数的 ebp 来访问
		- `[ebp+8]` 参数列表的第一个参数，即图中 x
		- `[ebp+12]` 参数列表的第二个参数，即图中 y
![](../img/Pasted%20image%2020231213115057.png)

### 栈帧的中间部分：（可能）空闲区域

- gcc 编译器将每个栈帧大小设置为 16 B 的整数倍（当前正在运行的函数的栈帧除外），因此栈帧内可能出现*未使用*的区域
	- 只要当前函数开始调用下一层的函数，一定会*凑齐*16B 的整数倍的大小

### 总结：栈帧中可能包含的内容

![](../img/Pasted%20image%2020231213115925.png)

- 栈帧的顶部和底部的：*上一层栈帧地址*和*IP 返回地址（调用时）*是一定存在的

## 参数、返回值传递

![](../img/Pasted%20image%2020231213120839.png)

- 通过寄存器来传递返回值
- **思考**：如果此时寄存器中存在其他需要使用的值？
	- 提前将寄存器中的旧值进行压栈保存
	- 等寄存器使用完毕后再出栈保存到原寄存器中即可（*所以栈帧中还可能存在一片保存寄存器值的区域*）

## 总结

![](../img/Pasted%20image%2020231213121104.png)

![](../img/Pasted%20image%2020231213121253.png)
