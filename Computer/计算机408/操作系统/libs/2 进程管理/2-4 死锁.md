#computer 
- 什么是死锁
- 进程死锁、饥饿、死循环的区别
- 死锁产生的必要条件
- 什么时候会发生死锁
- 死锁的处理策略
---
## 2.4.1 什么是死锁？

*并发环境*下，*多个进程同时*对某个*有限共享资源*进行*竞争访问*，而*资源数量不足以同时满足进程数量*，最终*导致各个进程都发生阻塞无法向前推进*的现象。
- 无外力干涉进程将都无法向前推进

## 2.4.2 死锁、饥饿、死循环

- 死锁：各个进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
- 饥饿：由于长期得不到想要的资源，某个进程无法向前推进的现象
- 死循环：进程执行过程中一直跳不出某个循环的现象，可能是程序逻辑 bug，也可能是故意为之

![](../../img/Pasted%20image%2020231229171728.png)

## 2.4.3 死锁产生的必要条件

四个条件必须全部满足

- **互斥条件**
	- 只有对必须互斥使用的资源的争抢才会导致死锁
- **不可剥夺条件**
	- 进程所获得的资源使用结束之前，*不能由其他进程强行夺走*，只能主动释放
- **请求和保持条件**
	- 进程*已经保持了一个资源*，同时*请求新的资源*，而该资源又被其他进程占有，此时请求阻塞，同时不释放自己持有的资源
- **循环等待条件**
	- 存在某个*进程资源的循环等待链*

**注意**：
- 发生死锁时一定有循环等待
- 但发生循环等待时未必死锁

## 2.4.4 什么时候发生死锁？

1. 对系统（*不可剥夺*）资源的竞争
2. 进程推进顺序非法（*请求和释放资源的顺序不当*）
3. 信号量的使用不当

总结：对不可剥夺资源的不合理分配，容易导致死锁

## 2.4.5 死锁的处理策略

1. **预防死锁**。破坏死锁产生的四个必要条件中的一个或几个
2. **避免死锁**。用某种算法避免系统进入不安全状态（*银行家算法*）
3. **死锁的检测和解除**。允许死锁发生，但操作系统会负责检测死锁的发生，并采取措施解除死锁

### 不允许死锁发生

#### 静态策略：预防死锁

*主要思想*：想办法破坏四种死锁必要条件的某一个或几个
- 破坏互斥条件
- 破坏不可剥夺条件
- 破坏请求和保持条件
- 破坏循环等待条件
##### 破坏互斥条件

![](../../img/Pasted%20image%2020231229174055.png)

##### 破坏不可剥夺条件

![](../../img/Pasted%20image%2020231229174241.png)

##### 破坏请求和保持条件

![](../../img/Pasted%20image%2020231229174414.png)

##### 破坏循环等待条件

![](../../img/Pasted%20image%2020231229174709.png)

#### 动态策略：避免死锁
##### 安全序列

![](../../img/Pasted%20image%2020231229175245.png)
![](../../img/Pasted%20image%2020231229175252.png)

经过考虑可以得到借钱序列：T->B->A, A->T->B

##### 系统的不安全状态，与死锁的联系

![](../../img/Pasted%20image%2020231229175429.png)

- **安全序列**：系统按照这种序列分配资源，则每个进程都可以顺利完成。能找到这样一个*安全序列*就表明系统是*安全状态*。
- 如果分配资源后，系统找不到这样一个安全序列，则进入*不安全状态*

综上，
- 系统处于*安全状态*，*一定不会*发生死锁
- 如果进入*不安全状态*，则*可能*发生死锁

根据上面分析，为了避免死锁的发生，可以在*分配资源之前，预先确认这种分配方式是否会导致系统进入不安全状态*，据此判断是否执行本次资源分配
- *银行家算法*的核心思想

##### 银行家算法

**核心思想**：进程提出资源请求时，先预判此次分配是否会导致系统进入不安全状态。
- 会，则拒绝本次请求，并让进程组赛
- 不会，则进行资源分配

利用向量来表示系统中存在的多种资源的情况，例如三种资源，初始数量为 $(10,5,7)$

**手算安全序列**

![](../../img/Pasted%20image%2020231229180300.png)

![](../../img/Pasted%20image%2020231229180308.png)

**算法实现**

![](../../img/Pasted%20image%2020231229180705.png)

![](../../img/Pasted%20image%2020231229180826.png)

### 允许死锁发生：死锁的检测和解除

#### 死锁的检测
主要思路：
- 用*某种数据结构*保存资源的请求和分配信息
- 提供*一种算法*，利用上述信息检测系统是否进入死锁状态
![](../../img/Pasted%20image%2020231229181235.png)

![](../../img/Pasted%20image%2020231229181432.png)

**死锁定理**：如果某时刻系统的资源分配图是*不可完全简化*的，那么此时系统*死锁*
![](../../img/Pasted%20image%2020231229182301.png)
#### 死锁的解除

**找到死锁进程**：
- 利用*死锁检测算法*化简资源分配图后，还连着边的那些进程就是死锁进程

1. *资源剥夺法*。挂起死锁进程，抢占其资源，并分配给其他死锁进程，同时需要防止被挂起的资源出现饥饿
2. *撤销/中止进程法*。强制撤销部分、甚至全部死锁进程，剥夺进程占有的资源
	- 实现简答
	- 可能代价很大，例如某些进程已经长时间运行快要结束结构被中终止
3. *进程回退法*。让一个或多个死锁进程退回到避免死锁发生的状态（需要进程记录历史信息，*设置还原点*）

**关键问题**：对多个死锁进程中的哪个一个动手？
1. 进程优先级：找最低
2. 已经执行时间：找最短
3. 还有多久完成：找最长
4. 已经使用多少资源：找最多
5. 进程是交互式还是批处理式：找批处理



