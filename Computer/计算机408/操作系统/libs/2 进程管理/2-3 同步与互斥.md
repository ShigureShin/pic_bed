#computer 

---

什么是？
- 进程同步
- 进程互斥

回顾，进程的异步性：各并发执行的进程以各自独立的、不可预知的速度向前推进

进程同步的目的，解决某些情况下需要进程以可以预知的次序执行的需求

## 2.3.1 什么是进程同步？

以写进程写数据和读进程读数据（同一串数据）为例，读进程必须发生在写进程之后，而进程具有异步性，所以*进程同步就是为了解决这种异步问题*

**同步**：*直接制约关系*，为完成某个任务而建立的两个进程，因为需要在某些位置上*协调它们的工作次序*而产生的制约关系

## 2.3.2 什么是进程互斥？

进程的“并发”需要“共享”的支持，进程不可避免地需要共享使用一些资源

两种资源共享方式：
- **互斥共享**：一个时间段内只允许一个进程访问该资源
	- 这种资源称为“**临界资源**”，对这种资源的访问必须*互斥*进行
- **同时共享**：允许一个时间段内被多个进程“同时”访问

### 实现互斥的四个逻辑

这种对临界资源的互斥访问，是一种进程间的*间接制约关系*，逻辑上分为四部分：
- **进入区**
	- 检查是否可进入，并设置是否正在访问临界资源的标志（上锁）
- **临界区**（临界段）
	- 访问临界资源的代码
- **退出区**
	- 解除正在访问标志（解锁）
- **剩余区**
	- 其他处理

*进入区*和*临界区*是*负责实现互斥*的代码段，*临界区*是访问临界资源的代码段

### 实现互斥的四个原则

**思考**：如果一个进程暂时不能进入临界区，那么该进程是否会一直占用处理机？有没有可能一直进不了临界区？

实现进程互斥，需要考虑上面的问题，因而给出几个需要遵循的原则：
1. **空闲让进**：临界区空闲，可以允许一个请求进入临界区的进程立即进入临界区
2. **忙则等待**：已有进程进入临界区，其他试图进入的临界区的进程必须等待
3. **有限等待**：保证在有限时间内能够进入临界区（防止饥饿）
4. **让权等待**：进程不能进入临界区则立即释放处理机，防止进程忙等待

## 2.3.3 进程互斥的实现

1. 理解算法的思想、原理
2. 结合“实现互斥的四个逻辑”，重点理解算法在*进入区*和*退出区*的行为
3. 分析各算法的缺陷（结合四个实现原则进行分析）

### 软件实现方法

#### 单标志法

**算法思想**：进程在访问完临界区后把临界区使用权交给另一个进程，*进入临界区的访问权只能由另一个进程赋予*

![](../../img/Pasted%20image%2020231229091220.png)

本质上为轮流访问，实现了*同一时刻最多只允许一个进程访问临界资源*

但轮流访问会导致虽然临界资源空闲，但只要没有轮到自己访问就一直不访问
- 违反了**空闲让进**的原则

#### 双标志先检查

**算法思想**：设置一个布尔型数组 `flag[]`，数组中各个元素来*标记各进程进入临界区的意愿*

![](../../img/Pasted%20image%2020231229091806.png)

**问题**：如果两个程序并发运行，会出现两个进程同时进入临界区的情况
- 违反了**忙则等待**原则
- **原因**：*进入区的“检查”和“上锁”两个处理分步进行*，“检查”后，“上锁”前可能发生进程切换

#### 双标志后检查

**算法思想**：同双标志先检查法，但改为*先“上锁”后“检查”*

![](../../img/Pasted%20image%2020231229092218.png)

**问题**：并发执行的进程容易出现都无法访问资源的问题
- 解决“忙则等待”
- 进程之间“争抢”进入临界区，违背了**空闲让进**和**有限等待**原则，长期无法访问而产生饥饿现象

#### Peterson 算法

**算法思想**：结合双标志法、单标志法的思想。
- 核心：双方都争抢进入临界区，让进程尝试进行“谦让”

![](../../img/Pasted%20image%2020231229092723.png)

**问题**：没有遵循*让权等待*
- 进程如果无法进入临界区会陷入循环中

### 硬件实现方法

#### 中断屏蔽方法

利用“开/关中断指令”实现（与原语思想相同）

即，进程开始访问临界区到结束访问为止都不允许被中断，也不能发生进程切换

![](../../img/Pasted%20image%2020231229093753.png)

**优点**：简单、高效
**缺点**：
- 不适用于多处理机（两个处理机都想要访问）
- 只适用于操作系统内核进程，不适用于用户进程（因为开关中断指令只能在内核态）

#### TestAndSet/TestAndSetLock（TS 指令/TSL 指令）

![](../../img/Pasted%20image%2020231229093944.png)

硬件实现中，可以保证“检查”和“上锁”一气呵成

**优点**：
- 实现简单，不需要严格检查是否有逻辑漏洞
- 适用于多处理机环境
**缺点**：
- 不满足“**让权等待**”
- 暂时无法进入临界区的进程会占用 CPU 并循环 STL 指令，导致“忙等”

#### Swap 指令（XCHG 指令）

Swap 指令为硬件实现，执行过程中不允许中断

C 语言描述逻辑：
![](../../img/Pasted%20image%2020231229094323.png)

逻辑上，Swap 和 TSL 没有太大区别
- 先记录此时临界区是否上锁
- 无论如何都进行上锁
- 检查 old

**优缺点**：同 TSL 指令

### 互斥锁

![](../../img/Pasted%20image%2020231229094550.png)

![](../../img/Pasted%20image%2020231229094631.png)

## 2.3.4 信号量机制

![](../../img/Pasted%20image%2020231229095045.png)

思考两个问题：
1. 让“检查”和“上锁”一气呵成
2. 真正实现“让权等待”

**信号量**：一种变量，用来表示*系统中某种资源的数量*

用原语实现，目的是利用原语的一气呵成，执行中不会被中断的特性

**一对原语**：`wait(S)` 原语和 `signal(S)` 原语
- 简称 P、V 操作
- 也可以写为 `P(S)` 和`V(S)`

利用这两个原语对系统资源进行“申请”和“释放”

### 整型信号量

**对信号量的操作只有三种**：
- 初始化
- P 操作
- V 操作

![](../../img/Pasted%20image%2020231229095816.png)

### 记录型信号量

![](../../img/Pasted%20image%2020231229100009.png)

![](../../img/Pasted%20image%2020231229100344.png)

### 信号量机制实现进程互斥、同步、前驱关系

#### 进程互斥

1. 分析并发进程的关键活动，划定临界区
2. 设置*互斥信号量 mutex*，**初值为 1**（同步中信号量设置为 0）
3. 进入区 P(mutex)--申请资源
4. 临界区
5. 退出区 V(mutex)--释放资源

- *不同临界区资源*设置*不同的互斥信号量*
- PV 操作要成对出现
	- P 保证临界资源的互斥访问
	- V 保证资源被释放（或着说资源处于可以使用的状态）并唤醒等待的进程

#### 进程同步

*让各并发进程按照要求有序推进*

例如有两个程序 P1 和 P2 并发执行，由于异步性，二者*交替推进*的次序是不确定的。如果此时 P2 中的某条代码是基于 P 1 的某条代码的运行结果，则需要保证 P2 的这条代码一定在 P1 的这条代码之后运行

1. 分析什么地方需要实现同步关系，即*必须保证一前一后执行的两个操作*
2. 设置*同步信号量 S*，**初始为 0**（互斥中信号量设置为 1）
3. “前操作（下图中代码 2）”之后执行 V(S)
4. “后操作（下图中代码 4）”之前执行 P(S) 

这里的前后操作表示，进程 P2 的代码 4 是基于进程 P 1 的代码 2 之上运行的，代码 2 为代码 4 的前操作，代码 4 即为代码 2 的后操作

![](../../img/Pasted%20image%2020231229102802.png)
分析：
- 如果先执行到 V (S)，则 S++后 S=1，之后执行到 P (S)时此时 S=1，表示有可用资源，继续执行
- 如果先执行到 P (S)，则由于 S=0，S--后 S=-1，表示没有可用资源并有进程在等待资源，P 操作执行 block，主动请求阻塞。当执行完 V (S)后 S++，S=0，并唤醒等待资源的进程

#### 进程的前驱关系

**本质**：多级同步问题

1. 利用同步关系，对每一对**前驱关系**之间设置一个同步信号量
2. “前操作”之后对相应的同步信号量执行 V 操作
3. “后操作”之前对相应的同步信号量执行 P 操作

![](../../img/Pasted%20image%2020231229103542.png)
![](../../img/Pasted%20image%2020231229103526.png)

**引申**：利用信号量同步来分配多个资源的问题

## 2.3.5 经典同步互斥问题

分析问题：
1. **关系分析**。找出题目中描述的各个进程，分析同步、互斥关系
2. **整理思路**。根据各进程操作流程，确定 P、V 操作大致顺序
3. **设置信号量**。根据题目条件确定信号量初始值
	- 互斥信号量：1/根据资源多少设置
	- 同步信号量：0/根据资源多少设置

### 生产者-消费者问题

一个生产者，一个消费者

![](../../img/Pasted%20image%2020231229105058.png)

#### 第一步：关系分析

**进程同步关系**

- 生产者进程：每次生产一个产品放入缓冲区
	- *缓冲区未满*，才可以写入
	- 否则等待，**需要 PV 操作部分**
- 消费者进程：每次从缓冲区中取出一个产品并使用
	- *缓冲区不空*，才可以读取
	- 否则等待，**需要 PV 操作部分**

**进程互斥关系**

二者共享一个初始为空，大小为 n 的缓冲区，需要各个进程*互斥访问*（互斥关系），即*缓冲区资源为临界资源*
- 生产者同时访问，容易出现同一块缓冲区内容中旧数据被新数据覆盖

#### 第二步：整理思路

**同步关系**：两对同步关系
- 缓冲区未满 -> 生产者生产
- 缓冲区未空 -> 消费者消费
![](../../img/Pasted%20image%2020231229112116.png)

**互斥关系**：
- 对缓冲区的访问

#### 第三步：设置信号量

**互斥信号量**：
- `semaphore mutex = 1; // 缓冲区互斥访问`

**同步信号量**：
- `semaphore empty = n; // 空闲缓冲区数量`
- `semaphore full  = 0; // 产品数量/非空缓冲区数量`

#### 如何实现

```cpp
producer(){
	while(1)
	{
		生产一个产品;
		
		P(empty); // 消耗一个空闲缓冲区资源
		
		P(mutex);
		产品放入缓冲区;
		V(mutex);
		
		V(full); // 增加一个产品资源
	}
}

consumer(){
	while(1){
		P(full); // 消耗一个产品资源（非空缓冲区）
		
		P(mutex);
		从缓冲区取出一个产品;
		V(mutex);
		
		V(empty); // 增加一个空闲缓冲区
		
		使用产品;
	}
}
```

- 互斥操作：*同一个进程中操作*
- 同步操作：*不同进程之间操作*

#### 思考：能否改变相邻 P 操作、V 操作的顺序

![](../../img/Pasted%20image%2020231229111234.png)

- 修改 P 操作顺序
	- 生产者申请缓冲区（1），但此时缓冲区已满导致生产者阻塞（2），切换进程
	- 消费者申请缓冲区（3），但此时缓冲区已经被生产者上锁，导致消费者阻塞（4）
	- 二者都在循环等待对方唤醒，出现**死锁**

- 修改 V 操作顺序，考虑 full=0，empty=n，按照 341 的顺序就会发生死锁
	- 消费者申请缓冲区（3），缓冲区为空导致消费者阻塞（4），切换进程
	- 生产者申请缓冲区（1），缓冲区被消费者上锁导致生产者阻塞（2）
	- 出现**死锁**

综上，**实现互斥的 P 操作一定要在实现同步的 P 操作**之后
- V 操作不会导致进程阻塞，可以交换操作顺序
- `生产产品` 和 `使用产品` 的代码可否放在 PV 操作之间？
	- 可以，但不建议
	- 会造成临界区访问时间过长的问题

### 多生产者-多消费者问题

多个生产者，多个消费者

![](../../img/Pasted%20image%2020231229114846.png)

1. **关系分析**
	- **同步**（一前一后，从*事件*的角度分析）
		- 生产者 1 放入苹果 -> 消费者 1 取走苹果
		- 生产者 2 放入橘子 -> 消费者 2 取走橘子
		- 消费者 1 或 2 取走物品导致*盘子为空* -> 生产者 1 或 2 才可以放入物品
	- **互斥**（mutex=1）
		- 对盘子的访问为互斥
2. **整理思路**
	- 互斥：临界区前后分别 PV
	- 同步：前 V 后 P 
3. **设置信号量**
	- ![](../../img/Pasted%20image%2020231229115232.png)

**代码实现**

```cpp
// 互斥：访问盘子（缓冲区）
semaphore mutex = 1;

// 同步：苹果信息
semaphore apple = 0;
// 同步：橘子信息
semaphore orange = 0;
// 同步：盘子状态
semaphore plate = 1;
```

![](../../img/Pasted%20image%2020231229150758.png)

- 因为本题中 plate 容量为 1，此时代码中是否设置 plate 的互斥都可以
- 如果 plate 容量为 2，则必须要加上互斥

### 吸烟者问题

- 一个生产者：生产三种资源（ABC）
- 缓冲区：一次放一种资源组合（AB、AC、BC）
- 三个消费者：分别有（A、B、C）
	- 从缓冲区取走自己没有的组合
	- 如 A 取走 BC

![](../../img/Pasted%20image%2020231229152312.png)

- **注意**本题要求三个抽烟者轮流抽烟
	- 利用取余操作

![](../../img/Pasted%20image%2020231229152531.png)

- 根据分析，四个信号量同一时刻，最多只有一个为 1

### 读者-写者问题

![](../../img/Pasted%20image%2020231229153749.png)

1. 关系分析
	- 两类进程：写进程、读进程
	- 互斥关系：写-写、写-读。读与读之间不存在互斥
2. 整理思路
	- 根据各进程操作流程确定 PV 操作的大致顺序
3. 设置信号量
	- 设置需要的信号量
	- 根据题目条件确定信号量初值
		- 互斥一般为 1
		- 同步则根据对应的资源初始值多少来设置

**读进程优先**

![](../../img/Pasted%20image%2020231229154419.png)

**写进程优先/先来先服务**

![](../../img/Pasted%20image%2020231229155003.png)

**核心思想**：
- 设置一个*计数器 count* ，记录正在访问共享文件的读进程数
	- 根据 count 判断是否为第一个/最后一个读进程，从而做出不同处理
- 在*读优先*中，对 count 变量的检查和赋值不能一气呵成从而导致了写进程饥饿，如果需要实现一气呵成，要自然想到用*互斥信号量*

### 哲学家进餐问题

![](../../img/Pasted%20image%2020231229161631.png)

**如何解决死锁？**
1. 限制最多允许四个同时进餐，保证至少有一个人是可以拿到两根
2. 要求奇数号拿左边，偶数号拿右边
3. *仅当一个人左右都可以使用时才允许拿*

按照方案三：
```cpp
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1; // 互斥事件：取筷子
Pi(){
	while(1)
	{
		P(mutex); // 申请拿筷子
		P(chopstick[i]);       // 申请拿左
		P(chopstick[(i+1)%5]); // 申请拿右
		V(mutex); // 允许其他人开始拿
		吃饭
		V(chopstick[i]);
		V(chopstick[(i+1)%5]);
		思考
	}
}
```

## 2.3.6 管程

### 为什么引入管程？

- 信号量机制存在的问题：编写程序困难、易出错

1973 年，Brinch Hansen 首次在程序设计语言（Pascal）中引入了“管程”--*一种高级同步机制*

### 管程的定义和基本特征

- 目的：实现进程的同步和互斥
- 因为进程可能共享使用某些有限资源
- **编译器负责实现**

**管程**：特殊的软件模块（和类结构有些类似）
- 局部于管程的*共享数据结构*说明
- 对该数据结构进行操作的*一组过程*
- 对局部于管程的共享数据*设置初始化语句*
- 管程名字

**基本特征**
- *局部于管程的数据只能被局部于管程的过程所访问*（类似于类中的私有成员？）
- 一个进程只有*通过调用管程内的过程才能进入管程内部访问共享数据*
- *每次仅允许一个进程*在管程内执行某个内部过程

![](../../img/Pasted%20image%2020231229164240.png)

![](../../img/Pasted%20image%2020231229164247.png) ![](../../img/Pasted%20image%2020231229164249.png)

![](../../img/Pasted%20image%2020231229164236.png)


