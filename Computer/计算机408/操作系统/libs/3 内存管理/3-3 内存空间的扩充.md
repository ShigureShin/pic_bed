#computer 

---
## 覆盖技术

- 解决“*程序大小超过物理内存总和*”的问题
- 早期的操作系统

**主要思想**：将程序*分成多个段/模块*
- 常用模块常驻内存
- 不常用模块在需要时调入内存

**实现方式**：在内存中分“*固定区*”和若干个“*覆盖区*”
- 前者存放常驻模块，调入后不再调出（除非运行结束）
- 后者存放动态模块

![](../../img/Pasted%20image%2020231230100811.png)

**必须由程序员声明覆盖结构**，操作系统负责自动完成

**缺点**：
- 对用户不透明
- 增加用户编程负担

## 交换技术

**设计思想**：内存空间紧张时，系统将内存中某些进程暂时*换出*外存，把外存中某些已经具备运行条件的进程*换入*内存（进程在内存和磁盘间动态调度）
- 可以参考进程管理的 [2-2 处理机调度](../2%20进程管理/2-2%20处理机调度.md)中的中级调度/内存调度

- **挂起状态/suspend**：暂时换出外存等待的进程状态
	- *就绪挂起*
	- *阻塞挂起*

![](../../img/Pasted%20image%2020231230101259.png)

**思考**：
1. 在外存中什么位置保存换出的进程？
	- 磁盘空间：*文件区*+*对换区*
		- 前者存放文件
		- 后者存放换出的进程（*连续分配方式，IO 速度比文件区快*）
2. 什么时候进行交换？
	- 运行进程较多导致内存资源不够时进行，降低系统负荷则停止换出
	- *缺页*、*缺页率*
3. 应该换出哪些进程？
	- 优先换出阻塞进程
	- 优先级更低的进程+考虑进程在内存中的驻留时间
	- *PCB 信息常驻内存中的系统分区*，不会被换出

## 虚拟存储技术

### 传统存储管理方式的特征、缺点

参考：[3-4 内存空间的分配与回收](3-4%20内存空间的分配与回收.md)
- 连续分配
	- 单一连续分配
	- 固定分区分配
	- 动态分区分配
- 非连续分配
	- 基本分页存储管理
	- 基本分段存储管理
	- 基本段页式存储管理

传统存储管理方式的特征：
- **一次性**：作业必须一次性全部装入内存后才能开始运行
	- 作业很大，不能全部装入，导致大作业无法运行
	- 大量作业要求运行，内存无法容纳所有，只有少量作业运行，降低多道程序并发度
- **驻留性**：作业被装入内存后，会*一直驻留在内存中*，直至作业运行结束
	- 实际上一个时间段只需要访问作业一小部分即可正常运行
	- 内存中有大量的、暂时不使用的数据，浪费内存资源

都可以利用**虚拟存储技术**来解决

### 局部性原理

虚拟存储技术基于**局部性原理**

- **时间局部性**：此时访问到的指令/数据，在不久后很可能再次访问到（如程序中的大量循环结构）
- **空间局部性**：程序访问了某个存储单元，其附近的存储单元也有可能被访问（基于数据/指令在内存中大都连续存放）
- **高速缓存技术**：将频繁访问的数据放到更高速的存储器上

### 虚拟内存的定义和特征

- 基于局部性原理，将程序中很快会用到的部分装入内存，暂时不用的留在外存，此时已经可以正常运行
- 程序执行过程中，访问信息不在主存时，可以由操作系统将外存中的信息调入主存，继续执行程序
- 内存空间不够，操作系统负责将内存中暂不需要的信息换出到外存
此时，用户视角上会发现内存似乎比实际内存大小大得多，这就是**虚拟内存**

虚拟内存的三个主要特征：
- **多次性**：作业时无需一次性全部装入，允许分成多次调入内存
- **对换性**：作业运行时无需常驻内存，允许作业过程中换入换出操作
- **虚拟性**：逻辑上扩充了内存容量

### 如何实现虚拟内存技术

- 采用连续分配方式会不方便实现
所以，虚拟内存的实现建立在**离散分配**的内存管理方式基础上

类比传统的非连续分配存储管理方式，就变成了：
- **请求分页存储管理**
- **请求分段存储管理**
- **请求段页存储管理**

增加功能：
- **请求调页/调段功能**（所需信息在外存，需要调入主存）
- **页面/段置换功能**（虚拟内存空间不够时，换出暂不使用的部分）

#### 请求分页管理方式

基于基本分页存储管理

新增功能：
- **请求调页功能**
- **页面置换功能**

##### 页表机制

**实现请求调页**：
- 需要知道页面是否调入内存（判断是否缺页）
- 未调入则需要知道其外存存放位置（去哪里找）
	- *外存地址*
**实现页面置换**：
- 根据什么指标决定换出哪个页面
	- *记录最近的访问次数*
- 记录页面是否修改，换出时将修改数据保存：*修改位*
	- 未修改的页面不需要写回外存
	- 修改过则将外存旧数据覆盖

![](img/Pasted%20image%2020231230181455.png)

##### 缺页中断机构

为实现请求调页功能引入

- 所需要页面不在主存，则产生**缺页中断**，通过*操作系统的缺页中断处理程序处理中断*
- 将缺页进程阻塞，放入阻塞队列，调页完成再唤醒，放回就绪队列
- 检查内存中是否有空闲块
	- 有，则分配一个空闲块，将缺页面装入，修改页表中相应页表项
	- 无，则通过**置换算法**选择一个淘汰页面
		- 该页面修改过则写回外存

**缺页中断**：当前执行指令想要访问目标页面，而目标页面未导入主存产生的，属于*内中断*
- 复习中断部分：[1-6 中断和异常](../1%20操作系统概述/1-6%20中断和异常.md)
- *一条指令在执行期间，可能产生多次中断*
	- 如：copy A to B，AB 都不在主存则两次缺页中断

##### 地址变换机构

和基本分页存储管理的区别：
- 操作系统负责将缺页信息调入主存
- 操作系统负责页面置换

因此需要在原来的地址变换基础上，增加如下步骤：
- **请求调页**
	- 通过页表项确认是否缺页
	- 缺页调入时会同样加入快表
	- 注意，缺页的中断处理，要保留 CPU 现场
- **页面置换**
	- 没有空闲内存块时
	- 换入换出需要启动慢速 IO 操作，太频繁的置换开销会很大
	- 调入内存后修改慢表，同时复制一份到快表
- **修改请求页表中新增的表项**
	- 注意快表中信息同样需要更新（快表中有的页面一定在内存中）

![](img/Pasted%20image%2020231230184728.png)
![](img/Pasted%20image%2020231230185049.png)

#### 页面置换算法

[3.2\_3\_页面置换算法\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1YE411D7nH?t=1.1&p=55)
