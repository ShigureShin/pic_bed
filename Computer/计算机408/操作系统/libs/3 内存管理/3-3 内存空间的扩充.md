#computer 

---
# 覆盖技术

- 解决“*程序大小超过物理内存总和*”的问题
- 早期的操作系统

**主要思想**：将程序*分成多个段/模块*
- 常用模块常驻内存
- 不常用模块在需要时调入内存

**实现方式**：在内存中分“*固定区*”和若干个“*覆盖区*”
- 前者存放常驻模块，调入后不再调出（除非运行结束）
- 后者存放动态模块

![](../../img/Pasted%20image%2020231230100811.png)

**必须由程序员声明覆盖结构**，操作系统负责自动完成

**缺点**：
- 对用户不透明
- 增加用户编程负担

---
# 交换技术

**设计思想**：内存空间紧张时，系统将内存中某些进程暂时*换出*外存，把外存中某些已经具备运行条件的进程*换入*内存（进程在内存和磁盘间动态调度）
- 可以参考进程管理的 [2-2 处理机调度](../2%20进程管理/2-2%20处理机调度.md)中的中级调度/内存调度

- **挂起状态/suspend**：暂时换出外存等待的进程状态
	- *就绪挂起*
	- *阻塞挂起*

![](../../img/Pasted%20image%2020231230101259.png)

**思考**：
1. 在外存中什么位置保存换出的进程？
	- 磁盘空间：*文件区*+*对换区*
		- 前者存放文件
		- 后者存放换出的进程（*连续分配方式，IO 速度比文件区快*）
2. 什么时候进行交换？
	- 运行进程较多导致内存资源不够时进行，降低系统负荷则停止换出
	- *缺页*、*缺页率*
3. 应该换出哪些进程？
	- 优先换出阻塞进程
	- 优先级更低的进程+考虑进程在内存中的驻留时间
	- *PCB 信息常驻内存中的系统分区*，不会被换出

---
# 虚拟存储技术

## 传统存储管理方式的特征、缺点

参考：[3-4 内存空间的分配与回收](3-4%20内存空间的分配与回收.md)
- 连续分配
	- 单一连续分配
	- 固定分区分配
	- 动态分区分配
- 非连续分配
	- 基本分页存储管理
	- 基本分段存储管理
	- 基本段页式存储管理

传统存储管理方式的特征：
- **一次性**：作业必须一次性全部装入内存后才能开始运行
	- 作业很大，不能全部装入，导致大作业无法运行
	- 大量作业要求运行，内存无法容纳所有，只有少量作业运行，降低多道程序并发度
- **驻留性**：作业被装入内存后，会*一直驻留在内存中*，直至作业运行结束
	- 实际上一个时间段只需要访问作业一小部分即可正常运行
	- 内存中有大量的、暂时不使用的数据，浪费内存资源

都可以利用**虚拟存储技术**来解决

## 局部性原理

虚拟存储技术基于**局部性原理**

- **时间局部性**：此时访问到的指令/数据，在不久后很可能再次访问到（如程序中的大量循环结构）
- **空间局部性**：程序访问了某个存储单元，其附近的存储单元也有可能被访问（基于数据/指令在内存中大都连续存放）
- **高速缓存技术**：将频繁访问的数据放到更高速的存储器上

## 虚拟内存的定义和特征

- 基于局部性原理，将程序中很快会用到的部分装入内存，暂时不用的留在外存，此时已经可以正常运行
- 程序执行过程中，访问信息不在主存时，可以由操作系统将外存中的信息调入主存，继续执行程序
- 内存空间不够，操作系统负责将内存中暂不需要的信息换出到外存
此时，用户视角上会发现内存似乎比实际内存大小大得多，这就是**虚拟内存**

虚拟内存的三个主要特征：
- **多次性**：作业时无需一次性全部装入，允许分成多次调入内存
- **对换性**：作业运行时无需常驻内存，允许作业过程中换入换出操作
- **虚拟性**：逻辑上扩充了内存容量

---
# 如何实现虚拟内存技术

- 采用连续分配方式会不方便实现
所以，虚拟内存的实现建立在**离散分配**的内存管理方式基础上

类比传统的非连续分配存储管理方式，就变成了：
- **请求分页存储管理**
- **请求分段存储管理**
- **请求段页存储管理**

增加功能：
- **请求调页/调段功能**（所需信息在外存，需要调入主存）
- **页面/段置换功能**（虚拟内存空间不够时，换出暂不使用的部分）

## 请求分页管理方式

基于基本分页存储管理

新增功能：
- **请求调页功能**
- **页面置换功能**

### 页表机制

**实现请求调页**：
- 需要知道页面是否调入内存（判断是否缺页）
- 未调入则需要知道其外存存放位置（去哪里找）
	- *外存地址*
**实现页面置换**：
- 根据什么指标决定换出哪个页面
	- *记录最近的访问次数*
- 记录页面是否修改，换出时将修改数据保存：*修改位*
	- 未修改的页面不需要写回外存
	- 修改过则将外存旧数据覆盖

![](../../img/Pasted%20image%2020231230181455.png)

### 缺页中断机构

为实现请求调页功能引入

- 所需要页面不在主存，则产生**缺页中断**，通过*操作系统的缺页中断处理程序处理中断*
- 将缺页进程阻塞，放入阻塞队列，调页完成再唤醒，放回就绪队列
- 检查内存中是否有空闲块
	- 有，则分配一个空闲块，将缺页面装入，修改页表中相应页表项
	- 无，则通过**置换算法**选择一个淘汰页面
		- 该页面修改过则写回外存

**缺页中断**：当前执行指令想要访问目标页面，而目标页面未导入主存产生的，属于*内中断*
- 复习中断部分：[1-6 中断和异常](../1%20操作系统概述/1-6%20中断和异常.md)
- *一条指令在执行期间，可能产生多次中断*
	- 如：copy A to B，AB 都不在主存则两次缺页中断

### 地址变换机构

和基本分页存储管理的区别：
- 操作系统负责将缺页信息调入主存
- 操作系统负责页面置换

因此需要在原来的地址变换基础上，增加如下步骤：
- **请求调页**
	- 通过页表项确认是否缺页
	- 缺页调入时会同样加入快表
	- 注意，缺页的中断处理，要保留 CPU 现场
- **页面置换**
	- 没有空闲内存块时
	- 换入换出需要启动慢速 IO 操作，太频繁的置换开销会很大
	- 调入内存后修改慢表，同时复制一份到快表
- **修改请求页表中新增的表项**
	- 注意快表中信息同样需要更新（快表中有的页面一定在内存中）

![](../../img/Pasted%20image%2020231230184728.png)
![](../../img/Pasted%20image%2020231230185049.png)

## 页面置换算法

内存空间不够时，操作系统将内存中暂不用的信息换出到外存
- *页面置换算法决定置换哪个页面*
同时页面换入换出需要磁盘 IO 操作，从而导致开销大，所以好的页面置换算法应该*追求更少的缺页率*

算法分类：
- 最佳置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用置换算法（LRU）
- 时钟置换算法（CLOCK）
- 改进型的时钟置换算法

### 最佳置换算法（OPT）
- 每次淘汰页面都是那些*以后永远不适用*，或者*最长时间内不再被访问的页面*，保证最低的缺页率

![](../../img/Pasted%20image%2020231231105852.png)
**缺页不一定引发页面置换**
- 页面置换只发生在内存中没有空闲内存块的情况下
上图中缺页率=缺页次数/访问页面次数
- 9/20=45%
**前提：需要提前知道页面访问序列**
- 实际上该算法无法实现（理想化的）

### 先进先出置换算法（FIFO）
- 每次*淘汰页面*是*最早进入内存的页面*

**实现方法**：调入内存的页面按照调入先后顺序排序，页面置换时直接将队头页面换出，*队列最大长度取决于系统为进程分配了多少个内存块*

**Belady 异常**：为进程分配的物理内存块数增大时，缺页次数不降反增的异常现象

**只有 FIFO 算法会出现 Belady 异常**
- 实现简单
- 但性能差

### 最近最久未使用置换算法（LRU）
- Least Recently Used：每次淘汰页面是最久未使用的页面

**实现方法**：在每个页面的页表项中，用*访问字段记录页面上被访问以来所经历的时间 t*，淘汰时选择 t 最大的页面

![](../../img/Pasted%20image%2020231231110701.png)

- 手动做题技巧：从淘汰页面位置开始逆向检查在内存中的几个页面号，*最后一个出现的页号就是要淘汰的页面*

**优点**：
- 算法性能好
**缺点**：
- 需要专门硬件支持
- 实现困难，开销大

### 时钟置换算法（CLOCK）
- 性能和开销均衡，
- *最近未用算法，NRU，Not Recently Used*

**实现方法（简单版）**：给页面设置一个*访问位*
- 将内存中的页面通过链接指针链接成一个循环队列
- 某页被访问时，访问位置置为 1
- 需要淘汰页面时，检查页的访问位
	- 0 则换出
	- 1 则置 0，检查下一个页面
- 如果第一次扫描后全是 1，则此时已经全部置 0，再进行第二次扫描即可找到置换页面
*最多经过两轮扫描*
![](../../img/Pasted%20image%2020231231112157.png)


对要淘汰的页面进行分析，除了考虑最近有没有被访问，还要考虑页面是否被修改：
- 如果该页面被修改过，*需要 IO 操作写回外存*
- 如果没有被修改过，*不需要 IO 操作写回外存*
**实现方法（改进版）** ：增加*修改位*（0，未修改；1，修改过），记（访问位，修改位）
- 第一轮：从当前位置开始扫描。
	- 找到第一个（0，0）帧替换，不修改标志位
	- 最近未访问、最近未修改
- 第二轮：第一轮扫描失败，重新扫描。
	- 查找第一个（0，1）帧替换，并将扫描过的访问位置 0
	- 最近未访问、最近修改
- 第三轮：第二轮扫描失败，重新扫描。
	- 找到第一个（0，0）帧替换，不修改标志位
	- 最近访问、最近未修改
- 第四轮：第三轮扫描失败，重新扫描。
	- 找到第一个（0，1）帧替换
	- 最近访问、最近修改
**最多四轮扫描**
- 不同扫描轮次，都在寻找访问过和修改过优先级最低的页面

## 页面分配策略

### 页面分配、置换策略

**驻留集**：请求分页存储管理中给进程分配的物理块的集合
- 虚拟存储技术的系统中，驻留集 size 一般小于进程的总 size 
- 太小：缺页频繁
- 太大：并发度下降

根据驻留集大小是否可变设置两种分配策略：
- **固定分配**：操作系统给每个进程分配一组固定数目的物理块，进程运行期间大小不变
- **可变分配**：OS 给每个进程分配一定数目的物理块，进程运行期间动态增加或减少

对于置换阶段，可以根据使用哪里的物理块进行置换分为：
- **局部置换**：发生缺页时，进程*使用自己的物理块*进行置换
- **全局置换**：将操作系统保留的空闲物理块分配给缺页进程，或将其他进程持有的物理块置换到外存再分配给缺页进程
	- 全局置换会改变进程被分配的物理块

综上能够得到的分配置换结果为：

|  | 局部置换 | 全局置换 |
| ---- | ---- | ---- |
| 固定分配 | √（难以确定开始时分配多少） | × |
| 可变分配 | √（根据进程运行中缺页率大小动态调整物理块分配） | √（可能使被置换的进程缺页率增加） |
- 固定分配中，进程得到的物理块大小已经确定，只能使用自己的物理块

- 可变分配*全局置换*：缺页就分配新物理块
- 可变分配*局部置换*：根据*缺页频率*动态增加/减少进程的物理块

### 何时调入页面

1. 进程运行前

进程在缺页时需要调入所需要的页面，如果一次性调入一个页面，根据局部性原理，当前页面相邻的页面也有可能在不久之后被进程访问。

所以如果能够提前将这些页面同样调入会比单次调入一个页面更为高效。即：
- **预调页策略**
- *主要是进程的首次调入*，由程序员指出先调入哪部分

2. **请求调页策略**：进程运行期间发现缺页而申请调入内存
	- 每次调入一个页面
	- 涉及到 IO 操作，开销大

### 从何处调入

外存：
- **对换区**（读写速度更快，连续分配方式）
- 文件区

1. 对换区大小足够
	- *调入调出*都发生在*对换区和内存之间*
	- 进程运行前，将进程数据从文件区复制到对换区
2. 对换区大小不足
	- *从文件区调入*，对于调回需要考虑是否修改
	- 对于只读数据，直接从文件区调入
		- 因为不会修改，所以不需要写回外存
	- 对于可能被修改的数据，换出时写回对换区，下次需要时直接从对换区调入
3. UNIX 方式：运行前，进程全部数据在文件区
	- 未使用的页面：直接从文件区调入
	- 使用过的页面：换出时写回对换区

### 抖动（颠簸）现象

**现象描述**：
- 刚刚换出的页面马上又要换入到内存
- 刚刚换入的页面马上又要换出到外存

导致系统开销大，真正执行进程的有效操作很少

**产生原因**：
- 进程频繁访问的页面数据高于可用的物理块数
- 即，*分配给进程的物理块太少*

**需要研究应该给进程分配多少物理块**
- 工作集

### 工作集

和驻留集之间进行区分：
- 驻留集：请求分页存储管理中，给进程分配的内存块的集合
- **工作集**：某段时间间隔里，进程*实际访问*页面的集合
	- 根据“窗口尺寸”计算工作集，参照下图进行理解
	- 当前访问页面开始，往前一共四个页面大小
	- ![](../../img/Pasted%20image%2020231231170839.png)

*工作集大小可能小于窗口尺寸*
- 工作集表示进程实际访问页面多少，可以根据此来判断需要给进程分配多少个物理块（*驻留集大小*）即可满足其大部分运行需要
- *驻留集大小不能小于工作集大小*，否则进程运行中将频繁缺页

回想前边的页面置换算法中的*局部置换策略*，结合工作集的内容，可以知道：
- 在进程物理块中进行置换时，可以选择一个*不在工作集中的页面*进行淘汰

## 内存映射文件

内存映射文件，Memory-Mapped Files
- 方便程序员访问文件数据
- 方便多个进程共享同一个文件数据

将要访问的文件数据，从磁盘中存储的多个块，映射到进程的虚拟地址空间中（*没有直接将文件数据读取到内存，仅仅是地址映射，即此时是缺页的状态*）
- 可以通过访问内存的方式访问文件数据
- 当想要访问某一页面时，触发缺页异常，操作系统就会执行页面调入
- 进程关闭文件时系统自动将脏页面写回磁盘

在实现多个进程共享同一个文件数据时，
- 每个进程内部存在一片对目标文件数据的映射地址
- 而这些进程内部的这片映射地址中，相同的页面部分映射到内存中相同的物理页框，如下图![](../../img/Pasted%20image%2020231231173947.png)


