#computer 
- 连续分配方式
	- 单一连续分配
	- 固定分区分配
	- 动态分区分配
- 非连续分配方式
	- 基本分页存储
	- 基本分段存储
	- 段页式存储
---
**连续分配**：系统为用户进程分配的必须是一个*连续的内存空间*
- 非连续分配不一定是连续

- **内部碎片**：分配给某进程的内存区域中，有部分没有用上
- **外部碎片**：内存中某些空闲分区由于太小而难以利用

可以通过*紧凑/拼凑 Compaction*技术来解决外部碎片

# 连续分配方式

## 单一连续分配

内存：*系统区* + *用户区*
- 只能有*一道用户程序*，独占整个用户区

**优点**：
- 实现简单
- *无外部碎片*
- 可以采用覆盖技术扩充内存
- 不一定需要内存保护
**缺点**：
- 只能用于单用户、单任务的操作系统
- *有内部碎片*：分配给进程的内存区域有部分没有用上
- 存储器利用率低

## 固定分区分配

将用户区划分成若干固定大小的分区，每个分区装入一道作业
- 最早的、最简单的一种运行多道程序的内存管理方式
![](../../img/Pasted%20image%2020231230102850.png)
- **分区大小相等**
	- 缺乏灵活性，但适合用于一台计算机控制*多个相同对象*的场合
- **分区大小不等**
	- 增加灵活性，满足不同大小的进程需求
	- 根据常在系统中运行的作业大小情况进行分区

如何记录内存中分区情况？
- **分区说明表**
- 实现各个分区的分配与回收
- 包含：分区号、分区大小、起始地址、状态（是否分配）

**优点**
- 实现简单
- 无外部碎片
**缺点**
- 用户程序太大时，可能所有分区都不满足，需要采用覆盖技术解决，但会降低性能
- 会产生内部碎片，内存利用率低（小进程被分配了大内存分区）

## 动态分区分配

**可变分区分配**，不预先划分，而是*进程装入内存时，根据进程大小动态建立分区*，使得分区大小正好适合进程需要
- 分区大小和数目可变

结合*动态重定位*方式装入内存

**问题**：
- 系统用什么样的数据结构记录内存的使用情况？
- 当多个空闲分区都满足进程需求时，如何选择分区进行分配？
- 如何进行分区的分配与回收操作？

### 记录内存使用情况

- **空闲分区表**
- **空闲分区链**

![](../../img/Pasted%20image%2020231230103549.png)

### 分区的分配与回收

回收时，相邻的空闲分区进行合并

### 选择空闲分区：动态分区分配算法

**目的**：解决多个空闲分区都满足进程需求时，选择哪个分区的问题

#### 首次适应算法（First Fit）

**算法思想**：从低地址开始查找，找到第一个能满足大小的分区
**如何实现**：*空闲分区按照地址递增顺序排列*，分配时进行查表/链，找到第一个满足的

**综合性能最好**，算法开销小，不需要重新对分区队列排序

#### 最佳适应算法（Best Fit）

**算法思想**：动态分区分配是一种连续分配方式，为了保证“大进程”到来时能有连续的大片空间，则优先使用更小的空闲区
**如何实现**：空闲分区按照*容量递增*次序链接，找到大小第一个满足的（分配后对链表重新排序）

**缺点**：
- 容易留下很多很小的、难以利用的内存块，*外部碎片*会很多
- 算法开销大

#### 最坏适应算法（Worst Fit）

**算法思想**：方式最佳适应算法中出现过多小碎片，则优先选择最大的连续空闲区，从而保证剩余空闲区不会太小
**如何实现**：按照*容量递减*顺序，找到第一个（第一个都不满足其他的都不可能了）（分配后对链表重新排序）

**缺点**：
- 容易导致“大进程”没有可以使用的大连续分区
- 算法开销大

#### 邻近适应算法（Next Fit）

**算法思想**：解决首次适应算法中每次从头开始查找，使得部分分区被反复查找。本算法目的，从上次查找结束的位置开始检索
**如何实现**：*地址递增*（此时可以做成一个循环链表），每次都从上次结束位置开始查找，找到大小满足的第一个空闲分区（*不需要额外对分配后的链表进行重新排序*）

**缺点**：
- 低地址、高地址分区以同等概率被利用，导致高地址部分的大分区更可能被使用，从而导致没有大分区可用

---
# 非连续分配方式

**非连续分配**：为用户进程分配的是一些*分散的内存空间*

## 基本分页存储管理

### （单级）页表

- 内存的地址空间：
	- **页框**：内存空间分成的*大小相等*的*分区*
		- 页框、页帧、内存块、物理块、物理页面
	- **页框号**：每个页框的编号，从 0 开始
		- 页框号、页帧号、内存块号、物理块号、物理页号
- 进程的地址空间：
	- **页/页面**：*进程的逻辑地址空间*也分为页框大小的一个个部分
	- **页号**：页/页面的编号，从 0 开始

操作系统*以页框为单位*为各个进程分配内存空间
- 进程的每个页面放入一个页框，*二者一一对应*
- *页面不需要连续存放，可放到不相邻的页框中*

#### 页表

- 记录*进程页面*和*内存页框*的映射关系的数据结构
- 每个进程建立一张*页表*，记录在 PCB（进程控制块） 中
- 进程每个页面对应一个页表项：页号+块号（内存号）

#### 问题一：每个页表项占多少字节？

![](../../img/Pasted%20image%2020231230111527.png)

只需要计算块号存储大小，不需要记录页号，因为页号是隐含的，不占存储空间（类比数组）
- 页表项连续存放，同时知道每个页表项中存储每个块号的大小
- 每个页表项占 3 B，则存储整个页表至少需要 $3*(n+1)$B
- **注意**，页表只记录内存块号，而不是起始地址
- $j 号内存块的起始地址 = j*内存块大小$

- **逻辑上**，页表项 = 页号 + 块号
- **物理上**，页表项 = （页号+）块号

#### 问题二：页表实现逻辑地址到物理地址的转换

**特点**：进程的*各页面在内存中离散存放*，但*页面内部是连续的*

如果要访问逻辑地址 A，则有：
- 确定逻辑地址 A 对应的“**页号**”P
- 确定逻辑地址 A 的“**页内偏移量**”W
- 找到 P 号页面在内存中的起始地址（查页表，在问题一中已经解决）
逻辑地址 A 对应的物理地址 = P 号页面在内存中的起始地址 + 页内偏移量 W 

![](../../img/Pasted%20image%2020231230112737.png)

![](../../img/Pasted%20image%2020231230112940.png)

#### 逻辑地址结构

![](../../img/Pasted%20image%2020231230113450.png)

- 页号：一个进程能分成几个页面
- 页内偏移量：进程的一个页面内部从 0 到页面大小

### 基本地址变换机构

- 用于实现逻辑地址到物理地址转化的一组硬件机构

**页表寄存器 PTR**：存放页表在内存中的起始地址 F 和页表长度 M 
- 进程未执行，页表始址和页表长度存在 PCB
- 进程被调度，则放到 PTR 中
注：页面大小为 2 的整数幂
- 页号 P>= 页表长度 M，则发生越界中断（*注意这里是有等于的*）
- **页表长度**：页表中有几个页表项
- **页表项长度**：每个页表项占多少存储空间
- **页面大小**：一个页面占多大的存储空间

#### 地址变换过程

![](../../img/Pasted%20image%2020231230115753.png)
两次访存：
- 第一次，查页表
- 第二次，访问目标内存单元

只要确定了每个页面的大小，逻辑地址结构就确定了
- **页式管理中地址是一维的**
#### 对页表项大小的进一步探讨

![](../../img/Pasted%20image%2020231230152642.png)
页表项也是需要存放在内存中，且是*按顺序连续存放*
- 那么，按照上图中，一个页表项为 3 B，一个页面为 4 KB，则一个页面中能够存放页表项为 1365 个（0 号~1364 号），同时该页面实际上会剩余 1 B 的存储空间，导致 1365 号页表项只能间隔 1 B 再存放，*产生了页内碎片*
所以，为了方便页表的查询，常常会让页表项占更多的字节，**使得每个页面恰好可用装得下整数个页表项**（实际中采用的方式）

### 具有快表的地址变换机构

*基本地址变换机构的改进*
- 加速地址变换过程

#### 快表 TLB

- 可以结合计算机组成原理的笔记中 [3.5 高速缓冲存储器](../../../计算机组成原理/libs/3.5%20高速缓冲存储器.md) 一节加深理解

**快表**
- 是什么？
	- *硬件设备*
	- 联想寄存器（TLB, translation lookaside buffer），*访问速度比内存快*很多的*高速缓存 Cache*（不是内存！）
- 做什么？
	- 存放*最近访问的页表项的副本*
	- 加快地址变换速度
- 对应的概念：**慢表**，即内存中的页表
- **TLB 是专门存储页表项副本的 Cache，**而普通 Cache 则可能会有其他各种数据的副本

#### 基于快表的地址变换过程

- 当进程切换时，*快表内容也会被清除*

![](../../img/Pasted%20image%2020231230154819.png)

注：
- 经过快表，需要一次访存
- 经过慢表，需要两次访存
- 快表已满，需要按照*一定的算法*对旧的页表项进行替换

![](../../img/Pasted%20image%2020231230155623.png)
- 注意题目中，*访问一个逻辑地址*
- 所以经过快表后会进行访存，需要在计算时加上快表访存的时间消耗

- 注意快表慢表的查询方式
	- 先快表，未命中再慢表
	- 还是快慢同时查询
	- 结合下方甘特图更容易理解
![](../../img/Pasted%20image%2020231230160033.png)

#### 局部性原理

- **时间局部性**
- **空间局部性**

### 两级页表

**单级页表存在的问题**：
- 问题一：页表项需要连续存放，需要占用很多个连续的页框
- 问题二：根据局部性原理，进程并不需要把所有页表都常驻存放在内存中，只需要几个关键页表项就可以正常运行

![](../../img/Pasted%20image%2020231230163732.png)

**问题一的解决方案**：****
- 根据页面大小对页表项进行分组打包
- 建立页表的页表
- 页目录表/外层页表/顶层页表
**问题二的解决方案**：
- 在需要访问页面时才把页面调入内存（*虚拟存储技术*）
- 页表项中增加设置一个标志位表示是否调入内存
	- 不在内存，则*缺页中断/内中断*
	- 再将目标页面从外存调入内存

**注意细节**：
1. 采用多级页表基址，则*各级页表大小不能超过一个页面*![](../../img/Pasted%20image%2020231230163954.png)
2. 两级页表的*访存次数分析*（不考虑快表时）
	- 第一次：访问内存的页目录表
	- 第二次：访问内存的二级页表
	- 第三次：访问目标内存单元

## 基本分段存储管理方式

- 和**分页存储**最大的区别是：离散分配时所分配的地址空间的基本单位不同

### 分段

进程的地址空间：按照程序*自身的逻辑*关系划分若干个段，每个段有一个段名（低级语言中，例如 main 函数，子函数，全局变量等），每段从 0 开始
- 用户编程更方便，程序可读性高

分段系统的逻辑地址：段号（段名）+段内地址（段内偏移量）
- **段号**：位数决定每个进程最多分几个段
- **段内地址**：位数决定每个段最大长度是多少

### 段表

程序分为多个段，各段离散存入主存。为正常运行，依靠**段表**从物理内存中找到各逻辑段存放位置

段表：段号+段长+基址（段在内存的起始地址）
- 各*段表项*的长度相同

### 地址变换

![](../../img/Pasted%20image%2020231230170650.png)

- 和页表的地址变脸中的区别是
	- 页表不需要对页内地址进行越界中断检查，因为每个页面大小都是相同的
	- *段表需要对段内地址进行越界中断检查*

## 分段、分页管理的对比

![](../../img/Pasted%20image%2020231230171214.png)

- **页**是*信息的物理单位*
	- 分页目的：实现离散分配，提高内存利用率
	- 分页：系统管理的需要，系统行为，*对用户不可见*
	- 系统决定页的固定大小
	- *地址空间为一维*，只需要*一个标记符*表示一个地址
- **段**是*信息的逻辑单位*
	- 分段的目的：满足用户需求，一个段包含一组属于同一个逻辑模块的信息
	- 分段：*对用户可见*，用户编程时显式给出段名
	- 段的长度取决于用户编写的程序
	- *地址空间为二维*，表示一个地址，显式给出*段名+段内地址*
	- **更容易实现信息的共享和保护**，不能被修改的代码称为*纯代码*或*可重入代码*（不属于临界资源），可以共享。*可修改代码不可共享*
	- 访存次数：两次访存
		- 可以引入**快表机构**减少访存次数

![](../../img/Pasted%20image%2020231230171346.png)

**为什么分页式不适合信息的共享？**
![](../../img/Pasted%20image%2020231230171444.png)

## 段页式管理方式

- 分页和分段管理的结合
- 仍然为二维地址

### 分页、分段的优缺点分析

| 管理方式 | 优点 | 缺点 |
| ---- | ---- | ---- |
| 分页管理 | 内存空间利用率高，不会产生外部碎片，只有少量内部碎片 | 不方便按照逻辑模块实现信息的共享和保护 |
| 分段管理 | 按照逻辑模块实现信息的共享和保护 | 段长过大，分配很大的连续空间不方便，会产生外部碎片 |

### 分段+分页 = 段页式管理

![](../../img/Pasted%20image%2020231230172620.png)

### 段表、页表

![](../../img/Pasted%20image%2020231230172819.png)
- 一个进程对应一个段表
- 但对应*多个页表*

### 实现地址转换

![](../../img/Pasted%20image%2020231230174237.png)


