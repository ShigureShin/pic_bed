#computer

---
# 括号匹配问题

- 左右括号的匹配
- 大小括号的匹配

![](../../img/Pasted%20image%2020231211171150.png)

栈的特定：后进先出LIFO

- 从左往右依次将*左括号*压入栈中
- 碰到右括号则弹出一个左括号进行匹配（即出现一个右括号，消耗掉一个左括号）
- 继续扫描
- 如果能够全部匹配最后栈一定是空的

**需要考虑清楚最后不匹配的情况**
- 弹出的左括号与右括号不匹配
- 栈空但是还有右括号没有匹配完毕
- 栈未空但是没有右括号

![](../../img/Pasted%20image%2020231211171805.png)

![](../../img/Pasted%20image%2020231211172112.png)

- 尝试不使用基本操作动手实现
- 直接使用top指针等

# 表达式求值

- 算术表达式，三部分组成：**操作数、运算符、界限符**
	- 中缀表达式
	- **后缀表达式**
	- 前缀表达式
- **后缀表达式** 逆波兰表达式 Reverse Polish notation
	- *中缀*表达式转*后缀*表达式
	- 后缀表达式求值
- 前缀表达式 Polish notation
	- *中缀*表达式转*前缀*表达式
	- 前缀表达式求值

![](../../img/Pasted%20image%2020231212160743.png)


## 中缀表达式转后缀表达式（手算）

![](../../img/Pasted%20image%2020231212161143.png)

- 客观来看二者都正确，但是“机算”的结果是前者
	- 因为算法需要有确定性，即输出唯一
- **左优先原则**：只要左边的运算符能先计算，就优先计算左边的

![](../../img/Pasted%20image%2020231212161355.png)


## 后缀表达式的计算（手算）

![](../../img/Pasted%20image%2020231212161535.png)

- 特点：最后出现的操作数最先被计算
- **后进先出，使用栈**

## 用栈实现后缀表达式计算

这里的栈用于存放暂时还不能确定运算顺序的*操作数*

- 从左往右扫描下一个元素，直至处理完所有元素
- 若扫描到操作数则压入栈，并回到上一步；否则执行下一步
- 若扫描到运算符，则弹出两个栈顶元素，执行相应计算，结果压回栈顶，回到第一步
	- 注意：先出栈的是右操作数
- 表达式合法的话，栈中只会留下一个元素，就是最终结果

- 例题：![](../../img/Pasted%20image%2020231212162424.png)

## 中缀表达式转为前缀表达式（手算）

![](../../img/Pasted%20image%2020231212162811.png)

## 栈实现前缀表达式
![](../../img/Pasted%20image%2020231212162911.png)

- 注意：前缀表达式中先出栈的是*左操作数*

## 中缀表达式转后缀表达式（机算）

- 存放暂时还不能确定运算顺序的*运算符*

![](../../img/Pasted%20image%2020231212165353.png)

- 操作数相对顺序不会改变
- ![](../../img/Pasted%20image%2020231212170026.png)

## 中缀表达式的计算（栈实现）
- 中缀转后缀
- 后缀表达式求值

![](../../img/Pasted%20image%2020231212170332.png)

![](../../img/Pasted%20image%2020231212170415.png)

![](../../img/Pasted%20image%2020231212182331.png)

# 递归应用

函数递归调用的特点：最后被调用的函数是最先被执行的（LIFO）

- *函数调用栈*保存递归调用的函数的信息，具体需要保存的信息有
	- 调用返回地址
	- 实参
	- 局部变量

- 递归算法：原始问题转换为属性相同，但规模较小的问题
- 两个关键：
	- 递归表达式（递归体）
	- 边界条件（递归出口）

![](../../img/Pasted%20image%2020231212193458.png)

- 缺点：
	- 递归太多容易导致栈溢出
		- 对应思考空间复杂度
	- 可能包含很多次重复运算



