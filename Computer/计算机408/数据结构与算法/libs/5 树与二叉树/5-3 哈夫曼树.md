#computer 

---

![](../../img/Pasted%20image%2020231227165344.png)

# 带权路径长度

![](../../img/Pasted%20image%2020231227171133.png)

# 哈夫曼树的定义

![](../../img/Pasted%20image%2020231227171339.png)

在含有 n 个带权叶结点二叉树中，其中带权路径长度（WPL）最小的二叉树称为**哈夫曼树**，也称**最优二叉树** 

# 哈夫曼树的构造

![](../../img/Pasted%20image%2020231227171507.png)

结点总数的计算：
- 初始有 n 个结点
- 两两合并后，增加了 n-1 个结点
- 所以一共是 2n-1 个结点

另一种哈夫曼树，但 WPL 相同

![](../../img/Pasted%20image%2020231227171648.png)

# 哈夫曼编码

![](../../img/Pasted%20image%2020231227171828.png)

那么有没有一种方式使得构造出来的树的 WPL 尽可能少？

根据哈夫曼树的构造，![](../../img/Pasted%20image%2020231227171946.png)

注意这里的不同字符对应的编码长度不相同，**可变长度编码**

*只能作为叶子节点，不能当作分支节点*
![](../../img/Pasted%20image%2020231227172111.png)

- **前缀编码**：没有一个编码是另一个编码的前缀
	- 例如上图中左侧编码，其中的前缀码解码无歧义
	- 右侧为非前缀编码，解码时会有歧义

**哈夫曼编码**：根据哈夫曼树得到的编码。字符集中的每个字符作为一个叶子节点，每个字符出现的频次作为结点的权值，从而构造哈夫曼树

![](../../img/Pasted%20image%2020231227172510.png)

**哈夫曼编码可以用于数据的压缩**



