#computer #csapp

---
计算机系统是由**硬件**和**系统软件**组成的

```c
#include <stdio.h>
int main()
{
	printf("hello, world\n");
	return 0;
}
```

- 思考一个 `hello.c` 程序的生命周期

## 1.1 信息就是位+上下文

- `hello.c` 程序以*字节序列*的方式储存在文件中
- 只由 ASCII 字符构成的文件为**文本文件**，其他所有文件都称为**二进制文件**

一个思想：系统中所有的信息（磁盘文件、内存中的程序等等）都是*一串比特*表示的。**区分不同数据对象**的唯一方法是读到这些数据对象时的**上下文**。

## 1.2 程序被其他程序翻译成不同的格式

hello 程序的声明周期开始于一个高级 C 语言程序

系统上要运行 `hello.c` 程序，需要被其他程序转化为*一系列*的低级机器语言指令。然后这些指令按照一种可*执行目标程序的格式*（可执行目标文件）打包，以二进制磁盘文件的形式存放起来。

- GCC 编译器驱动对源程序文件 `hello.c` 进行读取并翻译，翻译过程分为四个阶段
	- **预处理器**（cpp）：`hello.c` 源程序（文本） -> `hello.i`，修改了的源程序（文本）
		- 以字符 `#` 开头的命令修改源程序：读取头文件 `stdio.h` 内容直接插入程序文本
	- **编译器**（ccl）：`hello.i` -> `hello.s` 汇编程序（文本）
		- 以文本格式描述的*低级机器语言指令*
		- 汇编语言为不同的高级语言的不同编译器提供了通用的输出语言
	- **汇编器**（as）：`hello.s` -> `hello.s` 可重定位目标程序（二进制）
		- 翻译成机器语言指令，并将指令打包为*可重定位目标程序*（relocatable object program）的格式，保存在目标文件中
	- **链接器**（ld）：`hello.s` + `printf.o` -> `hello` 可执行目标程序（二进制）
		- 将包含 `printf` 函数的已经预编译过的目标文件合并到 `hallo.o` 程序中
- 这四个阶段的程序共同构成**编译系统**（cmpilation system）

![](img/Pasted%20image%2020231210093826.png)

## 1.3 了解编译系统是如何工作的大有益处

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞

## 1.4 处理器读并解释存储在内存中的指令

在 shell 中运行 hello 程序：
```shell
linux> ./hello
hello, world
linux>
```

- shell 命令行解释器：输出一个提示符，等待输入一个命令行，然后执行这个命令
	- 命令行的第一个单词不是内置的 shell 命令，则会假设是一个可执行文件的名字，会加载并运行这个文件

### 1.4.1 系统的硬件组成

- **总线**
	- 贯穿整个系统的一组电子管道，携带信息字节并负责在各个部件间传递。
	- 一般被设计为传送定长的字节块（**字 word**）
	- 机器字长，4 个字节（32 位）或 8 个字节（64 位）

![一个典型系统的硬件组成](img/Pasted%20image%2020231210094532.png)

- **I/O 设备**
	- 系统与外部世界的联系通道
	- 每个 I/O 设备都通过一个*控制器或适配器*与 I/O 总线相连
	- 控制器和适配器区别在于封装方式
		- 控制器：I/O 设备本身或系统的主板上的芯片组
		- 适配器：插在主板插槽上的卡
- **主存**
	- 临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据
	- 物理上，由一组**动态随机存取存储器 DRAM 芯片**组成
	- 逻辑上，是一个线性的字节数组，每个字节都有*唯一的地址（数组索引）*，地址从零开始
- **处理器**
	- 解释/执行存储在主存中指令的引擎
	- 核心，大小位一个字的存储设备/寄存器，**程序计数器（PC）**
	- 任何时刻，PC 都*指向主存中*的某条*机器语言指令*（含有该指令的地址）

### 1.4.2 运行 hello 程序

- shell 程序执行指令
	- 通过键盘输入 `./hello`，回车
	- shell 将字符逐一读入寄存器，再存放到主存中![](img/Pasted%20image%2020231210095252.png)
	- shell 执行一系列指令加载可执行 hello 文件，将目标文件代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 `hello, wolrd\n` ![](img/Pasted%20image%2020231210095519.png)
	- 目标文件 hello 的代码和数据加载到主存，处理器开始执行 hello 程序的 main 程序中的机器语言指令
		- 将要输出的字符串中的字节从主存复制到寄存器
		- 再从寄存器复制到显示设备
		- 最终显示在屏幕上
		- ![](img/Pasted%20image%2020231210095641.png)

## 1.5 高速缓存至关重要

系统设计者的一个主要目标就是使**这些复制操作**尽可能快地完成

针对处理器与主存之间运行速度的差异，系统设计者采用了更小更快的存储设备，**高速缓存存储器 cache memory**，作为暂时的集结区域，存放处理器近期可能会需要的信息

![](img/Pasted%20image%2020231210095853.png)

- **高速缓存的局部性原理**：程序具有访问局部区域里的数据和代码的趋势

## 1.6 存储设备形成层次结构

- 计算机系统中的存储设备都被组织成了一个存储器层次结构

![](img/Pasted%20image%2020231210100008.png)

- **主要思想**：*上一层的存储器*作为*低一层存储器*的**高速缓存**

## 1.7 操作系统管理硬件

**所有应用程序对硬件的操作尝试都必须通过操作系统**

![计算机系统的分层视图](img/Pasted%20image%2020231210100120.png)

- 操作系统的两个基本功能
	- **防止硬件被失控的应用程序滥用**
	- 向应用程序*提供简单一致的机制*来*控制复杂而又通常大不相同的低级硬件设备*
- 通过基本的抽象概念（*进程、虚拟内存和文件*）实现两个基本功能

- **文件**：I/O 设备的抽象表示
- **虚拟内存**：对主存和磁盘 I/O 设备的抽象表示
- **进程**：对处理器、主存和 I/O 设备的抽象表示

### 1.7.1 进程

- 宏观上，每个进程独立地同时使用处理器
- 微观上，每个进程之间交错执行

- **并发运行**：一个进程的指令和另一个进程的指令是交错执行的
	- 通过处理器在*进程间的切换*实现的

- **操作系统保持跟踪进程运行所需的所有状态信息**，即上下文信息
	- 切换进程时会进行上下文切换（*保存当前*进程上下文，*恢复新*进程上下文，控制权交给新进程，从上次停止的地方开始）
![进程的上下文切换](img/Pasted%20image%2020231210100755.png)

- 从一个进程切换到另一个进程是由**操作系统内核（kernel）**管理的
	- 内核：操作系统代码常驻主存的部分
	- 系统管理全部进程所用代码和数据结构的集合

### 1.7.2 线程

*一个进程*实际上可由*多个称为线程的执行单元*组成，每个*线程*都*运行在进程的上下文*中，并*共享*同样的*代码*和*全局数据*

**多线程之间比多进程之间更容易共享数据**


### 1.7.3 虚拟内存

为每个进程提供了一个*假象*，即*每个进程*都在*独占*地使用*主存*

每个进程看到的内存都是一致的，称为**虚拟地址空间**，由大量*准确定义的区*构成
- 地址从下往上是增大的

![进程的虚拟地址空间](img/Pasted%20image%2020231210101207.png)

- **程序代码和数据**：进程开始时指定大小
- **堆**：运行时可以动态扩展和收缩
- **共享库**：C 标准库和数学库这样的共享库的代码和数据的区域
- **栈**：位于用户虚拟地址空间顶部。编译器用来实现函数调用，可以在运行时动态扩展和收缩
- **内核虚拟内存**：地址空间顶部的区域，为内核保留。应用程序不允许读写这个区域的内容或调用内核代码定义的函数，**必须调用内核来执行**这些操作

- **虚拟内存的基本思想**：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存

### 1.7.4 文件

- **文件**，字节序列

## 1.8 系统之间利用网络通信

![](img/Pasted%20image%2020231210101738.png)

## 1.9 重要主题

### 1.9.1 Amdahl 定律

当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

- 若系统执行某个应用程序需要时间 $T_{old}$。
- 假设系统某部分所需执行时间与改时间的比例为 $\alpha$，该部分性能提升比例为 $k$。即该部分初始所需时间为 $\alpha T_{old}$，现在所需时间为 $\alpha T_{old}/k$
- 因此总的执行时间应为：$$
T_{new} = (1-\alpha)T_{old}+(\alpha \frac{T_{old}}{k})=T_{old}[(1-\alpha)+\alpha/k]
$$
- 加速比 $S=T_{old}/T_{new}$

### 1.9.2 并发和并行

- **并发 concurrency**：一个同时具有多个活动的系统
- **并行 parallelism**：用并发来使一个系统运行得更快，可以在计算机系统的多个抽象层次上使用

#### 线程级并发

"模拟"出来的并发执行，通过在*正在执行的进程间快速切换*实现的

多处理器的使用从两方面提高系统性能：
- 减少了执行多个任务时模拟并发的需要
- 是应用程序运行得更快（要求程序以多线程方式书写）

**找到书写应用程序的方法利用硬件开发线程级并行性**

#### 指令级运行

较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为*指令级并行*

**超标量 super-scalar**处理器：比一个周期一条指令更快的执行速率

#### 单指令、多数据并行

最低层次上，特殊的硬件，允许一条指令产生多个可以并行执行的操作，即 **SIMD 并行**

### 1.9.3 计算机系统中抽象的重要性

![计算机系统提供的一些抽象](img/Pasted%20image%2020231210102720.png)

- 一个重大主题：**提供不同层次的抽象表示**，隐藏实际实现的复杂性

- 文件：I/O 设备的抽象
- 虚拟内存：程序存储器的抽象
- 进程：一个正在运行的程序的抽象
- **虚拟机**：对整个计算机的抽象，包括操作系统、处理器和程序
