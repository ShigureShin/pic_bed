#cpp 

---
return 语句的作用
- 结束当前正在执行的函数
- 将控制权返回到调用函数的地方

两种形式：

```cpp
return ;
return expression;
```

### 6.3.1 无返回值函数

返回类型为 void 的函数，使用无返回值的 return 语句。可以不写，void 函数最后会隐式执行 return

return 语句的用途之一：*在函数的中间位置提前退出*，类似于 break 语句

如果要使用 return 语句的第二种形式，即 `return expression;`

则，这里的 `expression` 也必须是另一个返回 void 的函数

### 6.3.2 有返回值的函数

只要函数类型不是 void，则该函数内的 return 语句必须返回一个值，且该值类型*与函数的返回类型相同*，或*能够隐式转换*为函数的返回类型

#### **值是如何被返回的？**

与初始化一个变量或形参的方式一样：*返回值用于初始化调用点的一个临时变量*

如果函数返回引用，则该引用仅是它所指对象的一个别名（与其他引用类型一样）

#### **不要返回局部对象的引用或指针**

函数完成后，其占据的存储空间会被释放，因此此时局部对象的引用或指针会失效，强行返回会引发未定义的行为。

#### **返回类类型的函数和调用运算符**

```cpp
const string &shorterString(const string &s1, const string &s2)
{
	return s1.size() <= s2.size()? s1:s2;
}

// 返回较短string的长度，可以直接调用string对象的size成员函数
auto sz = shorterString(s1, s2).size();
```

#### **引用返回左值**

函数的返回类型：
- *返回引用类型*：得到左值
- 其他返回类型：得到右值

返回引用，可以像其他左值那样来直接赋值

```cpp
char &get_val(string &str, string::size_type ix)
{
	return str[ix]; // get_val 假定索引有效
}
int main()
{
	string s("a value");
	cout << s << endl; // 输出 a value
	get_val(s, 0) = 'A'; // 将s[0]修改为 'A'
	cout << s << endl; // 输出 A value
	return 0;
}
```

#### **列表初始化返回值**

```cpp
vector<string> process()
{
	// ...
	// expected 和 actual 是 string 对象
	if(expected.empty())
		return {};                              // 返回空vector对象
	else if(expected == actual)
		return {"functionX", "okay"};           // 返回列表初始化的vector对象
	else
		return {"functionX", expected, actual}; // 返回列表初始化的vector对象
}
```

需要注意
- 如果函数返回的类型为*内置类型*，则*花括号内最多有一个值*
- 如果返回的类型为*类类型*，则*由该类本身定义初始值如何使用*

#### **主函数 main 的返回值**

*允许 main 函数没有 return 语句直接结束*，编译器会隐式插入一条返回 0 的 return 语句

一般把 main 函数的返回值看作是状态指示器，返回 0 表示执行成功，返回其他表示执行失败（非 0 含义根据具体机器确定）

如果让返回值和机器无关，可以使用 `cstdlib` 头文件定义的两个预处理变量，分别表示成功与失败

```cpp
int main()
{
	if (failure)
		return EXIT_FAILURE;
	else
		return EXIT_SUCCESS;
}
```

预处理变量，不能在前边加上 `std` 也不能在 `using` 声明中出现

#### **递归**

一个函数调用了自身，即为**函数递归（recursive function）**

**注意**：递归函数中，一定有一条路径不包含递归调用（*即终止条件*），否则函数将“一直”递归下去（不断调用自身直到程序栈空间耗尽）

### 6.3.3 返回数组指针

数组不能被拷贝，所以函数不能返回数组，但是可以返回数组的指针或引用

#### **使用类型别名返回数组的指针**

```cpp
typedef int arrT[10];

using arrT = int[10];
arrT* func(int i); // 返回指向含有10个整数的数组指针
```

#### 声明一个返回数组指针的函数

```cpp
int arr[10]; // 含有10个整数的数组
int *p1[10]; // 含有10个指针的数组
int (*p2)[10] = &arr; // 指向含有10个整数的数组
```

参考如上方式，定义一个返回数组指针的函数

```cpp
Type (*function(parameter_list))[dimension]
```
- `(*function(parameter_list))` 两端的括号必须存在

解读：
- `func(int i)`：调用 func 函数需要一个 int 类型的实参
- `(*func(int i))`：可以对函数调用的结果执行解引用操作
- `(*func(int i))[10]`：解引用 func 的调用将得到一个大小为 10 的数组
- `int (*func(int i))[10]`：表示数组中的元素为 int 类型

#### 使用尾置返回类型

另一种简化上述声明方法，使用**尾置返回类型 trailing return type**

任何函数的定义都可以使用尾置返回，*适合返回类型比较复杂的函数*，例如：返回数组的指针或数组的引用

在形参列表后使用`->`符号开头紧接着为具体的返回类型，具体形式如下：

```cpp
// func接受一个int类型的实参，返回一个数组指针
auto func(int i) -> int(*)[10];
```

#### 使用 decltype

如果已知数组类型，可以使用 decltype 关键字声明返回类型，具体如下：

```cpp
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};

decltype(odd) *arrPtr(int i)
{
	return (i%2)? &odd:&even;
}
```

已知返回指针所要指向的数组类型，直接使用 `decltype(odd)` 获取对应类型


