#cpp 

---

## 6.3 f返回类型和return语句

### 6.3.2 有返回值的函数

#### [练习 6.30](src/6-30.cpp)

> 编译第200页的 str_subrange 函数，看看你的编译器是如何处理函数中错误的。

解：

错误信息如下：
```cpp
warning: control reaches end of non-void function [-Wreturn-type] 
```

#### 练习 6.31

> 什么情况下返回的引用无效？什么情况下返回常量的引用无效？

解：

- 返回的引用为局部变量时，返回的引用无效
- 需要修改函数返回值时，返回常量的引用无效

#### 练习 6.32

> 下面的函数合法吗？如果合法，说明其功能；如果不合法，修改其中的错误并解释原因。

```c
int &get(int *array, int index) { return array[index]; }
int main()
{
    int ia[10];
    for (int i = 0; i != 10; ++i)
        get(ia, i) = i;
}
```

解：

合法。
get 函数接收一个整型数组指针和索引值，并返回该数组在给定索引位置的元素引用

#### [练习 6.33](src/6-33.cpp)

> 编写一个递归函数，输出 vector 对象的内容。

#### 练习 6.34

> 如果 factorial 函数的停止条件如下所示，将发生什么？

```c
if (val != 0)
```

解：

factorial 函数为：
```cpp
int factorial(int val)
{
	if(val>1)
		return factorial(val-1)*val;
	return 1;
}
```

修改为题目中的中止条件后，计算的结果不会发生变化，具体执行步骤中多计算了一次与 1 的相乘

#### 练习 6.35

> 在调用 factorial 函数时，为什么我们传入的值是 val-1 而非 val--？

解：

- 如果传入 val--，因为是后置自减运算符，会导致先使用 val 的值调用 factorial 函数，再对 val-1
- 而此时，被调用的 factorial 函数之中又会再次进行 val--的操作，从而导致一直递归调用下去，直至函数调用栈使用完毕

### 6.3.3 返回数组指针

#### 练习 6.36

> 编写一个函数声明，使其返回数组的引用并且该数组包含10个 string 对象。不用使用尾置返回类型、decltype 或者类型别名。

解：

```cpp
string (&func())[10];
```

#### 练习 6.37

> 为上一题的函数再写三个声明，一个使用类型别名，另一个使用尾置返回类型，最后一个使用decltype关键字。你觉得哪种形式最好？为什么？

解：

```cpp
// 类型别名
typedef string STR[10];
STR &func();

// 尾置返回类型
auto func()->string(&)[10];

// decltype关键字
string str[10];
decltype(str) &func();
```

尾置返回类型更好，书写简便，类型明了

#### 练习 6.38

> 修改arrPtr函数，使其返回数组的引用。

解：

```cpp
decltype(odd)& arrPtr(int i)
{
    return (i % 2) ? odd : even;
}
```




