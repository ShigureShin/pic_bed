#编程基础 #cpp 

# 6.1 C++运算符重载基础教程

函数重载 Function Overloading 让一个函数名拥有多个功能，在不同的情况下进行不同操作。

*运算符重载 Operator Overloading 也是同理，让同一个运算符拥有不同的功能*

> 实际上，
> `+` 对不同类型 int、float 的数据进行加法操作；
> `<<`既可以作为位移运算符，又可以配合 `cout` 向控制台输出数据
> 不止这两种情况，C++本身已经对运算符进行了重载

下面举例，通过运算符重载，让 `+` 实现复数的加法运算：

```cpp
#include <iostream>
using namespace std;

class complex{
public:
    complex();
    complex(double real, double imag);
public:
    //声明运算符重载
    complex operator+(const complex &A) const;
    void display() const;
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

complex::complex(): m_real(0.0), m_imag(0.0){ }
complex::complex(double real, double imag): m_real(real), m_imag(imag){ }

//实现运算符重载
complex complex::operator+(const complex &A) const{
    complex B;
    B.m_real = this->m_real + A.m_real;
    B.m_imag = this->m_imag + A.m_imag;
    return B;
}

void complex::display() const{
    cout<<m_real<<" + "<<m_imag<<"i"<<endl;
}

int main(){
    complex c1(4.3, 5.8);
    complex c2(2.4, 3.7);
    complex c3;
    c3 = c1 + c2;
    c3.display(); // 6.7 + 9.5i
 
    return 0;
}
```

- 运算符重载其实就是定义一个函数，在函数体内实现想要的功能。当用到该运算符时，编译器会自动调用这个函数
- **运算符重载是通过函数实现的，本质上是函数重载**

格式为：

```cpp
返回值类型 operator 运算符名称 (形参列表){
	//TODO;
}
```

- `operator` 用于定义重载运算符的函数的关键字
- `operator 运算符名称` 可以看作函数名
- 运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别

对于上边的例子中，`c3=c1+c2` 实际上是 `c3 = c1.operator+(c2);`，注意这里的 `operator+` 是函数名

**注意这里，重载的 `+` 向左结合，调用对象 `c1` 的运算符重载函数**

另一种简练的定义形式：

```cpp
complex complex::operator+(const complex &A) const{
	return complex(this->m_real+A.m_real, this->m_imag+A.m_imag);
}
```

- `return` 语句中的 `complex(...)` 会创建一个临时的匿名对象，由 `return` 返回该临时对象

## 在全局范围内重载运算符

```cpp
#include <iostream>
using namespace std;

class complex{
public:
    complex();
    complex(double real, double imag);
public:
    void display() const;
    
    //声明为友元函数
    friend complex operator+(const complex &A, const complex &B);
    
private:
    double m_real;
    double m_imag;
};

complex operator+(const complex &A, const complex &B);

complex::complex(): m_real(0.0), m_imag(0.0){ }
complex::complex(double real, double imag): m_real(real), m_imag(imag){ }
void complex::display() const{
    cout<<m_real<<" + "<<m_imag<<"i"<<endl;
}

//在全局范围内重载+
complex operator+(const complex &A, const complex &B){
    complex C;
    C.m_real = A.m_real + B.m_real;
    C.m_imag = A.m_imag + B.m_imag;
    return C;
}

int main(){
    complex c1(4.3, 5.8);
    complex c2(2.4, 3.7);
    complex c3;
    c3 = c1 + c2;
    c3.display();
 
    return 0;
}
```

- 由于在全局范围内重载，所以在类中要加上 `friend` 声明为友元函数
- 此时 `c3=c1+c2;` 实际上是 `c3 = operator+(c1, c2);`

# 6.2 C++运算符重载的规则

1. **并不是所有的运算符都可以重载**
	- 可以重载的运算符包括：
		- `+  -  *  /  %  ^  &  |  ~  !  =  <  >  +=  -=  *=  /=  %=  ^=  &=  |=  <<  >>  <<=  >>=  ==  !=  <=  >=  &&  ||  ++  --  ,  ->*  ->  ()  []  new  new[]  delete  delete[]`
		- 其中，`[]`是下标运算符，`()`是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。
	- *不可以重载的运算符*：
		- 长度运算符`sizeof`
		- 条件运算符`: ?`
		- 成员选择符`.`
		- 域解析运算符`::`
2. **重载不能改变运算符的优先级和结合性**
3. **重载不会改变运算符的用法**
	- 例如，有几个操作数、操作数在左还是在右等
4. **运算符重载不能有默认默认参数**，某则就改变了运算符操作数的个数
5. **运算符重载函数既可以作为类的成员函数，也可以作为全局函数**
	- 作为类的成员函数时
		- 二元运算符的参数只有一个
			- 另一个参数是隐含的，通过 `this` 指针隐式访问成员变量
		- 一元运算符不需要参数
	- *作为全局函数时*
		- *二元运算符就需要两个参数*
		- 一元运算符需要一个参数
		- 并且其中必有一个参数是对象，以便让编译器区分是否为自定义的运算符，防止修改用于内置类型的运算符的性质
		- *一般需要在类中声明为友元函数*
			- 原因：该函数大部分情况下都需要使用类的 `private` 成员
6. **箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符` = `只能以成员函数的形式重载**

# 6.3 C++重载数学运算符（实例演示）

复数的四则运算及相等关系判断

**注意：**
- 代码中以全局形式重载了 `+、-、*、/、==、!=`
- 以成员函数重载了 `+=、-=、*=、/=`

# 6.4 到底以成员函数还是全局函数（友元函数）的形式重载运算符

在上一节最后，用不同形式重载运算符的原因

## 简单地了解转换构造函数

引入一个新概念，**转换构造函数**，用以搞清楚成员函数和全局函数的区别

```cpp
#include <iostream>
using namespace std;

//复数类
class Complex{
public:
    Complex(): m_real(0.0), m_imag(0.0){ }
    Complex(double real, double imag): m_real(real), m_imag(imag){ }
    Complex(double real): m_real(real), m_imag(0.0){ }  //转换构造函数
public:
    friend Complex operator+(const Complex &c1, const Complex &c2);
public:
    double real() const{ return m_real; }
    double imag() const{ return m_imag; }
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

//重载+运算符
Complex operator+(const Complex &c1, const Complex &c2){
    Complex c;
    c.m_real = c1.m_real + c2.m_real;
    c.m_imag = c1.m_imag + c2.m_imag;
    return c;
}

int main(){
    Complex c1(25, 35);
    Complex c2 = c1 + 15.6;
    Complex c3 = 28.23 + c1;
    
    cout<<c2.real()<<" + "<<c2.imag()<<"i"<<endl;
    // 40.6 + 35i
    cout<<c3.real()<<" + "<<c3.imag()<<"i"<<endl;
    // 53.23 + 35i
   
    return 0;
}
```

- 30、31行代码：double 类型和 complex 类型的加法运算
	- 留意7、8、9行代码，这里多声明了一个构造函数 `Complex(double real);`
	- 当编译器检测到 double 类型和 complex 类型相加时，会尝试将 double 转换为 complex，或者将 complex 转换为 double（只有相同类型的数据才能进行 + 运算）
	- 如果都转换失败或者都转换成功（*二义性*），就会报错
	- 所以，这个计算过程如下图所示![](../img/Pasted%20image%2020231116165113.png)
	- 即，double类型被转换为了 complex 对象
- 因为 `Complex(double real);` 在作为普通构造函数的同时，还能降 double 类型转换为 Complex 类型，集合了“构造函数”和“类型转换”的功能，所以被称为*转换构造函数*
- **转换构造函数用来将其它类型（可以是 bool、int、double 等基本类型，也可以是数组、指针、结构体、类等构造类型）转换为当前类类型**

## 为什么要以全局函数的形式重载 +

定义 `operator+` 为全局函数（友元函数），*保证 + 运算符的操作数能够被对称的处理，即 double 类型在 + 左边还是右边都是正确的*

如果将 `operator+` 定义为成员函数，根据“+ 运算符具有左结合性”： `Complex c2=c1+15.6;`，实际为 `Complex c2 = c1.operator+(Complex(15.6));`

所以如果此时double类型在 + 左侧，会出现 `Complex c3 = (28.23).operator+(c1);`，这显然是错误的

**C++ 只会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换**

## 为什么要以成员函数的形式重载 +=

**运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的**

但由于
*类的成员不能对称地处理数据*

程序员必须在（参与运算的）所有类型的内部都重载当前的运算符。以上面的情况为例，我们必须在 Complex 和 double 内部都重载 + 运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的。

所以 C++ 进行了折中，允许以全局函数（友元函数）的形式重载运算符。

> C++ 规定，箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符` = `只能以成员函数的形式重载

# 6.5 C++重载>>和<<（输入和输出运算符）

在[C++](https://c.biancheng.net/cplus/)中，标准库本身已经对左移运算符`<<`和右移运算符`>>`分别进行了重载，使其能够用于不同数据的输入输出，但是输入输出的对象只能是 C++ 内置的数据类型（例如 bool、int、double 等）和标准库所包含的类类型（例如 string、complex、ofstream、ifstream 等）

## 重载输入运算符>>

```cpp
istream & operator>>(istream &in, complex &A){
    in >> A.m_real >> A.m_imag;
    // 返回 istream 类对象的引用，是为了能够连续读取复数
    return in;
}
```

```cpp
complex c1, c2;  
cin>>c1>>c2;
```

- 还需要在 complex 类中声明为友元函数

```cpp
friend istream & operator>>(istream &in , complex &a);
```

## 重载输出运算符<<

```cpp
ostream & operator<<(ostream &out, complex &A){
    out << A.m_real <<" + "<< A.m_imag <<" i ";
    // 由于采用了引用的方式进行参数传递，并且也返回了对象的引用，所以重载后的运算符可以实现连续输出
    return out;
}
```

同样需要将该函数声明为 complex 类的友元函数：  

```cpp
friend ostream & operator<<(ostream &out, complex &A);
```

## 完整示例

```cpp
#include <iostream>
using namespace std;

class complex{
public:
    complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ };
public:
    friend complex operator+(const complex & A, const complex & B);
    friend complex operator-(const complex & A, const complex & B);
    friend complex operator*(const complex & A, const complex & B);
    friend complex operator/(const complex & A, const complex & B);
    friend istream & operator>>(istream & in, complex & A);
    friend ostream & operator<<(ostream & out, complex & A);
private:
    double m_real;  //实部
    double m_imag;  //虚部
};

//重载加法运算符
complex operator+(const complex & A, const complex &B){
    complex C;
    C.m_real = A.m_real + B.m_real;
    C.m_imag = A.m_imag + B.m_imag;
    return C;
}

//重载减法运算符
complex operator-(const complex & A, const complex &B){
    complex C;
    C.m_real = A.m_real - B.m_real;
    C.m_imag = A.m_imag - B.m_imag;
    return C;
}

//重载乘法运算符
complex operator*(const complex & A, const complex &B){
    complex C;
    C.m_real = A.m_real * B.m_real - A.m_imag * B.m_imag;
    C.m_imag = A.m_imag * B.m_real + A.m_real * B.m_imag;
    return C;
}

//重载除法运算符
complex operator/(const complex & A, const complex & B){
    complex C;
    double square = A.m_real * A.m_real + A.m_imag * A.m_imag;
    C.m_real = (A.m_real * B.m_real + A.m_imag * B.m_imag)/square;
    C.m_imag = (A.m_imag * B.m_real - A.m_real * B.m_imag)/square;
    return C;
}

//重载输入运算符
istream & operator>>(istream & in, complex & A){
    in >> A.m_real >> A.m_imag;
    return in;
}

//重载输出运算符
ostream & operator<<(ostream & out, complex & A){
    out << A.m_real <<" + "<< A.m_imag <<" i ";;
    return out;
}

int main(){
    complex c1, c2, c3;
    cin>>c1>>c2;
 
    c3 = c1 + c2;
    cout<<"c1 + c2 = "<<c3<<endl;

    c3 = c1 - c2;
    cout<<"c1 - c2 = "<<c3<<endl;

    c3 = c1 * c2;
    cout<<"c1 * c2 = "<<c3<<endl;

    c3 = c1 / c2;
    cout<<"c1 / c2 = "<<c3<<endl;

    return 0;
}
```

# 6.6 C++重载`[]`（下标运算符）

[C++](https://c.biancheng.net/cplus/) 规定，下标运算符`[ ]`必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：

```cpp
返回值类型 & operator[ ] (参数);
```

或者：

```cpp
const 返回值类型 & operator[ ] (参数) const;
```

- 使用第一种声明方式，`[ ]`不仅可以访问元素，还可以修改元素
- 使用第二种声明方式，`[ ]`只能访问而不能修改元素
- **实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为[通过 const 对象只能调用 const 成员函数](https://c.biancheng.net/view/2232.html)，如果不提供第二种形式，那么将无法访问 const 对象的任何元素**

- 通过自定义的 Array 类来实现变长数组

```cpp
#include <iostream>
using namespace std;

class Array{
public:
	Array(int length=0);
	~Array();
public:
	int & operator[](int i);
	const int & operator[](int i) const;
public:
	int length() const { return m_length; }
	void display() const;
private:
	int m_length;
	int *m_p;
}
Array::Array(int length):m_length(length){
	if (length==0){
		m_p = NULL;	
	}else{
		m_p = new int[length];
	}
}
Array::~Array(){
	delete[] m_p;
}
int& Array::operator[](int i){
	return m_p[i];
}
const int & Array::operator[](int i) const{
	return m_p[i];
}
void Array::display() const {
	for (int i=0;i<m_length;i++){
		if(i==m_length-1){
			cout<<m_p[i]<<endl;
		}else{
			cout<<m_p[i]<<",";
		}
	}
}
int main(){
	int n;
	cin >> n;
	Array A(n);
	for (int i=0, len=A.length();i<len;i++){
		A[i] = i * 5;
	}
	A.display();

	const Array B(n);
	cout<<B[n-1]<<endl;
}
```

- 重载 `[]` 运算符后，表达式 `arr[i]` 会被转换为

```cpp
arr.operator[](i);
```

# 6.7 C++重载++和--（自增和自减运算符）

自增`++`和自减`--`都是一元运算符，它的前置形式和后置形式都可以被重载

> 运算符++和--有前置和后置两种形式
> 如果不区分前置和后置，则使用 `operator++( )` 或 `operator--( )` 即可；
> 否则，
> 	使用 `operator++( )` 或 `operator--( )` 来重载前置运算符
> 	使用 `operator++(int)` 或 `operator--(int)` 来重载后置运算符,调用时，参数 int 被传递给值0

- 建立秒表类，重载运算符++的前置后置两种形式

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

//秒表类
class stopwatch{
public:
    stopwatch(): m_min(0), m_sec(0){ }
public:
    void setzero(){ m_min = 0; m_sec = 0; }
    stopwatch run();  // 运行
    stopwatch operator++();  //++i，前置形式
    stopwatch operator++(int);  //i++，后置形式
    friend ostream & operator<<( ostream &, const stopwatch &);
private:
    int m_min;  //分钟
    int m_sec;  //秒钟
};

stopwatch stopwatch::run(){
    ++m_sec;
    if(m_sec == 60){
        m_min++;
        m_sec = 0;
    }
    return *this;
}

stopwatch stopwatch::operator++(){
    return run();
}

stopwatch stopwatch::operator++(int n){
    stopwatch s = *this;
    run();
    return s;
}

ostream &operator<<( ostream & out, const stopwatch & s){
    out<<setfill('0')<<setw(2)<<s.m_min<<":"<<setw(2)<<s.m_sec;
    return out;
}

int main(){
    stopwatch s1, s2;

    s1 = s2++;
    cout << "s1: "<< s1 <<endl; // s1: 00:00
    cout << "s2: "<< s2 <<endl; // s2: 00:01
    s1.setzero();
    s2.setzero();

    s1 = ++s2;
    cout << "s1: "<< s1 <<endl; // s1: 00:01
    cout << "s2: "<< s2 <<endl; // s2: 00:01
    return 0;
}
```

- 注意前置与后置运算符的区别
- **后置运算符**
	- 在33行，重载了后置运算符，这里先保存了自增之前的 `*this` 对象，再调用自增操作 `run();`
	- 此时，其实对象已经完成了自增，但*返回的是自增之前的对象*

# 6.8 C++重载new和delete运算符

...

# 6.9 C++重载()（强制类型转换运算符）






