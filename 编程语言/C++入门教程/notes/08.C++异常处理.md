#编程基础 #cpp 

C++ 异常处理机制就可以让我们*捕获并处理这些错误*，然后我们可以让程序沿着一条不会出错的路径继续执行，或者不得不结束程序，但在结束前可以做一些必要的工作，例如将内存中的数据写入文件、关闭打开的文件、释放分配的内存等。

程序的错误大致可以分为三种，分别是**语法错误**、**逻辑错误**和**运行时错误**：

- **语法错误**
	- 在编译和链接阶段就能发现
	- 只有 100% 符合语法规则的代码才能生成可执行程序。
	- 语法错误是最容易发现、最容易定位、最容易排除的错误
	- 程序员最不需要担心的就是这种错误。  
- **逻辑错误**
	- 是说我们编写的*代码思路有问题*，不能够达到最终的目标
	- 这种错误可以*通过调试来解决*。  
- **运行时错误**
	- 是指程序*在运行期间发生的错误*，例如除数为 0、内存分配失败、数组越界、文件不存在等。
	- **[C++](https://c.biancheng.net/cplus/) 异常（Exception）机制就是为解决运行时错误而引入的**
	- 运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（Crash）

C++ 异常处理机制会涉及 `try`、`catch`、`throw` 三个关键字

# 8.1 C++异常处理 try catch

一个发生*运行时错误*的例子：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
	string str = "http://c.biancheng.net";
	char ch1 = str[100]; // 下标越界，垃圾值
	cout<<ch1<<endl;
	char ch2=str.at(100); // 下标越界，抛出异常
	cout<<ch2<<endl;
	return 0;
}
```

## 捕获异常

可以借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：

```cpp
try{  
    // 可能抛出异常的语句  
}catch(exceptionType variable){  
    // 处理异常的语句  
}
```

`try`和`catch`都是 C++ 中的关键字，后跟语句块，不能省略`{ }`。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它*只是“检测”语句块有没有异常*，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。

**异常的处理流程：**

```cpp
抛出（Throw）--> 检测（Try） --> 捕获（Catch）
```

## 发生异常的位置

异常可以发生在*当前的 try 块中*，也可以发生*在 try 块所调用的某个函数中*，或者是*所调用的函数又调用的另外的一个函数中发生了异常*。这些异常，都可以被 try 检测到。

# 8.2 C++异常类型以及多级catch匹配

try-catch 的用法：  

```cpp
try{  
    // 可能抛出异常的语句  
}catch(exceptionType variable){  
    // 处理异常的语句  
}
```

- catch 关键字后边的`exceptionType variable`
	- `exceptionType` 是异常类型，表明目前catch可以处理什么类型的异常
	- `variable`则是一个用来接受异常信息的变量，程序抛出异常时会创建一份包含了错误信息的数据
- 据此，**异常是包含了错误信息的数据，所以应该有相应的数据类型**
- C++规定，异常类型可以是 int、char、float、bool等基本类型和指针、数组、字符串、结构体、类等聚合类型。
	- *C++语言及标准库中的函数抛出的异常，都是 `exception` 类或其子类的异常*
	- 即，抛出异常时会创建一个exception类或其子类的对象

所以，catch作用是捕获 `exceptionType` 类型的异常，只有当异常数据和这里的类型相匹配时，才会传递给 variable

**catch和真正的函数调用之间的区别**：
- 函数调用：形参和实参的类型需要匹配，或者可以自动转换，否则在编译阶段报错
- catch：异常出现在运行阶段，无法提前预测异常类型，所以无法在编译阶段判断类型，只有在运行后出现异常时再将异常类型和catch能处理的类型进行匹配

*catch比真正的函数调用，多了一个【在运行阶段将实参和形参匹配】的过程*

## 多级 catch

一个try后边可以对应一个catch也可以对应多个catch

```cpp
try{
    //可能抛出异常的语句
}catch (exception_type_1 e){
    //处理异常的语句
}catch (exception_type_2 e){
    //处理异常的语句
}
//其他的catch
catch (exception_type_n e){
    //处理异常的语句
}
```

- 多级catch的匹配规则
	- *从上到下的顺序*，遇到类型匹配的catch就停止
	- 如果没有找到匹配的catch，则交给系统处理，终止程序的运行

## catch 在匹配过程中的类型转换

catch在匹配异常类型时，也会进行类型转换，限制比函数的实参与形参类型转换更多

- 对于函数：
	- 算术转换：int转float、char转int、double转int等
	- 向上转换：派生类转基类
	- const转换：非const转为const
	- 数组或函数指针转换：函数形参不是引用类型时，数组名会被转换为数组指针，函数名也会转换成函数指针
	- 自定义的类型转换
- **对于异常，只能进行下面的三种转换**
	- *向上转型*
	- *const转换*
	- *数组或函数指针转换*

# 8.3 C++ throw（抛出异常）

C++处理异常的流程为：

```cpp
抛出（Throw）--> 检测（Try） --> 捕获（Catch）
```

可以使用 `throw` 关键字来*显式抛出异常*

```cpp
throw exceptionData;
```

这里的 `exceptionData` 是异常数据，类型由程序员决定，如int、float、bool、数组、指针等

**异常规范是 C++98 新增的一项功能，但是后来的 C++11 已经将它抛弃了，不再建议使用**

# 8.4 C++ exception类：C++标准异常的基类

C++ 语言本身或者标准库抛出的异常都是 exception 的子类，称为**标准异常（Standard Exception）**

- 捕获所有标准异常的语句：

```cpp
try{
    //可能抛出异常的语句
}catch(exception &e){
    //处理异常的语句
}
```

- 这里使用引用，是为了提高效率。如果不使用引用，就需要进行一次对象拷贝

**exception 类的继承层次**

![](../img/Pasted%20image%2020231117170230.png)

- **exception类的直接派生类**

|异常名称|说  明|
|---|---|
|logic_error|逻辑错误。|
|runtime_error|运行时错误。|
|bad_alloc|使用 new 或 new[ ] 分配内存失败时抛出的异常。|
|bad_typeid|使用 typeid 操作一个 NULL [指针](https://c.biancheng.net/c/80/)，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。|
|bad_cast|使用 dynamic_cast 转换失败时抛出的异常。|
|ios_base::failure|io 过程中出现的异常。|
|bad_exception|这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型。|

- **logic_error 的派生类**

|异常名称|说  明|
|---|---|
|length_error|试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作。|
|domain_error|参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。|
|out_of_range|超出有效范围。|
|invalid_argument|参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常。|

- **runtime_error 的派生类**

|异常名称|说  明|
|---|---|
|range_error|计算结果超出了有意义的值域范围。|
|overflow_error|算术计算上溢。|
|underflow_error|算术计算下溢|






