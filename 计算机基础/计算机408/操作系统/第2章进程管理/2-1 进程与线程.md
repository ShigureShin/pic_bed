#computer 

---
# 2.1.1 概念、组成、特征
## 进程的概念

- 程序
	- *静态*
	- 存放在磁盘里的可执行文件，一系列的指令集合
- 进程（Process）
	- 动态的
	- 程序的一次执行过程
	- *同一个程序多次执行会对应多个进程*

如何区分各个进程？

## 进程的组成

- 进程的组成
	- PCB
	- 程序段
	- 数据段

### PCB

进程被创建时，OS 会为该进程分配一个唯一的、不重复的 PID，即进程ID

操作系统需要记录的进程信息如下：

![](img/Pasted%20image%2020231226104008.png)

PCB *是进程存在的唯一标志*

**进程控制块（PCB）**：
- 进程描述信息
	- 进程标识符 PID
	- 用户标识符 UID
- 进程控制和管理信息
	- CPU、磁盘、网络流量使用情况统计
	- 进程当前状态：就绪态、阻塞态、运行态
- 资源分配清单
	- 正在使用哪些文件
	- 正在使用哪些内存区域
	- 正在使用哪些 IO 设备
- 处理机相关信息
	- 如 PSW、PC 等等各种寄存器的值（用于实现进程切换）

PCB 为操作系统管理进程所需要的信息

### 程序段、数据段

- 程序段：程序的代码（指令序列）
- 数据段：程序运行过程中产生的各种数据（如：程序中定义的变量）

这两种为进程自身使用的信息

### 程序如何运行？

![](img/Pasted%20image%2020231226104755.png)

程序段、数据段、PCB 三部分组成了**进程实体（进程映像）**

**进程**是进程实体的*运行过程*，是系统进行*资源分配*和*调度*的独立单位

## 进程的特征

- 动态性
	- *进程最基本特征*
	- 进程是程序的一次执行过程，动态产生、变化和消亡
- 并发性
	- 内存中存在多个进程实体，各进程并发执行
- 独立性
	- 独立运行、独立获得资源、独立接受调度的基本单位
- 异步性
	- 会导致并发程序的不确定性
	- 各进程按照各自独立、不可预知的速度向前推进，OS 要提供*进程同步机制*来解决异步问题
- 结构性
	- 每个进程配置一个 PCB
	- 结构上，进程=程序段+数据段+PCB

---
# 2.1.2 状态与转换

## 总览

![](img/Pasted%20image%2020231226105529.png)

## 创建态、就绪态、运行态、阻塞态

- **创建态**：进程*正在被创建*
	- 此时 OS 为其分配资源、初始化 PCB
- **就绪态**：进程创建完成即进入“就绪态”，此时进程*具备运行条件*
	- CPU 无空闲则暂时不能运行
- **运行态**：CPU 空闲时，OS 选择一个就绪态的进程，*上处理机运行*
	- 此时 CPU 会执行该进程的指令序列
- **阻塞态**：进程运行过程中，可能会*请求等待某个事件的发生*
	- 如系统资源的分配，或其他进程的响应
- **中止态**
	- 进程自身结束
	- 或运行中出现不可修复错误

## 进程状态的转换

![](img/Pasted%20image%2020231226110317.png)

## 总结

![](img/Pasted%20image%2020231226110359.png)

对同一状态下的各个进程进行统一的管理，OS 将各个进程的 PCB 组织起来

---
# 2.1.3 组织与控制

目的：解决如何将各个处于不同状态的进程的 PCB 有效的组织并加以管理的问题

## 进程的组织
### 链式方式

利用对应状态的指针，将同一状态下的进程进行链式队列链接，顺序则按照各个进程之间的优先级

示意图如下：![](img/Pasted%20image%2020231226110551.png)
 
而阻塞队列指针则又可以根据具体的阻塞原因进行细分，如下图：![](img/Pasted%20image%2020231226110626.png)
### 索引方式

另一种组织方式，**索引方式**

建立索引表，将对应的进程存储进入对应状态的索引表中，示意图如下：![](img/Pasted%20image%2020231226110716.png)

**大部分系统使用的组织方式都是链式方式**

## 进程的控制

主要功能：对系统中所有进程实施有效管理
- 创建新进程
- 撤销已有进程
- 实现进程状态转换
- 等

*进程控制* = *实现进程状态转换*

![](img/Pasted%20image%2020231226114442.png)

**原语**：一种特殊的程序，不可以被中断
- 如果可以被中断，则可能出现 OS 中某些关键数据结构信息不统一，进而影响到 OS 的管理工作

这种不可以被中断的特性，通过两个特权指令实现这种原子性：
- **关中断**指令
- **开中断**指令

正常情况下，CPU 执行完一条指令都会检查是否有中断指令，有则执行中断指令对应的中断程序，中断程序执行完毕后再回到原来的指令。

对于原语的原子性：
- 通过*关中断指令*，让 CPU 不再检查中断信号
- 直到执行*开中断指令*之后才会恢复检查

![](img/Pasted%20image%2020231226120302.png)

![](img/Pasted%20image%2020231226120514.png)

![](img/Pasted%20image%2020231226120655.png)

![](img/Pasted%20image%2020231226120730.png)

## 程序如何运行？

在上文，进程的组成中简单描述了程序是如何运行的。这里针对 CPU 和内存之间进行针对性描述，程序是如何运行的

几个寄存器：
- PSW：程序状态字寄存器
- PC：程序计数器，存放下一条指令的地址
- IR：指令寄存器，存放当前正在执行的指令
- 通用寄存器：其他一些必要信息

这些寄存器为各个进程之间公用的，如果在某个进程执行期间发生中断，需要执行其他的进程，那么此时需要对要中断的进程的这些数据，即运行环境进行保存（保存一些*必要的寄存器信息*）
- 解决办法：在进程切换时，在 PCB 中保存

当原进程再次运行时，可以通过 PCB 恢复其运行环境（这里的运行环境，即为上文中进程切换时，切换原语所要保存/恢复的运行环境）

![](img/Pasted%20image%2020231226121735.png)

---
# 2.1.4 进程的通信

## 总览

![](img/Pasted%20image%2020231227091506.png)

进程通信是什么？
- 进程间通信（Inter-Process Communication， **IPC**）：进程和进程之间产生数据交互

为什么进程通信需要操作系统支持？
- 进程是分配系统资源的单位（包括内存地址空间），各进程拥有的内存地址空间相互独立
- 进程不能读取其他进程的内存空间，所以进程之间的交互*不是*通过直接访问其他进程的内存空间实现（原因：*保证安全*）
- 所以进程间通信需要操作系统来实现

有哪几种进程通信？
- **共享存储**
- **消息传递**
- **管道通信**

## 共享存储

![](img/Pasted%20image%2020231227093110.png)

**共享存储**：在内存中设置一片*共享存储区*，需要通信的进程通过这一片共享区进行数据交互

![](img/Pasted%20image%2020231227093117.png)

注：将共享区映射到进程自己的地址空间中，可以参考第三章中，“**增加页表项/段表项**”来实现这种映射

**思考**：如果两个进程同时对这个共享内存区进行写数据，如何避免可能发生的写覆盖问题？
- 设置进程对共享内存区的访问为*互斥*操作
- 使用*操作系统内核提供的同步互斥工具*（如 P、V 操作）
**注意**：这里实现互斥的方式，是*进程*利用操作系统内核提供的工具*实现*，

共享存储具体可分为两种共享方式：
- **基于数据结构**的共享
	- 划定的共享区中会规定，例如只能存放一个长度为 10 的数组
	- 共享方式速度慢，限制多，**低级通信**方式
- **基于存储区**的共享
	- 操作系统只负责划分出共享内存区
	- *内存区中数据的形式、存放位置则是由通信进程控制*
	- 这种共享方式速度很快，是一种**高级通信**方式

## 消息传递

**消息传递**：进程间的数据交互以*格式化信息（Message）* 为单位进行通信

这种格式化信息结构如下：![](img/Pasted%20image%2020231227100032.png)

使用操作系统的两个原语进行数据交换：
- *发送消息*
- *接收消息*

根据消息传递是否指明信息的发送者/接受者，分为两种：
- **直接通信方式**：发送进程指明*接收进程的 ID*
- **间接通信方式**：通过“信箱”方式间接通信

**直接通信方式**

- 进程 P 通过发送原语，指明接收进程 pid
- message 被发送到进程 Q 的消息队列（这个消息队列位于操作系统内核的地址空间）
- 进程 Q 从消息队列中指明接收来自进程 P 的格式化消息

![](img/Pasted%20image%2020231227100254.png)

**间接通信方式**

- 在操作系统内核地址空间中，申请信箱
- 进程 P 在自身的地址空间中创建消息并利用发送原语，发送给信箱 A（这里没有给出发给哪个进程）
- 进程 Q 利用接收原语去信箱 A 中接收消息

![](img/Pasted%20image%2020231227100536.png)

*问题*：
- 进程 Q 如何知道进程 P 要发送给自己消息？
- 进程 Q 如何知道进程 P 发给自己的消息位于信箱 A？

## 管道通信

![](img/Pasted%20image%2020231227104103.png)

与**共享存储**方式之间，
- 共享存储中，信息在这片共享存储区内的存储位置、存储形式，都是由进程自行决定的
- 而对于**管道通信**，必须按照 FIFO 的规则进行，即循环队列。
- 共享存储为进程利用内核工具实现互斥，而管道通信为操作系统负责实现

---
# 2.1.5 线程和多线程模型

## 总览

![](img/Pasted%20image%2020231227104714.png)

## 什么是线程？为什么要引入线程？

先来思考传统的进程，

传统的进程是程序执行流的最小单位，CPU 轮流为各个进程服务从而实现并发执行，而在每个进程内部又存在多种不同的“事情”，例如 QQ，一边视频聊天一边发送文字信息，也就是说*进程内部还存在一些需要并发执行的事件*

引入线程概念后，此时**线程**为程序执行流的最小单位。现在不仅进程之间可以并发，进程中的各个线程之间也可以并发，从而增加了并发度

此时，**进程**只作为除 CPU 之外的系统资源的**分配单元**（如打印机、内存地址空间等都是*分配给进程的*）

## 引入线程机制带来的变化

![](img/Pasted%20image%2020231227105538.png)

## 线程的属性

![](img/Pasted%20image%2020231227110113.png)

## 线程的实现方式

![](img/Pasted%20image%2020231227112027.png)

![](img/Pasted%20image%2020231227112039.png)

![](img/Pasted%20image%2020231227112137.png)

![](img/Pasted%20image%2020231227112227.png)

## 多线程模型

根据**用户级线程**和**内核级线程**的映射关系，划分为几种多线程模型

- **一对一模型**![](img/Pasted%20image%2020231227112358.png)
- **多对一模型**![](img/Pasted%20image%2020231227112437.png)
- **多对多模型**![](img/Pasted%20image%2020231227112552.png)
## 线程的状态与转换

![](img/Pasted%20image%2020231227112831.png)

与进程类似

![](img/Pasted%20image%2020231227112901.png)

## 线程的组织与控制

与进程类似，同样需要一个数据结构来进行管理，**线程控制块（TCB）**

![](img/Pasted%20image%2020231227113028.png)

多个线程组织起来形成一张线程表：
![](img/Pasted%20image%2020231227113424.png)


