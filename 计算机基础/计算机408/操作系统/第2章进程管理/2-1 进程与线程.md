#computer 

---
# 2.1.1 概念、组成、特征
## 进程的概念

- 程序
	- *静态*
	- 存放在磁盘里的可执行文件，一系列的指令集合
- 进程（Process）
	- 动态的
	- 程序的一次执行过程
	- *同一个程序多次执行会对应多个进程*

如何区分各个进程？

## 进程的组成

- 进程的组成
	- PCB
	- 程序段
	- 数据段

### PCB

进程被创建时，OS 会为该进程分配一个唯一的、不重复的 PID，即进程ID

操作系统需要记录的进程信息如下：

![](img/Pasted%20image%2020231226104008.png)

PCB *是进程存在的唯一标志*

**进程控制块（PCB）**：
- 进程描述信息
	- 进程标识符 PID
	- 用户标识符 UID
- 进程控制和管理信息
	- CPU、磁盘、网络流量使用情况统计
	- 进程当前状态：就绪态、阻塞态、运行态
- 资源分配清单
	- 正在使用哪些文件
	- 正在使用哪些内存区域
	- 正在使用哪些 IO 设备
- 处理机相关信息
	- 如 PSW、PC 等等各种寄存器的值（用于实现进程切换）

PCB 为操作系统管理进程所需要的信息

### 程序段、数据段

- 程序段：程序的代码（指令序列）
- 数据段：程序运行过程中产生的各种数据（如：程序中定义的变量）

这两种为进程自身使用的信息

### 程序如何运行？

![](img/Pasted%20image%2020231226104755.png)

程序段、数据段、PCB 三部分组成了**进程实体（进程映像）**

**进程**是进程实体的*运行过程*，是系统进行*资源分配*和*调度*的独立单位

## 进程的特征

- 动态性
	- *进程最基本特征*
	- 进程是程序的一次执行过程，动态产生、变化和消亡
- 并发性
	- 内存中存在多个进程实体，各进程并发执行
- 独立性
	- 独立运行、独立获得资源、独立接受调度的基本单位
- 异步性
	- 会导致并发程序的不确定性
	- 各进程按照各自独立、不可预知的速度向前推进，OS 要提供*进程同步机制*来解决异步问题
- 结构性
	- 每个进程配置一个 PCB
	- 结构上，进程=程序段+数据段+PCB

---
# 2.2.2 状态与转换

![](img/Pasted%20image%2020231226105529.png)

## 创建态、就绪态、运行态、阻塞态

- **创建态**：进程*正在被创建*
	- 此时 OS 为其分配资源、初始化 PCB
- **就绪态**：进程创建完成即进入“就绪态”，此时进程*具备运行条件*
	- CPU 无空闲则暂时不能运行
- **运行态**：CPU 空闲时，OS 选择一个就绪态的进程，*上处理机运行*
	- 此时 CPU 会执行该进程的指令序列
- **阻塞态**：进程运行过程中，可能会*请求等待某个事件的发生*
	- 如系统资源的分配，或其他进程的响应
- **中止态**
	- 进程自身结束
	- 或运行中出现不可修复错误

## 进程状态的转换

![](img/Pasted%20image%2020231226110317.png)

## 总结

![](img/Pasted%20image%2020231226110359.png)

对同一状态下的各个进程进行统一的管理，OS 将各个进程的 PCB 组织起来

---
# 2.2.3 组织与控制

目的：解决如何将各个处于不同状态的进程的 PCB 有效的组织并加以管理的问题

## 进程的组织
### 链式方式

利用对应状态的指针，将同一状态下的进程进行链式队列链接，顺序则按照各个进程之间的优先级

示意图如下：![](img/Pasted%20image%2020231226110551.png)

而阻塞队列指针则又可以根据具体的阻塞原因进行细分，如下图：![](img/Pasted%20image%2020231226110626.png)
### 索引方式

另一种组织方式，**索引方式**

建立索引表，将对应的进程存储进入对应状态的索引表中，示意图如下：![](img/Pasted%20image%2020231226110716.png)

**大部分系统使用的组织方式都是链式方式**

## 进程的控制

主要功能：对系统中所有进程实施有效管理
- 创建新进程
- 撤销已有进程
- 实现进程状态转换
- 等

*进程控制* = *实现进程状态转换*

![](img/Pasted%20image%2020231226114442.png)

**原语**：一种特殊的程序，不可以被中断
- 如果可以被中断，则可能出现 OS 中某些关键数据结构信息不统一，进而影响到 OS 的管理工作

这种不可以被中断的特性，通过两个特权指令实现这种原子性：
- **关中断**指令
- **开中断**指令

正常情况下，CPU 执行完一条指令都会检查是否有中断指令，有则执行中断指令对应的中断程序，中断程序执行完毕后再回到原来的指令。

对于原语的原子性：
- 通过*关中断指令*，让 CPU 不再检查中断信号
- 直到执行*开中断指令*之后才会恢复检查

![](img/Pasted%20image%2020231226120302.png)

![](img/Pasted%20image%2020231226120514.png)

![](img/Pasted%20image%2020231226120655.png)

![](img/Pasted%20image%2020231226120730.png)

## 程序如何运行？

在上文，进程的组成中简单描述了程序是如何运行的。这里针对 CPU 和内存之间进行针对性描述，程序是如何运行的

几个寄存器：
- PSW：程序状态字寄存器
- PC：程序计数器，存放下一条指令的地址
- IR：指令寄存器，存放当前正在执行的指令
- 通用寄存器：其他一些必要信息

这些寄存器为各个进程之间公用的，如果在某个进程执行期间发生中断，需要执行其他的进程，那么此时需要对要中断的进程的这些数据，即运行环境进行保存（保存一些*必要的寄存器信息*）
- 解决办法：在进程切换时，在 PCB 中保存

当原进程再次运行时，可以通过 PCB 恢复其运行环境（这里的运行环境，即为上文中进程切换时，切换原语所要保存/恢复的运行环境）

![](img/Pasted%20image%2020231226121735.png)

---
# 2.2.4 进程的通信

[2.1\_4\_进程通信\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1YE411D7nH?t=2.1&p=15)

---
# 2.2.5 线程和多线程模型
