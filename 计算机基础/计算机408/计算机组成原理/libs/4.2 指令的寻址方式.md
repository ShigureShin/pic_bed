#computer 

---
![](../img/Pasted%20image%2020231212100223.png)
![](../img/Pasted%20image%2020231212100220.png)

# 指令寻址

不同指令长度可能不一样，那么如何*确定下一条指令的存放地址*？
- 顺序寻址
- 跳跃寻址

计算机内部*通过程序计数器PC来指明下一条指令的存放地址*，(PC)+1 -> PC
- 如果按字节编址，每一条指令所占就不只是1了
- 采用变长指令字节构怎么办？下一条指令的地址就不能简单的+1+2了

指令字长=存储字长=16bit=2B

## 顺序寻址

(PC)+ "1" -> PC

- 这里的"1"表示*1个指令字长*
	- 实际会因为指令长度、编址方式而不同


## 跳跃寻址

- 根据*转移指令*判断下一条指令位置

取指令之后PC一定会自动+1，指向下一条应该执行的指令


# 数据寻址

- 确定*本条指令*的*地址码*的*真实地址*

指令 = 操作码 OP + 地址码 A

- 根据指令中间的寻址特征来判断根据什么方式寻址
![](../img/Pasted%20image%2020231212094114.png)

操作数的真实地址：有效地址（EA）

对于多地址指令：在每个形式地址前边加上各自的寻址特征
![](../img/Pasted%20image%2020231212094217.png)

- 假设指令字长=机器字长=存储字长，操作数为3

##  直接寻址

指令字中的形式地址A就是操作数的真实地址EA，即EA=A

- 取指令（1次），执行指令（1次）：两次访存
- 优点：简单，指令执行阶段仅访存依次，不需专门计算操作数的地址
- 缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址*不易修改*


## 间接寻址

指令地址字段给出的形式地址是操作数有效地址所在的存储单元的地址，即EA=（A）

- 取指令（1次）、执行指令（2次）
- 优点：
	- 扩大寻址范围（有效地址EA的位数大于形式地址A的位数）
	- 【汇编语言相关】便于编制程序（间接寻址可以方便完成子程序返回）
- 缺点
	- 执行阶段多次访存
![](../img/Pasted%20image%2020231212094702.png)![](../img/Pasted%20image%2020231212094729.png)

## 寄存器寻址

指令字中直接给出操作数所在的寄存器编号，即EA=Ri，操作数在由Ri所指的寄存器中
- 优点：
	- 执行阶段不访存，只访问寄存器
	- 指令字短且执行速度快，支持向量/矩阵运算
- 缺点：
	- 寄存器价格昂贵，计算机中寄存器个数有限

![](../img/Pasted%20image%2020231212095024.png)

## 寄存器间接寻址

寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址即，EA=（Ri）

![](../img/Pasted%20image%2020231212095203.png)
## 隐含寻址

在指令中隐含着操作数的地址

![](../img/Pasted%20image%2020231212095338.png)

## 立即寻址

![](../img/Pasted%20image%2020231212095437.png)

- 取指令 访存1次
- 执行指令 访存0次

- 优点
	- 指令执行阶段不访问主存，指令执行时间最短
- 缺点：
	- A的位数限制了立即数的范围

- 注意这里的访存次数只考虑了执行指令的阶段
![](../img/Pasted%20image%2020231212095638.png)

## 偏移寻址

![](../img/Pasted%20image%2020231212095715.png)

- 偏移寻址
	- 基址寻址：EA=（BR）+A
		- *程序的起始位置*
	- 变址寻址：EA=（IX）+A
		- *程序员自己决定从哪里*
	- 相对寻址：EA=（PC）+A
		- *程序计数器PC所指地址*
- 区别在于偏移的“起点”不同

### 基址寻址

EA=（BR）+A

BR：基址寄存器 Base Address Register

- 使用CPU中的基址寄存器（BR）![](../img/Pasted%20image%2020231212100103.png)
	- 面向*操作系统*，*由操作系统或管理程序确定*
	- 基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）
- 优点：
	- 便于程序“浮动”，方便多道程序并发运行![](../img/Pasted%20image%2020231212100356.png)

> 程序运行前，CPU将BR的值修改为该程序的起始地址（存在操作系统的PCB中）

- 使用某个通用寄存器![](../img/Pasted%20image%2020231212100202.png)
	- 通用寄存器可以通过汇编语言来控制哪一个寄存器读或写
		- 但如果将某个通用寄存器*作为基址寄存器使用*，则*其内容仍由操作系统决定*
	- 优点：
		- 可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）
		- 用户不需考虑自己的程序位于主存哪一空间区域，利于多道程序设计
		- 编制浮动程序（整个程序在内存中的浮动）

### 变址寻址

- 有效地址EA = 指令字中的形式地址A + 变址寄存器IX的内容
	- IX：index register
		- 可以是专用变址寄存器
		- 也可以是通用寄存器作为变址寄存器
	- *IX为偏移量*，*形式地址A不变*（基地址）
	- ![](../img/Pasted%20image%2020231212100903.png)

EA=（IX）+A

> 变址寄存器*面向用户*，程序执行过程中，变址寄存器的内容可由用户改变

- 用途：在执行某些循环操作时，每次循环范围可能不同，导致每变一次循环范围就需要增加一些直接寻址的存储

![](../img/Pasted%20image%2020231212101510.png)

- 基址&变址复合寻址![](../img/Pasted%20image%2020231212101701.png)
### 相对寻址

EA=（PC）+A

- A相对于PC（即当前执行指令的下一条指令）的偏移量，可正可负，补码表示

![](../img/Pasted%20image%2020231212101926.png)

![](../img/Pasted%20image%2020231212102210.png)

- 优点
	- 操作数的地址不是固定的，随着PC的值变化，并且与指令地址之间总是相差一个固定值，*便于程序浮动*（这里是*一段代码在程序内部*的浮动，基址寻址是程序在内存中）
	- 相对寻址广泛用于转移指令

![](../img/Pasted%20image%2020231212102445.png)


## 堆栈寻址

- 操作数存放在堆栈中，隐含使用堆栈指针（SP，stack pointer）作为操作数地址
	- 堆栈：存储器（或专用寄存器组）中一块特定的按照“后进先出LIFO”原则管理的存储区

![](../img/Pasted%20image%2020231212115700.png)

![](../img/Pasted%20image%2020231212115425.png)

- 堆栈寻址
	- 有效地址：入栈/出栈时EA的确定方式不同
	- 访存次数（指令执行期间）：硬堆栈不访存，软堆栈（主存中划分部分区间）访存1次
