#computer 

---
广度优先遍历， Breadth-First-Search，**BFS**

# 与树的广度优先遍历之间的联系

树的广度优先遍历，即**层次遍历**
1. 树非空，根节点入队
2. 队列非空，队头元素出队并访问，并将子结点依次入队
3. 重复步骤 2 直至队列为空

**共同点**：
- 都需要找到与一个结点相连的其他结点

**不同点**：
- 树中不会重复访问
- 图中可能重复访问，*需要对结点标记是否访问过*

# 算法实现

参考树的广度优先遍历：
1. 找到与一个顶点相邻的所有顶点
2. 标记哪些顶点被访问过
3. 需要一个辅助队列

需要用到两个基本操作：![](img/Pasted%20image%2020231228172817.png)

```cpp
bool visited[MAX_VERTEX_NUM]; // 访问标记数组

// BFS
void BFS(Graph G, int v)
{
	visit(v);
	visited[v] = true; // 标记顶点已被访问
	Enqueue(Q, v); // 顶点入队
	
	while(!isEmpty(Q)) // 队列不为空一直处理
	{
		DeQueue(Q, v); // 队头出队
		for(w=FirstNeighbor(G,v);w>=0;w=NextNeightbor(G,v,w))
		{// 给定结点v的第一个邻接点开始遍历
			if(!visited[w])
			{
				visit(w);
				visited[w] = true; // 标记已访问
				EnQueue(Q,w); // 顶点w入队
			}
		}
	}
}
```

![](img/Pasted%20image%2020231228173620.png)
可以发现这里是以*序号递增*的方式排列的

**邻接矩阵**方式会以序号递增形式排列，而**邻接表**中链表结点的顺序则可能不同

# 算法存在的问题

如果图为非连通图，则无法遍历完所有顶点

![](img/Pasted%20image%2020231228173818.png)

因为在 visited 数组中存储了图中结点的访问信息，所以可以根据该数组中是否存在 false 来确定是否继续进行 BFS

所以，增加如下代码：
```cpp
void BFSTraverse(Graph G)
{
	for (int i=0;i<G.vexnum;++i)
	{
		visited[i] = false; // 标记数组的初始化
	}
	InitQueue(Q);
	for(int i = 0; i<G.vexnum;++i) // 对所有顶点进行了遍历
	{
		if(!visited[i]) // 找到false的结点进行BFS
			BFS(G,i);
	}
}
```

**结论**：
- 对于无向图，调用 BFS 函数的次数 = **连通分量数**

# 复杂度分析

**空间复杂度**
![](img/Pasted%20image%2020231228174306.png)

**时间复杂度**
- 时间开销：*访问顶点* + *找各条边*
![](img/Pasted%20image%2020231228174448.png)

# 广度优先生成树

从某个顶点开始访问，依次访问经过的边进行标红，如图：

![](img/Pasted%20image%2020231228174613.png)
![](img/Pasted%20image%2020231228174652.png)

这些红边其实可以和顶点组成一个树的结构：
![](img/Pasted%20image%2020231228174725.png)

*要注意，邻接表不唯一，遍历顺序不唯一，导致最后的树也不唯一*

邻接矩阵则没有这种问题

# 广度优先生成森林

同上广度优先生成树，![](img/Pasted%20image%2020231228174842.png)

森林则是对非连通图的广度优先遍历

# 练习：有向图的 BFS 过程

![](img/Pasted%20image%2020231228174912.png)






