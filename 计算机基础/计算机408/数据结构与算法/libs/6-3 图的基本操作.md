#computer 

---

![](img/Pasted%20image%2020231228165902.png)

**数据结构的基本操作与数据结构选择的存储方式密不可分**

## 判断图 G 中某条边是否存在

**邻接矩阵**
- 是否存在边：直接去矩阵中寻找，复杂度 $O(1)$

**邻接表**
- 是否存在边：遍历边结点的链表寻找另一个边结点，最好 $O(1)$，最坏 $O(|V|)$

无向图与有向图判断方法相同

## 列出图 G 中与结点 x 邻接的边

### 无向图

**邻接矩阵**
- 遍历结点 x 所在的行或列，找出标识为存在的位置，复杂度 $O(|V|)$

**邻接表**
- 遍历结点 x 的链表结点，最好 $O(1)$，最坏 $O(|V|)$

### 有向图

**邻接矩阵**
- 同上

**邻接表**
- 出边同上，最好 $O(1)$，最坏 $O(|V|)$
- *入边*：遍历整个邻接表所有边结点，找到所有指向结点 x 的边结点，$O(|E|)$

## 在图 G 中插入顶点 x


**邻接矩阵**
- 增加行列
- 写入顶点信息

**邻接表**
- 存储结点末尾插入新节点
- 写入顶点信息

有向图类似

## 删除顶点 x 

### 无向图

**邻接矩阵**：
- 方法一：直接删除顶点 x 对应的行与列，移动行列填充空白（可能需要移动大量数据）
- 方法二：在数据结构中增加标识符，需要删除时直接修改对应位置的标识符，并重置矩阵中信息为默认值即可，复杂度为 $O(|V|)$

**邻接表**：
- 删除顶点 x 及其指向的链表数据，O(|V|)
- 同样遍历其他顶点，删除链表中存在顶点 x 的链表结点，O(1)~O(|E|)

### 有向图

**邻接矩阵**：方法同无向图

**邻接表**：
- 删除出边：删除结点的链表，O (1)~O (|V|)
- 删除入边：遍历整个邻接表，O(|E|)

## 在图 G 中添加一条边

顶点 x、y，其无向边(x,y)或有向边<x,y>不存在，则添加这条边

**邻接矩阵**：O(1)
**邻接表**：在结点后的链表中插入结点（最好是采用头插法，插入复杂度为 O (1)）

有向图类似

## 求图 G 中顶点 x 的第一个临界点

- 有，返回顶点号
- 无或不存在，返回-1

### 无向图

**邻接矩阵**：扫描顶点 x 的行，O(1)~O(|V|)

**邻接表**：直接找到边结点 x 的链表的第一个结点，O(1)

### 有向图

**邻接矩阵**
- 出边：扫描行
- 入边：扫描列
O(1)~O(|V|)

**邻接表**
- 出边：直接找到边结点 x 的链表的第一个结点，O (1)
- 入边：遍历邻接表， O (1)~O (|E|)

## 已知顶点 y 是 x 的一个邻接点，返回除 y 以外的下一个邻接点

如果 y 为最后一个，返回-1

### 无向图

**邻接矩阵**：直接扫描顶点 x 行中 y 的下一个
O (1)~O (|V|)

**邻接表**：直接找到结点 x 的链表中 y 的下一个
O(1)

## 获取/设置边的权值

**核心**：找到边/弧（与判断某条便是否存在相同）

## 图的遍历算法

**核心**：遍历算法中常用的为
- 找到顶点 x 的第一个邻接点
- 找到 x 的一个已知邻接点的下一个邻接点





