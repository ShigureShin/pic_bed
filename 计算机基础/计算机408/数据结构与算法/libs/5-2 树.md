#computer 

---
# 树的基本概念

![](img/Pasted%20image%2020231224174208.png)

从树根出发、逐级分支

- **空树**：结点树味 0 的树
- **非空树**特性
	- 树有且仅有一个*根结点*
	- 无后继结点：*叶子节点*（终端结点）
	- 有后继结点：*分支结点*（非终端结点）
	- 除了根节点外，任何一个结点都*有且仅有一个前驱*
	- 每个结点可以有 0 个或多个后继

数学上的描述：
![](img/Pasted%20image%2020231224174506.png)

树是一种*递归定义*的数据结构：
![](img/Pasted%20image%2020231224174544.png)

具体的应用：电脑中文件夹的层级结构、思维导图的各个结点

## 基本术语

### 结点之间的关系描述

- 两个结点的**路径**：只能从上往下
- **路径长度**：经过几条边

### 结点、树的属性描述

- 结点的**层次**（**深度**）-- 从上往下数（默认从 1 开始）
- 结点的**高度** -- 从上往下数
- 树的**高度**（深度）-- 总共多少层

- **结点的度** -- 有几个分支
- **树的度** -- 各节点的度的*最大值*

![](img/Pasted%20image%2020231224175241.png)

## 有序树 v.s. 无序树

- **有序树**：逻辑上，树中结点的各子树从左至右是*有次序*的，不能互换
- **无序树**：逻辑上，树中结点的各子树从左至右是*无次序*的，可以互换

*有无次序要具体根据需要存储的结点元素，以及结点的左右位置是否反应了某些逻辑关系*

## 树 v.s. 森林

森林：m（m>=0）棵互不相交的树的集合
- 允许有空森林

![](img/Pasted%20image%2020231224175516.png)

# 树的常考性质

- 节点数 = 总度数 + 1
- **度为 m 的树**、**m 叉树**的区别![](img/Pasted%20image%2020231224175819.png)
- ![](img/Pasted%20image%2020231224175834.png)
- ![](img/Pasted%20image%2020231224175935.png)（等比数列求和问题，*思考*：最少有多少个节点？）
	- 高度为 h 的 m 叉树至少有 h 个结点
	- 高度为 h 的度为 m 的树至少有 h+m-1 个结点（要保证至少有一个节点处为 3 个分支）

- ![](img/Pasted%20image%2020231224180221.png)
# 树的存储

![](img/Pasted%20image%2020231227160840.png)

树，递归定义的数据结构

要么是空树、要么是由一个根节点和几个互不相交的子树组成。

*注意*这里的子树不一定是两个

## 双亲表示法（顺序存储）

![](img/Pasted%20image%2020231227161130.png)

实现操作：增删查改

- **增加结点**
	- 直接在列表中增加结点数据 + 父节点“指针”即可，*无需按照逻辑顺序存储*
	- *更新树中存储的结点数信息*
- **删除叶子结点**
	- 方案一：删除 data，并将 parent 重置为-1
	- *方案二*：用最后一个存储位置的结点信息覆盖掉要删除的结点信息
	- *更新树中存储的结点数信息*
	- 思考：如果要删除的结点不是叶子节点该如何操作？
		- 需要找到该结点的全部子节点
		- 涉及到一个遍历查找操作
- **查找结点**
	- 由于是顺序存储方式，找到结点的父节点很简单，但是找到子节点需要从头开始遍历
	- 同时，如果采用*删除结点*中的方案一，会导致在遍历过程中进行几次无效的访问，影响了正常的遍历节奏

## 孩子表示法（顺序+链式存储）

每个节点：data + firstChild 的指针

![](img/Pasted%20image%2020231227162002.png)

- 增删查

## 孩子兄弟表示法（链式存储）

*使用二叉链表存储的树*，存储视角看形态上和二叉树类似

![](img/Pasted%20image%2020231227162235.png)

涉及到了树和二叉树之间相互转换的问题，此时就可以利用二叉树的相关操作来处理

## 森林和二叉树转换

本质：二叉链表存储森林

**森林转二叉树**：
- 先对每个树进行二叉树的转换，再将互不相交的几个树的根节点按照兄弟节点的方式进行连接

![](img/Pasted%20image%2020231227162444.png)

**二叉树转森林**：
- 注意二叉树中结点的右节点，此时表示的是该结点的兄弟结点

# 树和森林的遍历

![](../img/Pasted%20image%2020231227163048.png)

与二叉树的遍历类似

## 先根遍历

![](../img/Pasted%20image%2020231227163630.png)

## 后根遍历（深度优先）

![](../img/Pasted%20image%2020231227163838.png)

注意这里，*树的后跟遍历*和*二叉树的中序遍历*序列相同

## 树的层次遍历（广度优先遍历）

同样需要借助队列实现

![](../img/Pasted%20image%2020231227164001.png)

可以发现，树的层次遍历是优先访问结点的子节点，即**广度优先**；
而先前的后根遍历则是优先访问最底层的结点，即**深度优先**

## 森林的先序遍历

树是递归定义的一种数据结构，而森林其实是对树的又一种递归定义。去掉森林中每棵树的根节点后，其各个子树又组成森林

![](../img/Pasted%20image%2020231227164341.png)

也可以将森林转换为二叉树，再对二叉树进行先序遍历

## 森林的中序遍历

![](../img/Pasted%20image%2020231227164438.png)

同样，等同于二叉树的中序遍历




