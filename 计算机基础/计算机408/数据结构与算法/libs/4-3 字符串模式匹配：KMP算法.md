#computer 

---
朴素匹配算法的优化

# KMP 算法原理

思考朴素匹配算法中：如果某一次扫描中子串不匹配，则需要将主串的扫描指针回溯 m-1 步，即前进 m 步，后退 m-1 步

在这种最坏的情况下，时间复杂度为 O(nm)

- 子串与模式串*部分匹配*的时候，主串的扫描指针经常性回溯，导致时间开销增加

所以这里的核心思想，就是解决主串的指针 i 经常性回溯的问题，或者说减少这种回溯的次数，这里我们想要让主串的 i 连续向后移动，而经常性改变模式串中开始对比的 j 的位置

![](../img/Pasted%20image%2020231214160822.png)

假如说本次对比中发生了不匹配，那么此时已经对比过的串的长度为 j ，则主串中开始匹配的位置为 i-j+1，由于模式串长度为 m，按照朴素法下一次开始匹配的位置为 (i-j+1)+1

这种想法的目的实际上是确保从 i-j+1 到 i 这段子串中会不会出现正好匹配的起始位置

而这段子串，其实就是模式串的 1~j-1 这段子串

如果，我们假设这段子串中出现了正好匹配的起始位置，我们记这个位置为 k ，那么从这个位置 k 到 j-1 的这段子串，一定可以和以模式串的开头位置 1 开始的同样长度的子串是完全匹配的

为了方便描述，这里我们约定两个定义：
- 串的**前缀**：*包含*第一个字符，且*不包含*最后一个字符的子串
- 串的**后缀**：*包含*最后一个字符，且*不包含*第一个字符的子串

故，我们可以将问题转换成，在每次不匹配情况发生时，在模式串中这个不匹配的位置 j 之前的 1~j-1 这段子串中，寻找完全匹配的前缀和后缀（只寻找最长的相等前后缀）

那么此时，如果我们能找到这样的前后缀，那么说明只需要再确认已经匹配的后缀子串之后是否会和模式串对应部分相匹配即可，即将下一子进行对比的 j 的位置修改为后缀长度+1 即可

回想字符串模式匹配问题，我们肯定是在已知主串和模式串的前提下进行的，而根据我们上述的思考，是否可以提前假设在模式串的不同位置发生不匹配时，模式串指针 j 所应该回溯的位置呢？

即，我们假定在模式串的第 j 个位置发生了不匹配，那么我们如果提前知道了每个位置不匹配时所需要改变的 j 的目标值，则我们只需要进行查表，我们将这个表格存入一个名为 next 的数组中


- KMP 算法代码实现：
```c
int Index_KMP(SString S, SString T)
{
	int i=1,j=1;
	int next[T.length+1];
	get_next(T, next); // 获取模式串的next数组
	while(i<=S.length && j<=T.length)
	{
		if(j==0||S.ch[i]==T.ch[j])
		{
			++i;
			++j; // 匹配则继续比较后续
		}
		else
		{
			j=next[j]; // 模式串向右移动
		}
	}
	if(j>T.length)
		return i-T.length; // 匹配成功
	else
		return 0;
}
```

此时时间复杂度可以认为是 O(n+m)

![](../img/Pasted%20image%2020231214165144.png)

# 求 next 数组

注意这里使用的字符串结构

![](../img/Pasted%20image%2020231214171633.png)

- 计算 next 数组代码如下：

```c
void get_next(SString T, int next[])
{
	int i=1, j=0;
	next[1]=0; // 固定值
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j])
		{
			++i;++j;
			// pi=pj则next[j+1]=next[j]+1
			next[i]=j;
		}
		else
		{
			// 继续循环
			j=next[j];
		}
	}
}
```

# 进一步优化

- 针对 next 数组的优化

在计算 next 数组时，我们排除了一些重复的比较过程，但实际上利用 next 数组还是会进行一些不必要的重复比较

比如，本次匹配失败，模式串的这个位置字符为"a"，按照 next 数组我们需要找到对应的位置 j 来重新进行比较，但如果此时进行下一次比较的这个位置 j 的字符，同样也为"a"呢？

按照上一轮的对比，我们已经知道主串的这个位置不可能是字符"a"了，所以这次的比较属于是完全无用的一次比较

但如果位置 j 的字符，不是"a"，则直接进行比较

综上，我们需要在利用 next 数组获取下一次 j 的位置前，判断一次前后两处字符是否相同

```c
nextval[1]=0;
for(int j=2;j<=T.length;j++)
{
	if(T.ch[next[j]]==T.ch[j])
		nextval[j]=nextval[next[j]];
	else
		nextval[j]=next[j];
}
```




