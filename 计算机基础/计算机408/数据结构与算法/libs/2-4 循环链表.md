#computer 

---

# 循环单链表

![](img/Pasted%20image%2020231209143813.png)

- 注意：初始化时要将*循环单链表*的 next 指向自身
- 判断*循环单链表*是否为空：
	- `L->next == L`
	- 即是否头节点指针指向自己

![](img/Pasted%20image%2020231209143901.png)

- 判断*循环单链表*的表尾节点
	- `p->next==L`
	- 看节点的 next 是否指向头节点

- **循环单链表**
	- 从一个节点出发可以找到其他任何一个节点

- 很多时候对链表的操作都是在**头部或者尾部**
	- 一个技巧，可以让 L 指向表尾元素，从而可以实现访问尾部节点时的 O (1)复杂度，同时还可以利用表尾的 next 访问表头
	- 但要注意插入、删除的时候需要去修改 L 

# 循环双链表

![](img/Pasted%20image%2020231209144302.png)

- next 形成一个循环
- prior 形成一个循环
- 初始化时：next 和 prior 都指向头节点
- *判空*：`L->next==L`
- *判断表尾*节点p：`p->next==L`

- 节点 p 之后*插入* s 节点
	- 和双链表中的插入代码进行对比
	- 尤其是对表尾元素进行处理时
- 循环双链表的删除
  - 同样在表尾元素进行处理时的特殊情况

- **关键问题**
	- 如何判空
	- 如何判断节点为表尾还是表头节点（核心：*实现遍历*，所以需要有一个停止遍历循环的未知，即表头/表尾）
	- 如何在表头、表中、表尾插入/删除一个节点（*考虑着三种情况，以保证操作考虑到了一些特殊的可能情况*）