#computer 

- 基本概念
- 基本术语
	- 结点之间的关系描述
	- 结点、树的属性描述
	- 有序树、无序树
	- 森林
---

# 树的基本概念

![](img/Pasted%20image%2020231224174208.png)

从树根出发、逐级分支

- **空树**：结点树味 0 的树
- **非空树**特性
	- 树有且仅有一个*根结点*
	- 无后继结点：*叶子节点*（终端结点）
	- 有后继结点：*分支结点*（非终端结点）
	- 除了根节点外，任何一个结点都*有且仅有一个前驱*
	- 每个结点可以有 0 个或多个后继

数学上的描述：
![](img/Pasted%20image%2020231224174506.png)

树是一种*递归定义*的数据结构：
![](img/Pasted%20image%2020231224174544.png)

具体的应用：电脑中文件夹的层级结构、思维导图的各个结点

## 基本术语

### 结点之间的关系描述

- 两个结点的**路径**：只能从上往下
- **路径长度**：经过几条边

### 结点、树的属性描述

- 结点的**层次**（**深度**）-- 从上往下数（默认从 1 开始）
- 结点的**高度** -- 从上往下数
- 树的**高度**（深度）-- 总共多少层

- **结点的度** -- 有几个分支
- **树的度** -- 各节点的度的*最大值*

![](img/Pasted%20image%2020231224175241.png)

## 有序树 v.s. 无序树

- **有序树**：逻辑上，树中结点的各子树从左至右是*有次序*的，不能互换
- **无序树**：逻辑上，树中结点的各子树从左至右是*无次序*的，可以互换

*有无次序要具体根据需要存储的结点元素，以及结点的左右位置是否反应了某些逻辑关系*

## 树 v.s. 森林

森林：m（m>=0）棵互不相交的树的集合
- 允许有空森林

![](img/Pasted%20image%2020231224175516.png)

# 树的常考性质

- 节点数 = 总度数 + 1
- **度为 m 的树**、**m 叉树**的区别![](img/Pasted%20image%2020231224175819.png)
- ![](img/Pasted%20image%2020231224175834.png)
- ![](img/Pasted%20image%2020231224175935.png)（等比数列求和问题，*思考*：最少有多少个节点？）
	- 高度为 h 的 m 叉树至少有 h 个结点
	- 高度为 h 的度为 m 的树至少有 h+m-1 个结点（要保证至少有一个节点处为 3 个分支）

- ![](img/Pasted%20image%2020231224180221.png)

---
# 二叉树

- 二叉树
	- 基本概念
	- 特殊的二叉树
		- 满二叉树
		- 完全二叉树
		- 二叉排序树
		- 平衡二叉树

## 基本概念

![](img/Pasted%20image%2020231224180435.png)

![](img/Pasted%20image%2020231224180443.png)

特点：
- **每个结点最多有 2 个子树**
- **注意**：二叉树为有序树，及左右子树不能颠倒（*和度为 2 的有序树进行区别*）

## 二叉树的五种状态

![](img/Pasted%20image%2020231224180619.png)

## 几种特殊的二叉树

### 形态上特殊的二叉树

#### 满二叉树

![](img/Pasted%20image%2020231224183025.png)

#### 完全二叉树

完全二叉树中，如果某个结点只有一个孩子结点，那么一定是左结点![](img/Pasted%20image%2020231224183108.png)
#### 二叉排序树

![](img/Pasted%20image%2020231225152447.png)

#### 平衡二叉树

![](img/Pasted%20image%2020231225152606.png)

### 功能上特殊的二叉树

## 二叉树的常考性质

可以套用部分树的性质

![](img/Pasted%20image%2020231225153002.png)

![](img/Pasted%20image%2020231225153038.png)

![](img/Pasted%20image%2020231225153045.png)

## 完全二叉树的常考性质

![](img/Pasted%20image%2020231225153210.png)

另一个公式：![](img/Pasted%20image%2020231225153242.png)
注意两个公式中，向上取整和向下取整的书写方式

![](img/Pasted%20image%2020231225153315.png)

![](img/Pasted%20image%2020231225153531.png)

## 二叉树的存储结构

### 顺序存储

结点：数组 + 标记（是否为空）

完全二叉树的顺序存储，按照编号依次存储
![](img/Pasted%20image%2020231225154432.png)

实现的操作：
- 找到结点 i 的
	- 左孩子：2i
	- 右孩子：2i+1
	- 父节点：floor(i/2)
	- 所在层次：$ceil(\log_2(n+1))$ 或 $floor(\log_2n)+1$

若*完全二叉树*中共有 n 个结点，则
- 判断 i 是否有左孩子：2i <= n
- 判断 i 是否有右孩子：2i+1 <= n
- 判断 i 是否是叶子/分支结点：i > $floor(n/2)$

对于非完全二叉树，*要把二叉树的结点编号与完全二叉树对应起来*

![](img/Pasted%20image%2020231225155006.png)

![](img/Pasted%20image%2020231225155206.png)

则找到对应结点 i 的左孩子、右孩子、父节点、所在层次，和完全二叉树的判断条件一致

而对于下面三个判断，就不可以使用上述的条件了
- 判断 i 是否有左孩子
- 判断 i 是否有右孩子
- 判断 i 是否是叶子/分支结点
只能根据此时存储方式，先找到结点 i 的左孩子/右孩子的结点编号，然后去节点中查看空标签来确定

这种二叉树对于存储空间的利用不完全

*最坏的情况*：高度为 h 且只有 h 个结点的单支树（结点只有右孩子），也至少需要 $2^h-1$ 个存储单元

**结论**：二叉树的顺序存储结构，只适合存储完全二叉树。

实际应用中很少使用顺序存储方式来存储二叉树

### 链式存储

![](img/Pasted%20image%2020231225155615.png)

假设一个二叉树结点总数为 n，则该二叉树中指针域个数为 2n，而这些指针域中真正有效存储了结点的个数为 n-1（去掉根节点剩下的都连接一个父节点），所以：
- 这些指针域中存在 n+1 个**空指针域**，即无效指针，或指向 NULL
- *这些指针域可以用于构造线索二叉树*
- 由于这种建立方式每个结点都有左右两个指针，所以这种实现方式也被称为**二叉链表**

具体的构建方式
![](img/Pasted%20image%2020231225160101.png)

- 找到结点 i 的左右孩子：直接通过指针访问
- 找到结点 i 的父节点：只能从根结点开始遍历
	- *如果实际应用情况下，需要经常查找父节点，可以给结点中增加一个父节点指针*（**三叉链表**）

## 二叉树的遍历

利用树的层次结构来遍历，**层次遍历**

而本节的先/中/后序遍历：利用二叉树的递归特性确定的次序规则

- 二叉树的递归特性
	- 要么是*空二叉树*
	- 要么是“*根节点+左子树+右子树*”组成的二叉树，根据访问顺序来分为三种遍历
		- 先序遍历：NLR 根左右
		- 中序遍历：LNR
		- 后序遍历：LRN
	- （根节点的顺序）

![](img/Pasted%20image%2020231225162203.png)

- **分支节点逐层展开法**
	- ![](img/Pasted%20image%2020231225162513.png)

![](img/Pasted%20image%2020231225162600.png)

代码实现：

![](img/Pasted%20image%2020231225162808.png)

三种遍历方式：更换 visti 和递归遍历顺序更换一下

计算树的深度：![](img/Pasted%20image%2020231225163633.png)

## 二叉树的层序遍历

![](img/Pasted%20image%2020231225164032.png)

- 利用一个辅助队列
- 根节点入队
- 队列非空，头节点出队并访问，并将左右结点依次插入队尾（如果有）
- 重复上一步直到队列为空

这里使用的是链式队列

![](img/Pasted%20image%2020231225164639.png)

入队保存的其实是元素指针

## 遍历序列构造二叉树

以中序遍历为例

![](img/Pasted%20image%2020231225164909.png)

给定一个二叉树其中序遍历序列唯一，但给定中序遍历序列并不能唯一确定一个二叉树的结构

前序、后续、层次遍历也同理，也不能通过遍历序列唯一确定一个二叉树的结构

**结论**：只给出一棵二叉树的前中后层序遍历序列中的一种，不能唯一确定一棵二叉树

![](img/Pasted%20image%2020231225165108.png)

### 前序+中序遍历

前序遍历序列：根+左+右，确定根节点
中序遍历序列：左+根+右，确定根节点左子树的根节点

![](img/Pasted%20image%2020231225165208.png)

## 后序+中序遍历

![](img/Pasted%20image%2020231225165538.png)

## 层序+中序遍历

![](img/Pasted%20image%2020231225165747.png)


**总结**：
- 找到*根节点*
- 根据中序序列划分左右子树
- 再找到左右子树的根节点


[5.3\_4\_线索二叉树的概念\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1b7411N798?t=1.0&p=49)
